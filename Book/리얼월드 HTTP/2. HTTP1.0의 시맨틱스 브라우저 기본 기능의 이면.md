앞 장에서 HTTP의 기본 네 요소를 설명했다.
- 메서드와 경로
- 헤더
- 바디
- 스테이터스 코드
브라우저가 기본 요소들을 어떻게 응용하고 기본 기능을 실현하는지 살펴본다.
# 1 단순한 폼 전송(x-www-form-urlencoded)
HTTP/1.0의 바디 수신은 클라이언트가 지정한 콘텐츠가 그대로 저장될 뿐이다. 기본적으로 한 번 HTTP가 응답할 때마다 한 파일밖에 반환하지 못하기 때문이다. 즉 응답의 본체를 지정한 바이트 수만큼 읽어오면 그만이다. 
폼을 사용한 `POST` 전송에는 몇 가지 방식이 있다. 가장 단순한 전송 방식은 다음과 같다.
```HTML
<form method="POST">
	<input name="title">
	<input name="author">
	<input name="submit">
</form>
```
일반적인 웹에서 볼 수 있는 폼이며 method에는 `POST`가 설정돼 있다. 다음처럼 curl 커맨드를 사용하면 폼과 같은 형식으로 전송할 수 있다.
```shell
$ curl --http1.0 -d title="The Art of Community" -d author="Jono Bacon" http://localhost:8080
```
curl 커맨드는 `-d`옵션이 지정도미ㅕㄴ 브라우저와 똑같이 헤더로 `Content-Type:application/x-www-form-urlencoded`를 설정한다. 이때 바디는 키와 값이 `=`로 연결되고, 각 항목이 `&`로 연결된 문자열이 된다.
```
title=The Art of Community&author=Jono Bacon
```
실제로는 이 커맨드가 생성하는 바디는 브라우저의 웹 폼에서 전송하는 것과는 약간 차이가 있다. curl에서는 실제 보내는 데이터에 구분문자인 `&`와 `=`가 들어있는 경우 그대로 연결해버린다. 브라우저는 RFC 1866에서 책정한 변환 포맷에 따라 변환을 실시한다. 이 포맷에서는 알파벳, 수치, 별표, 하이픈, 마침표, 언더스코어의 여섯 종류 문자 외에는 변환이 필요하다.
```
title=Head+First+PHP+%26+MySQL&author=Lynn+Beighley%2C+Michael+Morrison
```
curl에는 이와 가까운 기능을 하는 `data-urlencode`가 있다. 이때 RFC 3986에서 정의된 방법으로 변환된다.
웸 폼의 GET의 경우 바디가 아니라 쿼리로서 URL에 부여된다고 RFC 1866에 정의되어 있다.

# 2 폼을 이용한 파일 전송
HTML의 폼에서는 옵션으로 멀티파트 폼 형식이라는 인코딩 타입을 선택할 수 있다. 옵션을 사용해서 파일을 보낼 수 있다. RFC 1867에 정의돼 있다. 
```
<form action="POST" enctype="multipart/form-data">
</form>
```
보통 HTTP 응답은 한 번에 한 파일씩 반환하므로, 빈 줄을 찾아 그곳부터 `Content-Length`로 지정된 바이트 수만큼 읽기만 하면 데이터를 통째로 가져올 수 있다. 하지만 멀티파트를 이용하는 경우는 한 번의 요청으로 복수의 파일을 전송할 수 있으므로 받는 쪽에서 파일을 나눠야 한다.
다음은 크롬 브라우저의 멀티파트 폼 형태로 출력했을 때의 헤더이다. 경계 문자열인 하나의 속성이 추가적으로 부여돼있다.
```
Content-Type: multipart/form-data; boundary=---WebKitFormBoundaryy0YfbccgoID172j7
```
바디는 다음과 같이 경계 문자열로 두 개의 블록으로 나뉜 것을 알 수 있다. 각각의 블록 내부도 HTTP와 같은 구성으로, 헤더+빈 줄+콘텐츠로 되어있다. 헤더에는 `Content-Disposition` 이라는 항목이 포함된다. Disposition은 기질, 성질이란 뜻으로, 대체로 `Content-Type`과 같은 것이다. 여기서는 항목의 이름을 붙이고 폼의 데이터라고 선언했다.
```
------WebKitFormBoundaryy0YfbccgoID172j7
Content-Disposition: form-data; name="title"

The Art of Community
------WebKitFormBoundaryy0YfbccgoID172j7
Content-Disposition: form-data; name="author"

Jono Bacon
------WebKitFormBoundaryy0YfbccgoID172j7--
```
여러 줄인 `X-www-form-urlencoded`와 다를 바 없지만 파일을 전송해보면 다르다.
```
<input name="attachment-file" type="file"
```
이 폼을 전송하면 다음과 같은 결과가 표시된다. `multipart/form-data`는 항목마다 추가 메타정보를 태그로 가질 수 있다. 파일을 전송할 때 이름, 파일명, 파일 종류, 그리고 파일 내용이라는 세 가지 정보가 전송되는 것을 알 수 있다. `x-www-form-urlencoded`는 파일 전송에 필요한 정보를 모두 보낼 수 없어, 파일 이름만 전송해버린다.
```
------WebKitFormBoundaryy0YfbccgoID172j7
Content-Disposition: form-data; name="attachment-file"; filename="test.txt"
Content=type: text/plain

hello world

------WebKitFormBoundaryy0YfbccgoID172j7--
```
`-F`를 사용하면 curl 커맨드는 `enctype="multipart/form-data`가 설정된 폼과 같은 형식으로 송신한다. `-d`와 `-F`를 섞어 쓸 수는 없다. 
```
#파일 내용을 test.txt에서 취득. 파일명은 로컬 파일명과 같다. 형식도 자동 설정.
$ curl --http1.0 -F attachment-file@test.txt http://localhost:8080

#파일 내용을 test.txt에서 취득. 형식은 수동 설정.
$ curl --http1.0 -F "attachment-file@test.txt;type=text/html" http://localhost:8080

#파일 내용을 test.txt에서 취득. 파일명은 지정한 파일명을 이용.
$ curl --http1.0 -F "attachment-file@test.txt;filename=sample.txt" http://localhost:8080
```
# 3 폼을 이용한 리디렉트
스테이터스 코드를 사용한 리디렉트의 경우 몇 가지 제한이 있다.
- URL에는 2000자 이내라는 기준이 있어 `GET`의 쿼리로 보낼 수 있는 데이터양에 한계가 있다.
- 데이터가 URL에 포함되므로, 전송하는 내용이 액세스 로그 등에 남을 우려가 있다.
이런 문제를 피하고자 종종 이용되는 방법이 HTML의 폼을 이용한 리디렉트이다. 서버로부터는 리디렉트할 곳으로 보내고 싶은 데이터가 `<input type="hidden">` 태그로 기술된 HTML이 되돌아 온다. 폼에서 보내는 곳이 리디렉트할 곳이다. 브라우저가 이 HTML 을 열면 로드 직후 발생하는 이벤트로 폼을 전송하므로 즉시 리디렉트해 이동하게 된다.
순간적으로 빈 페이지가 표시된다는 점과 전환 버튼이 표시되긴 하지만 자바스크립트가 비활성화 되어 있으면 자동으로 전환되지 않는다는 단점이 있다.

# 4 콘텐트 니고시에이션


#CS #Network 