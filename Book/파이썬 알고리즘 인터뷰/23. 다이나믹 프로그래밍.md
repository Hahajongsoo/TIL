- 문제를 각각의 작은 문제로 나누어 해결한 결과를 저장해뒀다가 나중에 큰 문제의 결과와 합하여 풀이하는 알고리즘이다.
- 문제의 최적 해결 방법이 부분 문제에 대한 최적 해결 방법으로 구성되는 경우의 문제, 최적 부분 구조를 갖고 있는 문제를 풀이할 수 있다.
	- 그리디 알고리즘은 항상 그 순간에 최적이라고 생각되는 것을 선택하면서 풀이해 나가는 거이고, 다이나믹  프로그래밍은 중복된 하위 문제들의 결과를 저장해뒀다가 풀이해 나간다는 차이가 있다.
	- 중복되지 않는 문제들은 다이나믹 프로그래밍으로 풀지 않는다. 병합 정렬, 퀵 정렬과 같은 분할 정복 알고리즘은 '중복된 하위 문제들'을 푸는 것이 아니기 때문에 다이나믹 프로그래밍으로 분류하지 않는다.
- 대부분의 재귀 알고리즘은 최적 부분 구조 문제를 풀 수 있다. 

| 알고리즘            | 풀이 가능한 문제들의 특징                                                                  | 풀이 가능한 문제 및 알고리즘                                        |
| ------------------- | ------------------------------------------------------------------------------------------ | ------------------------------------------------------------------- |
| 다이나믹 프로그래밍 | - 최적 부분 구조(Optimal Substructure) </br> - 중복된 하위 문제들(Overlapping Subproblems) | - 0 - 1 배낭 문제 </br> - 피보나치 수열 </br> - 다익스트라 알고리즘 |
| 그리디 알고리즘     | - 최적 부분 구조(Optimal Substructure) </br> - 탐욕 선택 속성(Greedy Choice Property)      | - 분할 가능 배낭 문제 </br> - 다익스트라 알고리즘                   |
| 분할 정복           | - 최적 부분 구조(Optimal Substructure)                                                     | - 병합 정렬 </br> - 퀵 정렬                                         | 

## 최적 부분 구조
서울에서 부산까지 가는 최단 경로를 찾는 간단한 예를 들어본다. 
- 서울에서 대구까지 가는 경로 3가지
- 대구에서 부산까지 가는 경로 3가지
- 서울에서 부산까지 가는 최단 경로는 서울에서 대구까지 가는 최단 경로와 대구에서 부산까지 가는 최단 경로의 합이다.
- 즉 1번 문제와 2번 문제의 해결 방법의 합이다. 따라서 문제의 최적 해결 방법은 부분 문제에 대한 최적 해결 방법으로 구성된다.
이러한 구조를 최적 부분 구조라 하며, 이런 유형의 문제는 분할 정복으로 풀 수 있다. 또한 다이나믹 프로그래밍과 그리디 알고리즘으로 접근해볼 수 있는 문제의 후보가 된다. 

## 중복된 하위 문제들
다이나믹 프로그래밍과 다른 문제들의 결정적인 차이는 중복된 하위 문제들을 갖는다는 점이다. 예를 들어, 피보나치 수열에서 $f(3) = f(2) + f(1)$ 이고 $f(4) = f(3) + f(2)$ 이다. 이처럼 피보나치 수열을 재귀로 풀면 반복적으로 동일한 하위 문제들이 발생한다.
