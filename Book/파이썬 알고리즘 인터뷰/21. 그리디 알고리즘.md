> 그리디 알고리즘은 글로벌 최적을 찾기 위해 각 단계에서 로컬 최적의 선택을 하는 휴리스틱 문제 해결 알고리즘이다.

- 눈앞의 이익만을 좇는 알고리즘이다. 
- 대부분의 경우 뛰어난 결과를 도출하지 못하지만, 드물게 최적해를 보장하는 경우도 있다. 
- 최적해를 찾을 수 있으면 그것을 목표로 삼고, 찾기 어려운 경우에는 주어진 시간 내에 그런대로 괜찮은 해를 찾는 것을 목표로 삼는다. 
- 탐욕 선택 속성(Greedy Choice Property)을 갖고 있는 최적 부분 구조(Optimal Substructure)인 문제들에서 잘 작동한다.
	- 탐욕 선택 속성: 앞의 선택이 이후 선택에 영향을 주지 않는 것
	- 최적 부분 구조: 문제의 최적 해결 방법이 부분 문제에 대한 최적 해결 방법으로 구성되는 경우
- 최적 부분 구조 문제를 푼다는 점에서 DP와 비교된다. 하지만 서로 풀 수 있는 문제의 성격이 다르며 접근 방식 또한 다르다.
	- DP: 하위 문제에 대한 최적의 솔루션을 찾은 다음, 이 결과들을 결합한 정보에 입각해 전역 최적 솔루션에 대한 선택을 한다.
	- 그리디: 각 단계마다 로컬 최적해를 찾는 문제로 접근해 문제를 더 작게 줄여나가는 형태

### 배낭 문제(Knapsack Problem)
- 배낭에 담을 수 있는 무게의 최댓값이 정해져 있고 각각 짐의 가치와 무게가 있는 짐들을 배낭에 넣을 때 가치의 합이 최대가 되도록 짐을 고르는 방법을 찾는 문제
- 짐을 쪼갤 수 있는 경우(그리디 알고리즘으로 해결)와 짐을 쪼갤 수 없는 경우(다이나믹 프로그래밍으로 해결)로 나뉜다.
- 짐을 쪼갤 수 있는 경우 단가가 높은 순으로 배낭에 넣고 마지막 짐은 배낭의 남는 무게 만큼 쪼개어 넣으면 된다.

### 동전 바꾸기 문제
- 동전의 액면이 10원, 50원, 100원 처럼 이전 액면의 배수 이상이 되면 그리디 알고리즘으로 풀 수 있다. 
- 160원의 경우 100 + 50 + 10 으로 주면 된다.
- 하지만 80원이 존재하는 경우 그리디 알고리즘으로 해결하려하면 80원 2개로 지불하는 경우를 찾을 수 없다. 이 경우 다이나믹 프로그래밍으로 해결한다.

### 가장 큰 합
- 그리디 알고리즘의 실패 사례로 트리에서 노드가 정렬되어 있지 않은 경우 매번 가장 큰 합을 선택하는 것으로는 전체에서 가장 큰 합을 구할 수 없다.