# 파이썬에 대한 이해
- 코딩 테스트를 치를 언어로 선택했다면, 적어도 그 언어의 세부 구현까지 상세히 알고 있어야 문제를 제대로, 신속학, 정확하게 풀 수 있다. 언어의 문법조차 제대로 숙지하지 않은 상태에서는 코딩 테스트를 잘 치러낼 수 없다.
- 어설프게 알고 있는 것은 더욱 위험하다. 대부분의 삽질은 제대로 알지 못하는 데에서 비롯된다. 언어는 도구에 불과하다고 주장하지만, 아무리 쉬운 도구라도 제대로 사용법을 숙지해야 제대로 사용할 수 있다.
- CPython의 내부 구현을 살펴보면서 원리를 정확히 이애하며 살펴본다.

# 파이썬 문법
기본적인 파이썬 문법을 알고 있다고 해도 놓치기 쉬운, 개발 역량을 한 단계 높여줄 파이썬의 고급 문법을 하나씩 살펴보면서 파이썬의 특징을 알아본다.

## 인덴트
파이썬의 대표적인 특징이기도 한 인덴트는 공식 가이드인 PEP 8에 따라 공백 4칸을 원칙으로 한다. 이외에도 PEP 8에는 다음과 같은 기준들이 포함되어 있다.
- 첫 번째 줄에 파라미터가 있다면, 파라미터가 시작되는 부분에 보기 좋게 맞춘다.
- 첫 번째 줄에 파라미터가 없다면, 인덴트를 한 번 더 추가하여 다른 행과 구분되게 한다.
이러한 모든 방식을 고민하면서 구분하기는 쉽지 않다. 이러한 경우 IDE의 포매터를 사용하는 것이 도움이 된다.

## 네이밍 컨벤션
파이썬의 변수명 네이밍 컨벤션은 각 단어를 `_` 로 구분하여 표기하는 스네이크 케이스를 따른다. 함수명도 마찬가지이다.

## 타입힌트
동적 타이핑 언어이지만 타입을 지정할 수 있는 타입힌트가 PEP 484 문서에 추가됐다. 함수를 정의할 때 타입힌트를 사용하지 않는 경우 함수의 파라미터에는 어떤 값을 넘겨야하는지 알 수 없고 함수의 리턴값이 무엇인지도 알 수 없다. 타입힌트를 사용하게 되면 파라미터에 어떤 값을 넘겨줘야하는지 함수의 리턴값은 어떤 값인지도 알 수 있다. 하지만 강제 규약이 아니다보니 여전히 동적으로 할당될 수 있으므로 주의가 필요하다.
```
>>> a: str = 1
>>> type(a)
<class 'int'>
```
`mypy`를 사용하면 타입 힌트에 오류가 없는지 자동으로 확인할 수 있다.

## 리스트 컴프리헨션
파이썬은 `map, filter`와 같은 함수형 기능을 지원하며 람다 표현식도 지원한다. 사실 파이썬의 훨씬 더 유용한 기능은 리스트 컴프리헨션이다. 기존 리스트를 기반으로 새로운 리스트를 만들어내는 구문이다. 『Effective Python 파이썬 코딩의 기술』(길벗, 2016) 에서도 map과 filter 대신 리스트 컴프리헨션을 사용하자는 절이 있을 정도로 리스트 컴프리헨션은 다방면에 유용하게 활용되며, 무엇보다 람다 표현식에 map이나 filter를 섞어서 사용하는 것에 비해 가독성이 훨씬 높다.

다음은 홀수인 경우 2를 곱해 출력하라는 리스트 컴프리헨션이다.
```
>>> [n * 2 for n in range(1, 10 + 1) if n % 2 == 1]
[2, 6, 10, 14, 18]
```
리스트컴프리헨션은 딕셔너리에서도 사용가능하다.  리스트 컴프리헨션은 가독성이 좋은 편이지만 이 또한 무리하게 복잡하게 작성할 경우 가독성을 떨어뜨릴 수 있으므로 적절히 사용하는게 중요하다. 대체로 표현식은 2개를 넘지 않아야 한다.

## 제너레이터
제너레이터는 루프의 반복 동작을 제어할 수 있는 루틴 형태를 말한다. 예를 들어 임의의 조건으로 숫자 1억 개를 만들어내 계산하는 프로그램을 작성한다고 가정해보자. 이 경우 제너레이터가 없다면 메모리 어딘가에 만들어낸 숫자 1억 개를 보관하고 있어야 한다. 그러나 제너레이터를 이용하면, 단순히 제너레이터만 생성해두고 필요할 때 언제든 숫자를 만들어낼 수 있다. 
`yield` 구문을 사용하면 제너레이터를 리턴할 수 있다. `yield`는 제너레이터가 여기까지 실행 중이던 값을 내보낸다는 의미로 중간값을 리턴한 다음 함수는 종료되지 않고 계속해서 맨 끝에 도달할 때 까지 실행된다.

```
>>> def get_natural_number():
...     n = 0
...     while True:
...             n += 1
...             yield n
...
>>> get_natural_number()
<generator object get_natural_number at 0x10530dba0>
>>> g = get_natural_number()
>>> for _ in range(0, 100):
...     print(next(g))
...
1
2
3
4
...
97
98
99
100
```
제너레이터는 여러 타입의 값을 하나의 함수에서 생성하는 것도 가능하다.
```
>>> def generator():
...     yield 1
...     yield 'string'
...     yield True
...
>>> g = generator()
>>> g
<generator object generator at 0x1054b4740>
>>> next(g)
1
>>> next(g)
'string'
>>> next(g)
True
```

## range
제너레이터의 방식을 활용하는 대표적인 함수로 `range()`가 있다. 주로 `for` 문에서 쓰인다. `for` 문에서 사용할 경우 내부적으로는 제너레이터의 `next()`를 호출하듯 매번 다음 숫자를 생성해내게 된다. 
숫자 백만 개를 생성하는 경우 메모리에 적지않은 공간을 차지할 것이고 생성 시간도 오래 걸릴 것이다. 그러나 제너레이터를 리턴하듯 range 클래스만 리턴하면 그렇지 않다. 생성 조건만 정해두고 나중에 필요할 때 생성해서 꺼내 쓸 수 있다.
```
>>> a = [n for n in range(1000000)]
>>> b = range(1000000)
>>> len(a)
1000000
>>> len(b)
1000000
>>> b
range(0, 1000000)
>>> type(b)
<class 'range'>
>>> import sys
>>> sys.getsizeof(a)
8448728
>>> sys.getsizeof(b)
48
>>> b[999]
999
```
b의 메모리 점유율이 훨씬 더 작다. 인덱스로 접근 시에는 바로 생성하도록 구현되어 있기 때문에 리스트와 거의 동일한 느낌으로 불편 없이 사용할 수 있다.

## enumerate
`enumerate()`는 '열거하다'는 뜻의 함수로, 여러가지 자료형(`list, set, tuple` 등)을 인덱스를 포함한 `enumerate` 객체로 리턴한다.

## pass
파이썬에서 `pass`는 널 연산으로 아무것도 하지 않는 기능이다. 이처럼 아무 역항르 하지 않는 `pass`를 지정하면 불필요한 오류를 방지할 수 있다. `pass`는 mockup 인터페이스부터 구현한 다음에 추후 구현을 진행할 수 있게 한다.

## locals
`locals()`는 로컬 심볼 테이블 딕셔너리를 가져오는 메소드로 업데이트 또한 가능하다. 로컬에 선언된 모든 변수를 조회할 수 있는 강력한 명령이므로 디버깅에 많은 도움이 된다. 특히 로컬 스코프에 제한해 정보를 조회할 수 있기 때문에 클래스의 특정 메소드 내부에서나 함수 내부의 로컬 정보를 조회해 잘못 선언한 부분이 없는지 확인하는 용도로 활용할 수 있다. 
```
>>> import pprint
>>> pprint.pprint(locals())
{'_': 99,
 '__annotations__': {},
 '__builtins__': <module 'builtins' (built-in)>,
 '__doc__': None,
 '__loader__': <class '_frozen_importlib.BuiltinImporter'>,
 '__name__': '__main__',
 '__package__': None,
 '__spec__': None,
 'b': range(0, 1000000),
 'g': <generator object generator at 0x1054b4740>,
 'generator': <function generator at 0x1055be0d0>,
 'get_natural_number': <function get_natural_number at 0x1055be040>,
 'pprint': <module 'pprint' from '/Users/krc/miniconda3/envs/mac_gpu_test/lib/python3.9/pprint.py'>,
 'sys': <module 'sys' (built-in)>}
```
클래스 메소드 내부의 모든 로컬 변수를 출력해 주기 때문에 디버깅에 많은 도움이 된다.
