- 몽고DB 데이터의 기본 단위는 도큐먼트이며, 이는 RDB의 행과 유사하다.
- 같은 맥락에서 컬렉션(collection)은 동적 스키마가 있는 테이블과 같다.
- 몽고DB의 단일 인스턴스는 자체적인 컬렉션을 갖는 여러 개의 독립적인 데이터베이스를 호스팅한다.
- 모든 도큐먼트는 컬렉션 내에서 고유한 특수키인 `"_id"`를 가진다.
- 몽고DB는 `mongosh` 라는 간단하지만 강력한 도구와 함께 배포된다. 몽고DB 인스턴스를 관리하고 몽고DB 쿼리 언어로 데이터를 조작하기 위한 내장 지원을 제공한다. 또한 사용자가 다양한 목적으로 자신의 스크립트를 만들고 로드할 수 있는 완전한 기능의 자바스크립트 인터프리터이다. 

# 도큐먼트

몽고DB 핵심은 정렬된 키와 연결된 값의 집합으로 이뤄진 도큐먼트다. 도큐먼트 표현 방식은 언어마다 다르지만 대부분의 언어는 도큐먼트를 자연스럽게 표현하는 자료구조를 가진다. 

```
{"greeting": "Hello, World!"}
```

이 간단한 도큐먼트는 `"greeting"` 이라는 키에 연결된 `"Hello World!"`라는 값을 가진다. 대부분의 도큐먼트는 이보다 복잡한 다중 키/값 쌍을 가진다.

```
{"greeting": "Hello, World!", "views": 3}
```

값은 데이터형이어야 한다. 키는 문자열이다. 다음 예외를 제외하면 어떤 UTF-8 문자든 쓸 수 있다.
- 키는 `\0(null 문자)` 를 포함하지 않는다. `\0`는 키의 끝을 나타내는 데 사용된다.
- `.`과 `$` 문자는 몇 가지 특별한 속성을 가지며 특정 상황에만 사용해야 한다. 보통 예약어로 취급해야 한다.

몽고 DB는 데이터형과 대소문자를 구분한다. 
```
{"count": 5}
{"count": "5"}
```

```
{"count": 5}
{"Count": 5}
```

키는 중복될 수 없다. 다음 도큐먼트는 올바른 도큐먼트가 아니다.

```
{"greeting": "Hello, World!", "greeting": "Hello, MongoDB!"}
```

# 컬렉션
도큐먼트의 모음이다. 몽고DB의 도큐먼트가 관계형 데이터베이스의 행에 대응된다면 컬렉션은 테이블에 대응된다고 볼 수 있다.

## 동적 스키마
컬렉션은 동적 스키마를 가진다. 하나의 컬렉션 내 도큐먼트들이 모두 다른 구조를 가질 수 있다.도큐먼트들의 키, 키의 개수, 데이터형의 값이 모두 다를 수 있다. 이렇게 다른 구조의 도큐먼트를 같은 컬렉션에 저장할 수 있다면 별도의 컬렉션이 필요한 것에 대해 의문이 들 수 있다. 이에 별도의 컬렉션이 필요한 합당한 이유들이 있다.
- 같은 컬렉션에 다른 종류의 도큐먼트를 저장하면 번거로운 일이 생길 수 있다. 각 쿼리가 특정 스키마를 고수하는 도큐먼트를 반환하는지, 혹은 쿼리한 코드가 다른 구조의 도큐먼트를 다룰 수 있는지 확실히 확인하자.
- 컬렉션별로 목록을 뽑으면 한 컬렉션 내 특정 데이터형별로 쿼리해서 목록을 뽑을 때보다 훨씬 빠르다. 단일 컬렉션 내에서 특정 값을 찾는것 보다 나눠진 컬렉션 중에서 올바른 컬렉션을 쿼리하는 것이 훨씬 빠르다.
- 같은 종류의 데이터를 하나의 컬렉션에 모아두면 데이터 지역성에도 좋다. 
- 인덱스를 만들면 도큐먼트는 특정 구조를 가져야 한다.(고유 인덱스일 경우 특히 더 그렇다.) 이러한 인덱스는 컬렉션별로 정의한다. 같은 유형의 도큐먼트를 하나의 컬렉션에 넣음으로써 컬렉션을 효율적으로 인덱싱할 수 있다.
스키마를 만들고 관련된 유형의 도큐먼트를 그룹화하는 데는 타당한 이유가 있다. 몽고DB의 도큐먼트 유효성 검사 기능과 객체-도큐먼트 매핑 라이브러리를 이용한다.

## 네이밍
컬렉션은 이름으로 식별된다. 어떤 UTF-8 문자열이든 쓸 수 있지만 몇가지 제약 조건이 있다.
- 빈 문자열은 유효한 컬렉션명이 아니다.
- `\0`은 컬렉션명의 끝을 나타내는 문자이므로 컬렉션명에 사용할 수 없다.
- `system.` 으로 시작하는 컬렉션명은 시스템 컬렉션에서 사용하는 예약어이므로 사용할 수 없다.
- 사용자가 만든 컬렉션은 이름에 예약어인 `$` 를 포함할 수 없다. 

### 서브컬렉션
서브컬렉션의 네임스페이스에 `.`문자를 사용해 컬렉션을 체계화한다. 예를 들어 블로그 기능이 있는 애플리케이션은 `blog.posts` 와 `blog.authors` 라는 컬렉션을 가질 수 있다. 이는 단지 체계화를 위함이며 `blog` 컬렉션이나 자식 컬렉션과는 아무런 관계가 없다. 심지어 `blog` 컬렉션이 없어도 된다.
- 큰 파일을 저장하는 프로토콜인 GridFS는 콘텐츠 데이터와 별도로 메타데이터를 저장하는 데 서브컬렉션을 사용한다.
- 대부분의 드라이버는 특정 컬렉션의 서브컬렉션에 접근하는 몇가지 편리한 문법을 제공한다.

# 데이터베이스
몽고DB는 데이터베이스에 컬렉션을 그룹 지어 놓는다. 몽고DB의 단일 인스턴스는 여러 데이터베이스를 호스팅할 수 있으며, 각 데이터베이스를 완전히 독립적을오 취급할 수 있다. 한 애플리케이션의 데이터를 동일한 데이터베이스에 저장하는 것은 좋은 방식이다. 
데이터베이스는 이름으로 식별된다. 어떤 UTF-8 문자열이든 쓸 수 있지만 제약 조건이 있다.
- 빈 문자열은 유효한 데이터베이스 이름이 아니다.
- 데이터베이스 이름은 다음 문자를 포함할 수 없다.`/, \, ., '', *, <, >, :, |, ?, $, (단일공간), \0`
- 데이터베이스 이름은 대소문자를 구별한다.
- 데이터베이스 이름은 최대 64바이트다.

직접 접근할 수는 있지만 특별한 의미론을 갖는 예약된 데이터베이스 이름도 있다.
- admin: 인증과 권한 부여 역할을 한다. 일부 관리 작업을 하려면 이 데이터베이스에 대한 접근이 필요하다.
- local: 단일 서버에 대한 데이터를 저장한다. 복제 셋에서 local은 복제 프로세스에 사용된 데이터를 저장한다. local 데이터베이스 자체는 복제되지 않는다. 
- config: 샤딩된 몽고DB 클러스터는 config 데이터베이스를 사용해 각 샤드의 정보를 저장한다.

컬렉션을 저장하는 데이터베이스의 이름을 컬렉션명 앞에 붙이면 올바른 컬렉션명인 네임스페이스를 얻는다. 예를 들어 cms 데이터베이스의 blog.posts 컬렉션을 사용한다면 컬렉션의 네임스페이스는 cms.blog.posts 가 된다. 네임스페이스의 최대 길이는 120바이트지만 실제로는 100바이트보다 짧아야 한다.

# 몽고DB 시작
`mongod`는 인수없이 실행하면 기본 데이터 디렉터리로 `/data/db` 를 사용한다. 데이터 디렉터리가 존재하지 않거나 쓰기 권한이 없을 때는 서버가 시작되지 않는다. 
시작할 때 서버는 버전과 시스템 정보를 출력한 후 클라이언트의 연결을 기다린다. 몽고DB는 기본적으로 27017번 포트에서 소켓 연결을 기다린다.

# 몽고DB 셸 소개
몽고DB는 명령행에서 몽고DB 인스턴스와 상호작용하는 자바스크립트 셸을 제공한다. 관리 기능이나, 실행 중인 인스턴스를 점검하거나 간단한 기능을 시험하는 데 매우 유용하다.
셸은 시작하면 자동으로 로컬 장비에서 실행 중인 몽고DB 서버에 접속을 시도한다. 셀은 완전한 자바스크립트 해석기이며 임의의 자바스크립트 프로그램을 실행한다. 표준 자바스크립트 라이브러리의 모든 기능을 사용할 수 있다. 자바스크립트 함수를 정의하고 호출할 수도 있다.

## 몽고DB 클라이언트
셸은 시작할 때 몽고DB 서버의 `test` 데이터베이스에 연결하고, 데이터베이스 연결을 전역변수 db에 할당한다. 셸에서는 주로 이 변수를 통해 몽고DB에 접근한다.
현재 `db`에 할당된 데이터베이스를 확인하려면 `db`를 입력한다.
```
> db
test
```
셸은 자바스크립트 구문으로는 유효하지 않지만 SQL 사용자에게 친숙한 추가 기능을 포함한다. 다른 확장 기능은 없지만 편리한 문법을 제공한다.
```
> use video
switched to db video
> db
video
```

## 셸 기본 작업
셸에서 데이터를 조작하거나 보려면 create, read, update, delete 네 가지 기본적인 작업 (CRUD)을 한다.
### 생성
`insertOne` 함수는 컬렉션에 도큐먼트를 추가한다. 예를 들어 영화를 저장한다고 가정했을 때 도큐먼트를 나타내는 자바스크립트 객체인 movie라는 지역 변수를 생성한다.

```
> movie = {"title": "Star Wors: Episode IV - A New Hope",
... "director": "George Lucas",
... "year": 1977}
{
        "title" : "Star Wors: Episode IV - A New Hope",
        "director" : "George Lucas",
        "year" : 1977
}
```
이 객체는 유효한 몽고DB 도큐먼트이며 `insertOne` 함수를 이용해 `movies` 컬렉션에 저장할 수 있다.

```
video> db.movies.insertOne(movie)
{
  acknowledged: true,
  insertedId: ObjectId("64b0cbe8931b3aa44e75f913")
}
```

```
video> db.movies.find()
[
  {
    _id: ObjectId("64b0cbe8931b3aa44e75f913"),
    title: 'Star Wars: Episode IV - A New Hope',
    director: 'George Lucas',
    year: 1977
  }
]
```

### 읽기
`find` 와 `findOne` 은 컬렉션을 쿼리하는 데 사용한다. 컬렉션에 단일 도큐먼트를 읽으려면 `findOne`을 사용한다.
`find` 와 `findOne` 은 쿼리 도큐먼트 형태로 조건 전달도 가능하다. 따라서 쿼리에서 일치하는 도큐먼트로 결과를 제한한다. 셸은 `find`와 일치하는 도큐먼트를 20개까지 자동으로 출력하지만, 그 이상도 가져올 수 있다.

### 갱신
게시물을 갱신하려면 `updateOne` 을 사용한다. `updateOne`의 매개변수는 최소 두 개다. 첫 번째는 수정할 도큐먼트를 찾는 기준이고, 두 번째는 갱신 작업을 설명하는 도큐먼트다.
갱신하려면 갱신 연산자인 `set`을 사용한다.

```
video> db.movies.updateOne({"title": "Star Wars: Episode IV - A New Hope"}, {$set : {"reviews": []}})
{
  acknowledged: true,
  insertedId: null,
  matchedCount: 1,
  modifiedCount: 1,
  upsertedCount: 0
}
video> db.movies.find()
[
  {
    _id: ObjectId("64b0cbe8931b3aa44e75f913"),
    title: 'Star Wars: Episode IV - A New Hope',
    director: 'George Lucas',
    year: 1977,
    reviews: []
  }
]
```

### 삭제
`deleteOne` 과 `deleteMany`는 도큐먼트를 데이터베이스에서 영구적으로 삭제한다. 두 함수 모두 필터 도큐먼트로 삭제 조건을 지정한다. 
```
video> db.movies.deleteOne({"title": "Star Wars: Episode IV - A New Hope"})
{ acknowledged: true, deletedCount: 1 }
video> db.movies.find()

```

# 데이터형
## 기본 데이터형
도큐먼트는 자바스크립트 객체와 개념적으로 닮았다는 점에서 JSON과 닮았다고 생각할 수 있다. JSON의 타입들은 꽤 다양한 표현을 지원하지만, 애플리케이션, 데이터베이스와 연동할 때는 중요한 타입이 몇 가지 더 있다. 예를 들어 JSON은 날짜형이 없어 날짜 다루기가 일반적인 경우보다 더 성가시다. 숫자형이 있기는 하지만 한 가지뿐이다. 함수나 정규 표현식과 같은 흔히 쓰는 데이터형을 표현하는 방법도 없다.
몽고DB는 JSON의 키/값 쌍 설질을 유지하면서 추가적인 데이터형을 지원한다.

### null
null 값과 존재하지 않는 필드를 표현하는 데 사용한다.

### 불리언
참과 거짓 값에 사용한다.

### 숫자
셸은 64비트 부종소수점 수를 기본으로 사용한다. 4바이트 혹은 8바이트의 부호 정수는 각각 `NumberInt` 혹은 `NumberLong` 클래스를 사용한다.

### 문자열
어떤 UTF-8 문자열이든 문자열형으로 표현할 수 있다.

### 날짜
몽고DB는 1970년 1월 1일부터의 시간을 1/1000 초 단위로 나타내는 64비트 정수로 날짜를 저장한다. 표준 시간대(time zone)는 저장하지 않는다.

### 정규표현식
쿼리는 자바스크립트의 정규표현식 문법을 사용할 수 있다.
```
{"x": /foobar/i}
```

### 배열
값의 셋이나 리스트를 배열로 표현할 수 있다.

### 내장 도큐먼트
도큐먼트는 부모 도큐먼트의 값으로 내장된 도큐먼트 전체를 포함할 수 있다. 

### 객체 ID
객체 ID는 도큐먼트용 12바이트 ID다. 

### 이진 데이터
이진 데이터는 임의의 바이트 문자열이며 셸에서는 조작이 불가능하다. 이진 데이터는 데이터베이스에 UTF-8이 아닌 문자열을 저장하는 유일한 방법이다.

### 코드
쿼리와 도큐먼트는 임의의 자바스크립트 코드를 포함할 수 있다.

## 날짜
- 자바스크립트에서 Date 클래스는 몽고DB의 날짜를 표현하는 데 사용한다. 새로운 Date 객체를 생성할 때는 항상 `new Date()`를 호출해야 한다. 함수로 생성자를 호출하면(new가 포함되지 않은 것) 실제 `Date` 객체가 아닌 날짜의 문자열 표현을 반환한다. 
- 문자열과 날짜는 서로 일치하지 않으므로 삭제, 수정, 쿼리 등 거의 모든 작업에서 문제를 일으킬 수 있다.
- 표준 시간대 정보는 또 다른 키 값으로 저장할 수 있다.

## 배열
- 배열은 정렬 연산(리스트, 스택, 큐)과 비정렬 연산(셋)에 호환성 있게 사용 가능한 값이다. 
- 배열은 서로 다른 데이터형을 값으로 포함할 수 있다. 
- 도큐먼트 내 배열의 장점으로 몽고DB가 배열의 구조를 이해한다는 점과 배열의 내용에 작업을 수행하기 위해 내부에 도달하는 방법을 안다는 점이 있다. 따라서 배열에 쿼리하거나 배열의 내용을 이용해 인덱스를 만들 수 있다. 

## 내장 도큐먼트
- 도큐먼트는 키에 대한 값이 될 수 있는데 이를 내장 도큐먼트라고 한다. 
- 배열과 마찬가지로 몽고DB는 내장 도큐먼트의 구조를 이해하고, 인덱스를 구성하고, 쿼리하며, 갱신하기 위해 내장 도큐먼트 내부에 접근한다.
- 더 많은 데이터 반복이 생길 수 있다는 단점이 있다. RDB에서는 테이블끼리 조인을 수행하여 해당 데이터를 가진 모든 행을 한 번에 수정할 수 있지만, 몽고DB의 경우 각 도큐먼트에서 오타를 수정해야한다. 

## `_id` 와 `ObjectId`
몽고DB에 저장된 모든 도큐먼트는 `"_id"` 키를 가진다. 해당 키 값은 어떤 데이터형이어도 상관없지만 `ObjectId` 가 기본이다. 하나의 컬렉션에서 모든 도큐먼트는 고유한 `"_Id"` 값을 가지며, 이 값은 컬렉션 내 모든 도큐먼트가 고유하게 식별되게 한다. 

### `ObjectIds`
`ObjectId` 는 `"_id"` 의 기본 데이터형이다. `ObjectId` 클래스는 가벼우면서도, 여러 장비에 걸쳐 전역적으로 고유하게 생성하기 쉽게 설계됐다. 자동 증가하는 기본 키 처럼 전통적인 것이 아닌 `ObjectId` 를 사용하는 주요 이유는 몽고DB의 분산 특성 때문이다. 여러 서버에 걸쳐 자동으로 증가하는 기본 키를 동기화하는 작업은 어렵고 시간이 걸린다. 몽고Db는 분산 데이터베이스로 셜계됐기 때문에 샤딩된 환경에서 고유식별자를 생성하는 것이 중요했다.
`ObjedtId`는 12바이트 스토리지를 사용하며 24자리 16진수 문자열 표현이 가능하다. 바이트당 2자리를 사용한다. 
`ObjectId` 의 첫 4바이트는 1970년 1월 1일 부터의 시간을 1/1000초 단위로 저장하는 타임스탬프다.
- 타임스탬프는 그 다음 5바이트와 묶일 때 초 단위의 유일성을 제공한다.
- 타임스탬프가 맨 처음에 온다는 것은 ObjectId가 대략 입력 순서대로 정렬된다는 의미다. 확실히 보장되지는 않는다.
- 이 4바이트에는 각 도큐먼트가 생성된 때의 잠재적인 타임스탬프가 존재한다. 대부분의 드라이버는 `ObjectId`로부터 이런 정보를 추출하는 방법을 제공한다.
타임스탬프의 실제 값은 `ObjectId` 와 상관없기 땜문에 서버 시각을 동기화하는 것이 꼭 필요하진 않다.
`ObjectId` 의 다음 5바이트는 랜덤 값이다. 최종 3바이트는 서로 다른 시스템에서 충돌하는 `ObjectId` 들을 생성하지 않도록 랜덤 값으로 시작하는 카운터다. 
`ObjectId` 의 앞 9바이트는 1초 동안 여러 장비와 프로세스에 걸쳐 유일성을 보장한다. 마지막 3바이트는 단순이 증분하는 숫자로, 1초 내 단일 프로세스의 유일성을 보장한다. 고유한 `ObjectId`는 프로세스당 1초에 $256^3$ (1677만 7216)개 까지 생성된다.

### `_id` 자동 생성
도큐먼트를 입력할 때 `"_id"` 키를 명시하지 않으면 입력된 도큐먼트에 키가 자동으로 추가된다. 이는 몽고DB 서버에서 관리할 수 있지만 일반적으로는 클라이언트 쪽 드라이버에서 관리한다. 
