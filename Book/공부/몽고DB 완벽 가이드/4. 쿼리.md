쿼리에서 주로 다루는 영역은 다음과 같다.
- `$` 조건절을 이용해 범위 쿼리, 셋의 포함관계, 부등 관계 쿼리 등을 수행한다.
- 쿼리는 필요할 때마다 도큐먼트 배치(batch)를 반환하는 데이터베이스 커서(database cursor)를 반환한다.
- 커서(cursor)를 이용해 결과를 몇 개 건너뛰거나, 반환하는 결과 수를 제한하거나, 결과를 정렬하는 등 다양한 메타연산(metaoperation)을 수행한다.

# find 소개
- mongDB 에서 `find` 함수는 쿼리에 사용한다. 쿼리는 컬렉션에서 도큐먼트의 서브셋(빈 컬렉션부터 컬렉션 전체까지)을 반환한다. `find`의 첫 매개변수에 따라 어떤 도큐먼트를 가져올지 결정된다. 
- 빈 쿼리 도큐먼트 (`{}`) 는 컬렉션 내 모든 것과 일치한다. 매개변수에 쿼리 도큐먼트가 없으면 `find` 함수는 빈 쿼리 도큐먼트 `{}` 로 인식한다. 따라서 다음 명령은 컬렉션 `c`의 모든 도큐먼트와 일치하므로 컬렉션 `c` 내 모든 도큐먼트를 반환한다.
```
> db.c.find()
```
- 쿼리 도큐먼트에 여러 키/값 쌍을 추가해 검색을 제한할 수 있다. 대부분의 데이터형에서 간단히 작동하며 정수형은 정수형에, 불리언형은 불리언형에, 문자열형은 문자열형에 일치한다. 간단한  데이터형은 찾으려는 값만 지정하면 쉽게 쿼리할 수 있다.
```
> db.users.find({"age" : 29})
> db.users.find({"name" : "hajong"})
```
- 쿼리 도큐먼트에 여러 개의 키/값 쌍을 추가할 수 있으며 `AND` 연산으로 해석된다.
```
> db.users.find({"age" : 29, "name" : "hajong"})
```

## 반환받을 키 지정
- 때때로 반환받은 도큐먼트 내 키/값 정보가 모두 필요하지는 않을 수 있다. 그럴 땐 두 번째 매개변수에 원하는 키를 지정하면 된다. 이는 네트워크상의 데이터 전송량과 클라이언트 측에서 도큐먼트를 디코딩하는데 드는 시간과 메모리를 줄여준다.
```
> db.users.find({}, {"username": 1, "email": 1})
```
- `_id` 키는 지정하지 않아도 항상 반환된다.
- 특정 키/값을 제외한 결과를 얻을 수도 있다. 특정 키가 필요하지 않은 경우 해당 필드의 값을 0으로 지정해주면 된다. 이것으로 `_id` 를 제외할 수도 있다.
```
> db.users.find({}, {"username": 1, "_id": 0})
```

## 제약 사항
- 쿼리에는 몇 가지 제약이 있다. 데이터베이스에서 쿼리 도큐먼트 값은 반드시 상수여야 한다. 이는 도큐먼트 내 다른 키의 값을 참조할 수 없음을 의미한다. 
- 예를 들어 재고 도큐먼트에 재고 수량 키 `"in_stock"` 과 판매 수량 키 `"num_sold"` 가 있으면 키 값을 다음과 같은 쿼리로 비교할 수 없다.
```
> db.stock.find({"in_stock" : "this.num_sold"})
```
- 다른 쿼리 방법이 있지만 (4.4 `$where` 쿼리 참조) 일반 쿼리로 처리할 수 있게 도큐먼트 구조를 약간 재구성하면 더 나은 성능을 얻을수 있다. `"initial_stock"` 과 `"in_stock"` 키를 사용하여 누군가가 상품을 구매할 때마다 `"in_stock"` 값을 감소시키면 품절 상품을 확인하는 쿼리는 다음과 같다.
```
> db.stock.find({"in_stock" : 0})
```

# 쿼리 조건
쿼리는 완전 일치 외에도 범위, OR절, 부정 조건 등 더 복잡한 조건으로 검색할 수 있다.

## 쿼리 조건절
- `"$lt", "$lte", "$gt", "$gte"` 를 조합해 사용하면 특정 범위 내 값을 쿼리할 수 있다. 예를 들어 18세 에서 30세 사이의 사용자를 찾으려면 다음과 같이 쿼리한다.
```
>db.users.find({"age": {"$gte" : 18, "$lte": 30}})
```
- 범위 쿼리는 날짜 쿼리에 유용하다. 날짜는 밀리초 단위로 저장되므로 정확히 일치시키는 조건은 그리 유용하지 않다. 하루, 한 주, 또는 한 달 단위가 필요한 경우가 많으므로 범위 쿼리를 사용한다. 
```
> start = new Date("01/01/2007")
> db.users.find({"registered": {"$lt": start}})
```
- 키 값이 특정 값과 일치하지 않는 도큐먼트를 찾는 데는 `"$ne"` 를 사용한다. 모든 데이터형에 사용할 수 있다. 

## OR 쿼리
- OR 쿼리에는 두 가지 방법이 있다. 
	- `"$in"` 은 하나의 키를 다양한 값과 비교하는 쿼리에 사용한다.
	- `"$or"` 은 더 일반적이며, 여러 키를 주어진 값과 비교하는 쿼리에 사용한다.
- 하나의 키에 일치시킬 값이 여러 개 있다면 `"$in"` 에 조건 배열을 사용한다. 예를 들어 추첨 당첨자를 뽑는 상황을 가정하면 다음과 같다.
```
> db.raffle.find({"ticket_no": {"$in": [123, 45, 1]}})
```
- `"$in"` 은 여러 개의 값을 쓸 수 있을 뿐 아니라 서로 다른 데이터형도 쓸 수 있다. 예를 들어 사용자 ID에 번호 대신 이름을 쓰도록 점진적으로 이전하고 있다면 두 조건 중 하나라도 맞는 도큐먼틀를 찾도록 쿼리한다.
```
> db.users.find({"user_id": {"$in" : [1234, "hajong"]}})
```
- `"$in"` 의 조건 배열에 값이 하나만 주어지면 바로 일치하는 것을 찾는다.
- `"$nin"` 은 `"$in"` 과 반대로 배열 내 조건과 일치하지 않는 도큐먼트를 반환한다. 

- `"$in"` 의 경우 하나의 키에 대해서 OR 쿼리를 하는 것을 볼 수 있다. 여러 개의 키에 대해서 OR 쿼리를 하고 싶은 경우에는 `"$or"` 연산자를 사용하면 된다. `"$or"` 은 가능한 조건들의 배열을 취한다.
```
> db.raffle.find({"$or": [{"ticket_no": 1234}, {"winner": true}]})
```
- `"$or"` 은 다른 조건절도 포함할 수 있다. 티켓 번호가 셋 중 하나이거나 "winner" 가 ture 인 경우를 찾는다면 다음과 같다.
```
> db.raffle.find({"$or": [{"ticket_no": {"$in": [123, 45, 1]}}, {"winner": true}]})
```

- 일반적인 AND 쿼리에서는 최소한의 인수로 최적의 결과를 추려내야 한다. OR 쿼리의 경우에는 첫 번째 인수가 일치하는 도큐먼트가 많을 수록 효율적이다. 

## `$not`
- `$not` 은 메타 조건절이며 어떤 조건에도 적용할 수 있다. 정규 표현식과 함께 사용해 주어진 패턴과 일치하지 않는 도큐먼트를 찾을 때 특히 유용하다.

# 형 특정 쿼리
일부 데이터 형은 쿼리 시 형에 특정하게 작동한다.

## null
- null은 존재하지 않음과도 일치한다. 따라서 키가 null 인 값을 쿼리하면 해당 키를 갖지 않는 도큐먼트도 반환한다.

```
go-web-dev> db.c.find()
[
  { _id: ObjectId("64c35e25c731366455e5c5c2"), y: null },
  { _id: ObjectId("64c35e2ac731366455e5c5c3"), y: 1 },
  { _id: ObjectId("64c35e2dc731366455e5c5c4"), y: 2 }
]
go-web-dev> db.c.find({"y":null})
[ { _id: ObjectId("64c35e25c731366455e5c5c2"), y: null } ]
go-web-dev> db.c.find({"z": null})
[
  { _id: ObjectId("64c35e25c731366455e5c5c2"), y: null },
  { _id: ObjectId("64c35e2ac731366455e5c5c3"), y: 1 },
  { _id: ObjectId("64c35e2dc731366455e5c5c4"), y: 2 }
]
```

- 값이 null인 키만 찾고 싶으면 키가 null인 값을 쿼리하고, `"$exists"` 조건절을 사용해 null 존재 여부를 확인하면 된다.
```
go-web-dev> db.c.find({"z": {"$eq": null, "$exists": true}})

```

## 정규 표현식
- `"$regex"` 는 쿼리에서 패턴 일지 문자열을 위한 정규식 기능을 제공한다. 정규 표현식은 문자열 일치를 유연하게 하는 데 유용하다. 
```
> db.users.find({"name" : {"$regex" : /joe/i }})
```
- 정규 표현식 플래그는 사용할 수 있지만 꼭 필요하지는 않다.
- mongoDB는 정규 표현식 일치에 펄 호환 정규 표현식(PCRE) 라이브러리를 사용하며 PCRE에서 쓸 수 있는 모든 문법은 mongoDB에서 쓸 수 있다. 쿼리하기 전에 먼저 자바스크립트 셸로 해당 정규 표현식이 의도한 대로 동작하는지 확인해보는 것이 좋다.

## 배열에 쿼리하기
- 배열 요소 쿼리는 스칼라 쿼리와 같은 방식으로 동작하도록 설계 됐다. 배열이 다음과 같은 과일 목록이라고 가정하면, 다음과 같은 쿼리를 이용해서 일치하는 도큐먼트를 찾을 수 있다.
```
go-web-dev> db.food.insertOne({"fruit" : ["banana", "apple", "lemon"]})
{
  acknowledged: true,
  insertedId: ObjectId("64c360ddc731366455e5c5c5")
}
go-web-dev> db.food.find({"fruit": "banana"})
[
  {
    _id: ObjectId("64c360ddc731366455e5c5c5"),
    fruit: [ 'banana', 'apple', 'lemon' ]
  }
]
```

### `"$all"` 연산자
- 2개 이상의 배열 요소가 일치하는 배열을 찾으려면 `"$all"` 을 사용한다. 이는 배열 내 여러 요소와 일치하는지 확인하게 해준다.
- 조건 배열에서 요소의 순서는 중요하지 않다. 
```
go-web-dev> db.food.find({"fruit": "banana"})
[
  {
    _id: ObjectId("64c360ddc731366455e5c5c5"),
    fruit: [ 'banana', 'apple', 'lemon' ]
  },
  {
    _id: ObjectId("64c36184c731366455e5c5c7"),
    fruit: [ 'banana', 'apple', 'peach' ]
  },
  {
    _id: ObjectId("64c36193c731366455e5c5c8"),
    fruit: [ 'banana', 'peach', 'lemon' ]
  }
]
go-web-dev> db.food.find({"fruit" : {"$all" : ["apple", "banana"]}})
[
  {
    _id: ObjectId("64c360ddc731366455e5c5c5"),
    fruit: [ 'banana', 'apple', 'lemon' ]
  },
  {
    _id: ObjectId("64c36184c731366455e5c5c7"),
    fruit: [ 'banana', 'apple', 'peach' ]
  }
]
```

- 배열 내 특정 요소를 쿼리하려면 `key.index` 구문을 이용해 순서를 지정한다.
```
go-web-dev> db.food.find({ "fruit.2": "peach" })
[
  {
    _id: ObjectId("64c36184c731366455e5c5c7"),
    fruit: [ 'banana', 'apple', 'peach' ]
  }
]
```

### `"$size"` 연산자
- 특정 크기의 배열을 쿼리하는 유용한 조건절이다. 
- 크기의 범퀴로 쿼리할 수 있다. `$size`는 다른 `$` 조건절과 결합해 사용할 수 없지만, 도큐먼트에 `size` 키를 추가하면 이런 쿼리를 처리할 수 있다. 그리고 배열에 요소를 추가할 때 마다 `"size"` 값을 증가시키면 된다. 
```
> db.food.update(criteria, {"$push": {"fruit": "strawberry"}, "$inc": {"size": 1}})
```
- 하지만 이 기능은 `"$addToSet"` 과 함께 사용할 수 없다. 

### `"$slice"` 연산자
- `find` 의 두 번째 매개변수에는 반환받을 특정 키를 지정한다. `"$slice"` 연산자를 사용해서 배열 요소의 부분집합을 반환받을 수 있다.
- 예를 들어 블로그 게시물에서 먼저 달린 댓글 열 개를 반환받는다면 쿼리는 다음과 같다.
```
> db.blog.posts.findOne(criteria, {"comments" : {"$slice" : 10}})
```
- 반대로 나중에 달린 댓글 열 개를 반환 받으려면 -10 을 지정하면 된다.
```
> db.blog.posts.findOne(criteria, {"comments" : {"$slice" : -10}})
```
- 오프셋과 요소 개수를 동시에 지정할 수 도 있다. 다음의 경우 23개를 건너뛰고 24번째 요소부터 33번째 요소까지 반환한다.
```
> db.blog.posts.findOne(criteria, {"comments" : {"$slice" : [23, 10]}})
```
- 특별히 명시하지 않는 한 `"$slice"` 연산자는 도큐먼트 내 모든 키를 반환한다. 명시하지 않은 키는 반환하지 않는 다른 키 명시자들과는 다르다.
```
go-web-dev> db.food.findOne({"fruit": {"$all" : ["peach", "lemon"]}}, {"fruit" : {"$slice" : [2,1]}})
{
  _id: ObjectId("64c36193c731366455e5c5c8"),
  fruit: [ 'lemon' ],
  size: 3
}
```

### 일치하는 배열 요소의 반환
- 찾고자 하는 요소의 인덱스를 알지 못하는 경우 `"$slice"` 를 사용하기는 어렵다. 대신 이때 `"$"` 연산자를 사용하면 일치하는 요소를 반환받을 수 있다. 

```
go-web-dev> db.food.findOne({"fruit": "banana"})
{
  _id: ObjectId("64c360ddc731366455e5c5c5"),
  fruit: [ 'banana', 'apple', 'lemon' ]
}
go-web-dev> db.food.findOne({"fruit": "banana"}, {"fruit.$": 1})
{ _id: ObjectId("64c360ddc731366455e5c5c5"), fruit: [ 'banana' ] }
```

### 배열 및 범위 쿼리의 상호작용
- 도큐먼트 내 스칼라(비배열 요소)는 쿼리 기준의 각 절과 일치해야 한다. 예를 들어 `{"x" : {"$gt" : 10, "$lt" : 20}}` 과 같이 쿼리했다면 `"x"` 는 10보다 크고 20보다 작아야 한다.
- 도큐먼트의 `"x"` 필드가 배열이라면 각 절의 조건을 충족하는 도큐먼트가 일치된다. 그리고 각 쿼리 절은 서로 다른 배열 요소와 일치할 수 있다. 
```
go-web-dev> db.c.find()
[
  { _id: ObjectId("64c36cccc731366455e5c5c9"), x: 5 },
  { _id: ObjectId("64c36ccfc731366455e5c5ca"), x: 15 },
  { _id: ObjectId("64c36cd3c731366455e5c5cb"), x: 25 },
  { _id: ObjectId("64c36cdbc731366455e5c5cc"), x: [ 5, 25 ] }
]
go-web-dev> db.c.find({"x" : {"$gt": 10, "$lt" : 20}})
[
  { _id: ObjectId("64c36ccfc731366455e5c5ca"), x: 15 },
  { _id: ObjectId("64c36cdbc731366455e5c5cc"), x: [ 5, 25 ] }
]
```
- 5와 25 둘다 10과 20 사이는 아니지만, 25는 첫 번째 절과 일치하고 5는 두 번째 절과 일치하기 때문에 반환되었다. 

- 이 방법을 사용하면 배열에 대한 범위 쿼리가 본질적으로 쓸모없어진다. 원하는 결과를 얻으려면 다음의 방법들을 사용해야 한다.
1. `"$elemMatch"` 연산자를 사용하면 두 절을 하나의 배열 요소와 비교한다. 하지만 `"$elemMatch"` 연산자는 비배열 요소를 일치시키지 않는다.
```
go-web-dev> db.c.find({"x" : {"$elemMatch" : {"$gt" : 10, "$lt" : 20 }}})

```
2. 쿼리하는 필드에 인덱스가 있다면 `min` 함수와 `max` 함수를 사용해 `"$gt"` 와 `"$lt"` 값 사이로 인덱스 범위를 제한해 쿼리할 수 있다. 
```
> db.c.find({"x" : {"$gt": 10, "$lt" : 20}}).min({"x":10}).max({"x": 20})
```
- 쿼리하는 필드에 인덱스가 있을 때는 `min` 함수와 `max` 함수만을 사용할 수 있지만, 그렇더라도 `min`과 `max`에 인덱스의 모든 필드를 전달해야 한다. 
- 일반적으로 배열을 포함하는 도큐먼트에 범위 쿼리를 할 때 `min` 함수와 `max` 함수를 사용하면 좋다. 배열에 대한 `"$gt"/"$lt` 쿼리의 인덱스 한계(index bound)는 비효율적이다. 어떤 값이든 허용하므로 범위 내 값뿐 아니라 모든 인덱스 항목을 검색한다. 

## 내장 도큐먼트에 쿼리하기
- 내장 도큐먼트 쿼리는 도큐먼트 전체를 대상으로 하는 방식과 도큐먼트 내 키/값 쌍 각각을 대상으로 하는 방식으로 나뉜다. 
- 서브도큐먼트 전체에 쿼리하려면 서브도큐먼트와 정확히 일치해야한다. 필드 값들이 일치하지 않거나 필드 값의 위치가 달라도 반환되지 않는다.
- 내장 도큐먼트에 쿼리할 때는 가능하면 특정 키로 쿼리하는 방법이 좋다. 도큐먼트 전체를 대상으로 정확히 일치시키는 방법이 아니므로 스키마가 변경되더라도 모든 쿼리가 정상적으로 작동한다. 
```
{
	"name" : {
		"first": "joe",
		"last": "schmoe"
	},
	"age" : 45
}
> db.people.find({"name": {"first": "joe", "last": "schmoe"}})
> db.people.find({"name.first": "joe", "name.last": "schmoe"})
```
- 점 표기법은 쿼리 도큐먼트와 다른 도큐먼트 타입의 큰 차이점이다. 쿼리 도큐먼트는 점을 포함할 수 있고, 이는 내장 도큐먼트 내 항목에 접근할 수 있다는 의미이다. 또한 점 표기법 때문에 입력하는 도큐먼트에 `.` 문자를 사용할 수 없다. (URL을 키로 저장할 때 주로 문제가 된다. 도큐먼트를 입력하기 전이나 꺼낸 후에 `.` 문자를 URL에 쓰이지 않는 문자로 바꾸는 방법으로 해결할 수 있다.)

# `$where` 쿼리
- 키/값 쌍만으로 꽤 다양한 쿼리를 할 수 있지만 정확하게 표현할 수 없는 쿼리도 있다. `"$where"` 절을 사용해 임의의 자바스크립트를 쿼리의 일부분으로 실행하면 (거의) 모든 쿼리를 표현할 수 있다. 따라서 보안상의 이유로 `"$where"` 절 사용을 제한해야 한다. 최종 사용자가 임의의 `"$where"` 절을 실행하지 못하도록 한다. 
- `"$where"` 절은 도큐먼트 내 두 키의 값을 비교하는 쿼리에 가장 자주 쓰인다. 예를 들어 다음과 같은 도큐먼트가 있다고 가정하자.
```
go-web-dev> db.foo.insertOne({"apple": 1, "banana": 6, "peach": 3})
go-web-dev> db.foo.insertOne({"apple": 8, "spinach": 4, "watermelon": 4})
```
- 두 필드의 값이 동일한 도큐먼트를 반환받고자 할 때, mongoDB에서는 이런 경우에 `$` 조건절을 사용할 수 없으므로 `"$where"` 절 내 자바스크립트로 처리한다.
```
go-web-dev> db.foo.find({"$where" : function() {
... for (var current in this) {
...     for (var other in this) {
...         if (current != other && this[current] == this[other]) {
...             return true;
...         }
...     }
... }
... return false;
... }});
[
  {
    _id: ObjectId("64c37d59c731366455e5c5ce"),
    apple: 8,
    spinach: 4,
    watermelon: 4
  }
]
```
- `"$where"` 절 실행시 각 도큐먼트는 BSON 에서 자바스크립트 객체로 변환되기 때문에 오래걸린다. 또한 `"$where"` 절에는 인덱스를 쓸 수 없다. 따라서 `"$where"` 쿼리는 일반 쿼리보다 훨씬 느리니 반드시 필요한 경우가 아니면 사용하지 않는게 좋다.
- `"$where"` 절을 다른 쿼리 필터와 함께 사용하면 성능 저하를 줄일 수 있다. 가능한 한 `"$where"` 절이 아닌 조건은 인덱스로 거르고 `"$where"` 절은 결과를 세부적으로 조정할 때 사용한다. 
- mongoDB 언어로 집계 표현식을 사용하는 `"$expr"` 를 사용하는 것이 더 좋다.

# 커서
- 데이터베이스는 커서를 사용해 `find` 의 결과를 반환한다. 일반적으로 클라이언트 측의 커서 구현체는 쿼리의 최종 결과를 강력히 제어하게 해준다. 
- 결과 개수를 제한하거나, 결과 중 몇 개를 건너뛰거나, 여러 키를 조합한 결과를 어떤 방향으로든 정렬하는 등 다양하게 조작할 수 있다. 
- 셸에서 커서를 생성하려면 쿼리한 결과를 지역변수에 할당한다. 
```
go-web-dev> for(i=0; i<100; i++) {
... db.c.insertOne({x: i});
... }
{
  acknowledged: true,
  insertedId: ObjectId("64c380b2c731366455e5c632")
}
go-web-dev> var cursor = db.c.find();
```
- 결과를 전역 변수에 저장하거나 아예 변수가 없으면, mongoDB 셸은 자동으로 결과를 훑으며 처음 몇 개의 도큐먼트를 표시한다. 이는 컬렉션 내에 무엇이 있는지 보는데 사용하며, 셸에서 실제 프로그래밍을 하는 데는 적합하지 않다.
- 차례대로 결과를 얻을 때 커서의 `next` 메서드를 사용하고, 다음 결과가 있는지는 `hasNext`를 사용하여 확인한다.
```
> while (cursor.hasNext()) {
... 	obj = cursor.Next();
... 	// 사용자 정의 작업 수행
...}
```
- `cursor` 클래스는 자바스크립트의 iterator 인터페이스를 구현했으므로 `forEach` 반복문에 사용할 수 있다.
```
> var cursor = db.people.find()
> cursor.forEach(function(x) {
...     print(x.name);
...});
```
- find 를 호출할 때 셸이 데이터베이스를 즉시 쿼리하지는 않으며 결과를 요청하는 쿼리를 보낼 때까지 기다린다. 따라서 쿼리하기 전에 옵션을 추가할 수 있다. 또한 `cursor` 객체상의 거의 모든 메서드가 커서 자체를 반환하므로 옵션을 어떤 순서로든 이어쓸 수 있다.
```
> var cursor = db.foo.find().sort({"x": 1}).limit(1).skip(10);
> var cursor = db.foo.find().limit(1).sort({"x": 1}).skip(10);
> var cursor = db.foo.find().skip(10).limit(1).sort({"x": 1});
```
- 이 시점에서 쿼리는 아직 수행되지 않는다. 다음 메서드를 수행한다고 가정하자.
```
> cursor.hasNext()
```
- 이때 비로소 쿼리가 서버로 전송된다. 셸은 `next` 나 `hasNext` 메서드 호출 시 서버 왕복 횟수를 줄이기 위해, 한 번에 처음 100개 또는 4메가바이트 크기의 결과 (둘 중 작은것)를 가져온다. 클라이언트가 첫 번째 결과 셋을 살펴본 후에, 셸이 데이터베이스에 다시 접근해 더 많은 결과를 요청한다. `getMore` 요청은 기본적으로 커서에 대한 식별자를 가지며, 데이터베이스가 다음 배치를 반환하도록 요구한다. 프로세스는 모든 결과를 반환해 커서가 소진될 때 까지 계속된다.

## 제한, 건너뛰기, 정렬
- 결과 개수를 제한하려면 `limit` 함수를 연결한다. 상한만 설정하고 하한은 설정하지 않는다. 
```
> db.c.find().limit(3)
```
- `skip` 은 `limit` 와 유사하게 작동한다. 조건에 맞는 결과 중 처음 n 개를 건너뛴 나머지를 반환한다. 컬렉션에서 조건에 맞는 결과가 n개 보다 적으면 아무 결과도 반환하지 않는다.
```
>db.c.find().skip(3)
```
- `sort` 는 객체를 매개변수로 받는다. 매개변수는 키/값 쌍의 셋, 키는 키의 이름, 값은 정렬방향이다. 1은 오름차순 -1은 내림차순이다. 키가 여러 개이면 주어진 정렬 방향에 따라 정렬된다.
```
> db.c.find().sort({username: 1, age: -1})
```

### 비교 순서
- mongoDB에는 데이터형을 비교하는 위계 구조가 있다. 데이터형이 섞여 있는 키는 미리 정의된 순서에 따라 정렬한다. 
1. 최솟값
2. null
3. 숫자(int, long, double, decimal)
4. 문자열
5. 객체/도큐먼트
6. 배열
7. 이진 데이터
8. 객체 ID
9. 불리언
10. 날짜
11. 타임스탬프
12. 정규 표현식
13. 최댓값

## 많은 수의 건너뛰기 피하기
- `skip` 은 생략된 결과물을 모두 찾아 폐기하므로 결과가 많으면 느려진다. 대부분의 데이터베이스는 `skip` 을 위해 안덱스 안에 메타데이터를 저장하지만 mongoDB는 아직 해당 기능을 지원하지 않는다. 따라서 많은 수의 건너뛰기는 피해야한다. 

### skip을 사용하지 않고 페이지 나누기
- `limit`를 사용해 첫 번째 페이지를 반환하고 다음 페이지들은 첫 페이지부터 오프셋을 주어 반환하면 가장 쉽게 페이지를 나눌 수 있다.
- `skip` 을 사용하지 않는 방법으로는 예를 들어 `"date"` 를 내림차순으로 정렬해 도큐먼트를 표시한다고 가정하자. 마지막 도큐먼트의 `"date"` 값을 사용해 다음 페이지를 가져온다.
```
var page1 = db.foo.find().sort({"date": -1}).limit(100)
var latest = null;
while (page1.hasNext()) {
	latest = page1.next();
	display(latest);
}

var page2 = db.foo.find({"date" : {"$lt": latest.date}});
page2.sort({"date": -1}).limit(100);
```

### 랜덤으로 도큐먼트 찾기
- 단순하고 느린 방법으로는 도큐먼트의 개수를 세고 `find`를 실행한 후 0과 컬렉션 크기 사이의 수를 랜덤으로 뽑아 그 개수만큼 건너뛰는 방법이 있다. 이는 전체 도큐먼트를 세어야하며, 많은 요소를 건너뛰어야 하므로 시간이 오래걸린다.
- 도큐먼트를 입력할 때 랜덤 키를 별도로 추가하는 것이 효율적인 방법이 될 수 있다. 셸을 사용한다면 `Math.random()` 함수를 사용한다. 함수는 0과 1 사이의 랜덤 수를 생선한다.
```
> db.people.insertOne({"name": "joe", "random" : Math.random()})
```
- 컬렉션에서 랜덤으로 도큐먼트를 찾고 싶으면 `skip` 을 사용하는 대신 랜덤 수를 계산해 쿼리 조건으로 사용한다. 
```
> var random = Math.random()
> result = db.people.findOne({"random" : {"$gt" : random}})
> if (result == null) {
... result = db.people.findOne({"random" : {"$lte : random"}})}
```
- 랜덤 키가 인덱스를 갖는지 명확히 해야한다.

## 종료되지 않는 커서 
- 커서에는 두 가지 측면이 있다. 클라이언트가 보는 커서와 클라이언트 커서가 나타내는 데이터베이스 커서다.
- 서버 측에서 보면 커서는 메모리와 리소스를 점유한다. 따라서 리소스 점유율을 낮추기 위해 커서를 최대한 빨리 해제시켜야 한다.
- 서버 커서를 종료하는(그리고 이후의 작업도 정리하는) 몇 가지 조건이 있다.
	1. 커서는 조건에 일치하는 결과를 모두 살펴본 후에는 스스로 정리한다.
	2. 커서가 클라이언트 측에서 유효 영역을 벗어나면 드라이버는 데이터베이스에 메시지를 보내 커서를 종료해도 된다고 알린다.
	3. 사용자가 아직 결과를 다 살펴보지 않았고, 커서가 여전히 유효 영역 내에 있더라도 10분 동안 활동이 없으면 데이터베이스 커서는 자동으로 죽는다.
- 드라이버는 데이터베이스가 커서를 타임아웃 시키지 못하게 하는 `immortal` 함수를 제공한다. 커서의 타임아웃을 비활성화 했다면 반드시 결과를 모두 살펴보거나 커서를 명확히 종료해야한다.