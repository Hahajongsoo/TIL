발전해온 역사를 더듬어 '왜 HTTP가 지금의 모습이 됐는가?'를 아는 편이 HTTP의 모든 것을 이해하기 쉬워진다.
HTTP를 데이터의 사자로서 보면 통신 내용을 몇 가지 요소로 나눌 수 있다
- 메서드와 경로
- 헤더
- 바디
- 스테이터스 코드
# 1. HTTP의 역사
HTTP는 웹 브라우저와 웹 서버가 통신하는 절차와 형식을 규정한 것이다. 웹 브라우저로 웹페이지를 표시할 때 서버로부터 정보를 받아오는 약속이지만, 다양한 서비스의 인터페이스(API)로도 사용되면서 현재 인터넷의 기초가 됐다.
- 1990년: HTTP/0.9
- 1996년: HTTP/1
- 1997년: HTTP/1.1
- 2005년: HTTP/2
최초 버전은 HTML 도큐먼트를 요청해서 가져오기만 하는 단순한 프로토콜이었다. 그 후로는 폼을 전송, 정보 갱신, 채팅 기능 구현에 사용 등 새로운 기능이 필요할 때마다 확장됐다.
최초 사양이 HTTP/0.9라 불리게 된 것은 HTTP/1.0 사양이 화제가 되고 나서부터이다.
다양한 프로토콜이 RFC로 정의됐다. RFC는 IETF라는 조직이 중심이 되어 유지 관리하는 통신의 상호접속성 유지를 위한 공통화된 사양서 모음이다.
## 1.1 테스트 에코 서버 실행
```go
package main
  
import (
    "fmt"
    "log"
    "net/http"
    "net/http/httputil"
)
  
func handler(w http.ResponseWriter, r *http.Request) {
    dump, err := httputil.DumpRequest(r, true)
    if err != nil {
        http.Error(w, fmt.Sprint(err), http.StatusInternalServerError)
        return
    
    fmt.Println(string(dump))
    fmt.Fprintf(w, "<html><body>hello</body></html>\n")
}  

func main() {
    var httpServer http.Server
    http.HandleFunc("/", handler)
    log.Println("start http listening :8080")
    httpServer.Addr = ":8080"
    log.Println(httpServer.ListenAndServe())

}
```
# HTTP/0.9 의 기능
HTTP/0.9는 텍스트 정보가 적힌 페이지 경로를 서버에 지정해서 해당 페이지를 가져오기만 하는 프로토콜이다. 0.9 버전은 현행 프로토콜과 하위 호환성이 없으므로 송신 측, 수신 측 모두 0.9 버전의 프로토콜을 다룰 수 없다.
```bash
# curl 실행 예
$ curl --http1.0 http://localhost:8080/greeting
<html><body>hello</body></html>

# 서버 측 로그
GET /greeting HTTP/1.0
Host: localhost:8080
Accept: */*
User-Agent: curl/7.88.1
```
 0.9의 기본 기능은 이것뿐이다. 웹사이트의 페이지를 서버에 요청하고, 그 응답으로 웹사이트의 내용을 받아온다. HTTP라는 이름 그대로이다. 수신한 후에는 서버와 연결이 끊어진다.
 요청에는 호스트 이름 또는 IP 주소와 포트 번호를 지정한다. (포트 번호 생략 시 80 포트)
 curl 커맨드는 호스트명과 경로가 함께 있는 URI를 사용하지만, 서버가 받아들이는 것은 /greeting 이라는 경로 부분뿐이다.
 현재 인터넷의 기초가 된 '폼'과 '검색 기능'이 있다. HTML 문장 내에서 \<isindex> 태그를 사용하면 텍스트 입력란이 생겨 검색할 수 있었다. 검색을 하면 주소 끝에 ? 기호와 단어를 붙여 검색 요청을 보낸다. 검색 방법은 서버가 결정하고 요청하는 쪽은 검색할 단어를 입력받아 전송하는 기능만 있었다. \<isindex> 태그는 현재 HTML에 없지만, URL에 검색 키워드를 부여해 요청하는 방식은 지금도 바뀌지 않았다.
 이와 거의 같은 통신은 curl로 하려면 `--get or -G` `--data-urlencode or --data or -d`(get이 있는 경우 URL 끝에 쿼리를 붙인다.)
 HTTP/0.9에서 실현된 것은 바디의 수신과 경로 뿐이다.
# 3. 1.0으로의 여정
0.9에서는 할 수 없는 일이 많았다.
- 하나의 문서를 전송하는 기능밖에 없었다.
- 통신되는 모든 내용을 HTML 문서로 가정했으므로, 다운로드할 콘텐츠의 형식을 서버가 전달할 수단이 없었다.
- 클라이언트 쪽에서 검색 이외의 요청을 보낼 수 없었다.
- 새로운 문장을 전송하거나 갱신 또는 삭제할 수 없었다.
요청이 올바른지 혹은 서버가 올바르게 응답했는지 아는 방법도 없었다.
###### 요청
\> 로 시작하는 행이 클라이언트에서 서버로 전송할 내용이다. 요청의 변경된 점은 다음과 같다.
- 요청 시 메서드가 추가됐다.(GET)
- 요청 시 HTTP 버전이 추가됐다.(HTTP/1.0)
- 헤더가 추가 됐다.(Host, User-Agent, Accept)
요청에 관해서 큰 변경사항 두 가지는 메서드와 요청 헤더이다.
```bash
$ curl -v --http1.0 http://localhost:8080/greeting
*   Trying 127.0.0.1:8080...
* Connected to localhost (127.0.0.1) port 8080 (#0)
> GET /greeting HTTP/1.0
> Host: localhost:8080
> User-Agent: curl/7.88.1
> Accept: */*
>
```
###### 응답
\< 로 시작되는 행이 서버에서 응답으로 돌아온 내용이다.
- 응답 선두에 HTTP 버전과 3행의 스테이터스 코드가 포함됐다.
- 요청과 같은 형식의 헤더가 포함되게 됐다.
```
* HTTP 1.0, assume close after body
< HTTP/1.0 200 OK
< Date: Thu, 24 Apr 2025 16:52:17 GMT
< Content-Length: 32
< Content-Type: text/html; charset=utf-8
< 
<html><body>hello</body></html>
* Closing connection 0
```
# 4. HTTP의 조상 (1) 전자메일
HTTP의 헤더는 요청과 응답 양쪽에서 사용된다. 이 아이디어는 인터넷이 보급되기 전부터 사용자 간 정보 교환으로 사용되던 메일 시스템에서 왔다. 헤더의 원형은 1977년에 제정된 RFC 733에서 명문화됐다.
메일의 원시 정보를 살펴보면 (지메일의 경우 원본보기로 확인할 수 있다.) 헤더는 **'파일명:값'** 형식으로 본문 앞에 부가된다. 헤더 이름은 대문자, 소문자를 구별하지 않는다. 헤더에는 본문 이외의 모든 정보가 포함돼 있다.
HTTP에서 헤더는 서버와 클라이언트 사이에 필요한 추가 정보, 지시나 명령, 당부 등을 쓰는 장소이다. 클라이언트가 서버에 보내는 헤더는 다음과 같은 것들이 있다.
- User-Agent: 클라이언트가 자신의 애플리케이션 이름을 넣는 곳. 서버는 이곳의 이름을 보고 응답을 전환하기도 한다. 핸드폰의 종류, 브라우저의 종류나 버전을 구분할 수 있다. 
- Referer: 서버에서 참고하는 추가 정보. 클라이언트가 요청을 보낼 때 보고 있던 페이지의 URL을 보낸다. 
- Authorization: 특별한 클라이언트에만 통신을 허가할 때 인증 정보를 서버에게 전달한다.
서버에서 클라이언트로 보낼 때 부여하는 헤더는 다음과 같은 것들이 있다.
- Content-Type: 파일 종류를 지정. 여기에는 MIME 타입이라는 식별자를 기술한다. MIME 타입은 전자메일을 위해 만들어진 식별자다.
- Content-Length: 바다 크기. 압축이 이루어지는 경우는 압축 후의 크기가 들어간다.
- Content-Encoding: 압축이 이루어진 경우 압축 형식을 설명한다.
- Date: 문서 날짜
X-로 시작되는 헤더는 각 애플리케이션이 자유롭게 사용해도 좋다고 되어있다.HTTP 규격으로 정해진 헤더는 극히 일부이고, 다양한 헤더가 HTTP 밖에서도 추가되고 있다.
## 4.1 헤더의 전송
curl에서 헤더를 보내기 위해선 `--header="헤더행" or -H ` 옵션을 사용한다.

```bash
$ curl --http1.0 -H "X-Test:Hello" http://localhost:8080

GET / HTTP/1.0
Host: localhost:8080
Accept: */*
User-Agent: curl/7.88.1
X-Test: Hello
```

RFC에서는 같은 헤더를 여러 번 보내는 것도 허용한다. 
## 4.2 헤더 수신
클라이언트가 전송하는 헤더와 서버에서 반환하는 헤더의 형식은 완전히 같다. 단 사용되는 필드 이름은 다르다. 헤더 중에는 요청에만 사용되는 것, 응답에만 사용되는 것, 양쪽 다 사용되는 것이 있다.
## 4.3 MIME 타입
파일의 종류를 구별하는 문자열로 전자메일을 위해 만들어졌다. 
브라우저는 OS와 별도로 파일 종류별로 어떤 동작을 할지 관리한다. 이때 파일 종류를 나타내는 식별자가 MIME 타입이다. 
MIME 타입 체계는 웹이 등장하기 훨씬 전부터 전자메일 규격으로 사용됐다. Content-Type 필드가 등장 한것은 1988년 RFC 1049이다. 1992년 RFC 1341에서는 지금과 같은 '대항목/상세'와 같은 표기 방식이 정해졌다. 아직 HTML은 없었지만 text/plain 포맷이나 image/jpeg 등의 포맷 식별자는 여기서 정의됐다. 
현재 웹 서버에서 HTML을 보낼 경우는 서버의 응답 헤더에 다음과 같은 MIME 타입을 설정한다.
```
Content-Type: text/html; charset=utf-8
```
사진과 동영상의 경우는 브라우저나 환경에 따라 이용할 수 있는 포맷이 일부 다르다. 클라이언트와 서버는 다룰 수 있는 포맷에 관해 니고시에이션하고, 실제로 반환할 파일 포맷을 변경한다.
## 4.4 Content-Type과 보안
브라우저에서는 파일 종류를 특정할 때 `Content-Type` 헤더에서 지정된 MIME 타입을 사용한다.
브라우저 옵션에 따라 MIME 타입이 아닌 내용을 보고 파일 형식을 추측하려고 한다. 이런 동작을 콘텐트 ㅅ스니핑이라 한다. 원래 텍스트로만 표시돼야 하는 `text/plain` 파일인데도 HTML과 자바스크립트가 적혀 있으면 브라우저가 파일을 실행해버리는 경우도 있기에 보안상 문제가 될 수 있다. 이를 막기 위해 다음의 헤더를 사용한다
```
X-content-Type-Options: nosniff
```
## 4.5 전자메일과의 차이
HTTP의 와 전자메일 포맷을 비교하면 다음과 같다.
- '헤더+본문' 구조는 같다.
- HTTP 요청에서는 선두에 '메서드+패스' 행이 추가된다.
- HTTP 응답에서는 선두에 스테이터스 코드가 추가된다.
# 5 HTTP의 조상 (2) 뉴스그룹
옛날에 있던 뉴스그룹은 대규모 전자 게시판이다. 주제별로 그룹이 만들어져, 논의가 이루어지거나 소프트웨어 공개에 사용되곤 했다.
뉴스그룹은 분산 아키텍처로 되어있다. 사용자는 서버에 구독하는 최신 기사를 요청하고 기사가 있으면 가져온다.  복수의 서버가 마스터/슬레이브 구조로 연결돼 있어, 슬레이브의 서버도 클라이언트처럼 마스터 서버에 접속하고, 정보를 가져와 로컬에 저장한다. 스토리지 용량에 제한이 있어 오래된 것부터 지워간다. 클아이언트 서버 간 통신과 마스터 서버와 슬레이브 서버 간 통신에 사용된 것이 NNTP라는 프로토콜이다. 메시지 포맷은 그보다 이전에 제정됐다.
HTTP는 뉴스그룹으로부터 메서드와 스테이터스 코드라는 두 가지 기능을 도입했다.
## 5.1 메서드
지정된 주소에 있는 리소스에 대한 조작을 서버에 지시한다. 
HTTP의 경우는 파일 시스템 같은 설계 철학으로 만들어졌다. 아래 세 가지 메서드가 흔히 쓰이는 메서드이다.
- GET: 서버에 헤더와 콘텐츠 요청
- HEAD: 서버에 헤더만 요청
- POST: 새로운 문서 투고
아래 두 메서드는 1.0 이후에도 살아남았지만 1.0 단계에서는 필수가 아니라 구현에 따라 제공되기도 하고 제공되지 않기도 하는 옵션 기능이다.실제 브라우저가 표준 기능만으로 이들 메서드로 서버에 요청을 보낼 수 있게 된 것은 훨씬 나중의 일로, 자바스크립트에서 XMLHttpRequest가 지원되고 나서부터이다. HTML의 폼에서는 GET과 POST만 지원된다.
- PUT: 이미 존재하는 URL의 문서를 갱신한다.
- DELETE: 지정된 URL의 문서를 삭제한다. 삭제에 성공하면 삭제된 URL은 무효가 된다.
curl 커맨드로 메서드를 전송할 때는 `--request=` 메서드 혹은 그 단축형인 `-X` 메서드를 사용한다.
## 5.2 스테이터스 코드
뉴스그룹에서 가져온 기능 중 하나이다. 세 자리 숫자를 통해 서버가 어떻게 응답했는지 알 수 있다.
- 100번대: 처리가 계속됨을 나타낸다.
- 200번대: 성공했을 때의 응답, 자주 사용되는 스테이터스 코드는 200OK로 정상 종료를 나타낸다.
- 300번대: 서버에서 클라이언트로의 명령. 오류가 아니라 정상 처리의 범주. 리디렉트나 캐시 이용을 지시한다.
- 400번대: 클라이언트가 보낸 요청에 오류가 있다.
- 500번대: 서버 내부에서 오류가 발생했다.
# 6 리디렉트
300번대 일부는 서버가 브라우저에 대해 리디렉트하도록 지시하는 스테이터스 코드이다. 300 이외의 경우는 Location 헤더를 사용해 리디렉트할 곳을 서버에서 클라이언트로 전달한다.


| 스테이터스 코드               | 메서드 변경 | 영구적/일시적 | 캐시      | 설명                     |
| ---------------------- | ------ | ------- | ------- | ---------------------- |
| 301 Moved Permanently  | O      | 영구적     | 한다.     | 도메인 전송, 웹사이트 이전, HTTPS |
| 302 Found              | O      | 일시적     | 지시에 따름  | 일시적 관리, 모바일 기반 전송      |
| 303 See Other          | 허가     | 영구적     | 하지 않는다. | 로그인 후 페이지 전환           |
| 307 Temporary Redirect |        | 일시적     | 지시에 따름  | RFC 7231 에서 추가         |
| 308 Moved Permanently  |        | 영구적     | 한다.     | RFC 7538에서 추가          |
영구적인지 일시적인지는 이동하는 이전 페이지가 이후에도 존재하는지로 분류한다. 새 도메인을 얻어 서버의 콘텐츠로 이동한 경우나 HTTP로 운영되던 페이지를 HTTPS로 전환한 경우에는 예전 페이지를 볼 일이 없습니다. 이때는 영구적인 리디렉트가 됩니다.
메서드 변경은 첫 번째 요청이 POST이고, 두 번째 이후에 GET이나 HEAD를 사용할 경우에 사용자에게 확인할 필요 없이 실시할 수 있는지이다.
- 301/308: 요청된 페이지가 다른 장소로 이동했을 때 사용한다. 영구적으로 이동한다. 검색 엔진도 이 응답을 받으면 기존 페이지의 평가를 새로운 페이지로 계승한다.
- 302/307: 일시적인 이동이다. 모바일 전용 사이트로 이동하거나 관리 페이지를 표시한다.
- 303: 요청된 페이지에 반환할 콘텐츠가 없거나 혹은 원래 반환할 페이지가 따로 있을 때, 그쪽으로 이동시키려고 사용한다.
클라이언트는 Location 헤더 값을 보고, 다시 요청한다. 재전송할 때는 헤더 등도 다시 보낸다.
curl 커맨드에 -L을 부여하면 응답이 300번대고 응답 헤더에 Location 헤더가 있으면 그 헤더에서 지정된 URL에 다시 요청을 보낸다. 또한 스테이터스 코드가 301, 302, 303이고 GET 이외의 메서드인 경우에는 GET으로 리디렉트를 다시 보낸다.
리디렉트하는 곳이 다른 서버라면 리디렉트할 때마다 TCP 세션 접속, HTTP 송수신으로 두 번 왕복 통신이 발생한다.
# 7 URL
URL(Uniform Resource Locator)은 RFC 1738에서 상대 URL은 RFC 1808에서 정의됐다. 모두 HTTP/1.0 보다 빠른 시기의 문서다. HTTP/1.0을 내다보고 먼저 규격화 됐다.
URI에는 URN이라는 이름 부여 규칙도 포함된다. 웹 시스템에서 URN이 등장할 일은 없으므로 URL과 URI는 거의 같다. 
## URL의 구조
```
스키마://호스트명/경로`
```

예를 들면 다음과 같은 요소가 된다.
- 스키마: `http`
- 호스트명: `www.naver.com`
- 경로: `index.html`
URL 사양에 포함되는 모든 요소가 들어간 예제는 다음과 같은 형식이 된다.

```
스키마://사용자:패스워드@호스트명:포트/경로#프래그먼트?쿼리
```
자주 보는 스키마로는 `http`외에 통신 경로가 암호화되는 `https`, 메일러를 시작하는`mailto`가 있다. 로컬 파일을 브라우저로 열면 `file`이 표시된다. 파일 서버의 경우 `ftp`도 있다.
스키마 해석은 브라우저의 책이미다. 브라우저는 스키마를 보고 적절한 접속 방법을 선택해야 한다. 실제로 통신하는 곳은 `호스트명`으로 지정된 서버이다. 같은 주소라도 포트가 다르면 독립적으로 복수의 서버를 운영해 서비스를 제공할 수 있다. 포트가 생략되면 스키마별 기본 포트를 사용한다.
프래그먼트는 HTML에서는 페이지 내 링크의 앵커를 지정하는데 쓰인다.
쿼리는 검색 용어를 지정하거나 표시하고 싶은 웹페이지에 대해서 특정 파라미터를 부여하는데 사용한다.
URL은 주소를 지정하는 데 사용하지만, 동시에 '사용자가 읽는 문장'이기도 하다. 다음과 같은 URL이 있다면
```
http://www.oreilly.co.jp/books/97898172841/
```
호스트명을 보고 오라일리 재펜 사이트라고 파악한다. 그 다음 경로에 있는 books를 보고 서적 관련 페이지라고 알 수 있다. 마지막 경로인 숫자를 통해 ISBN 코드라고 추측할 수 있다. 왼쪽에서 오른쪽으로 갈 수록 정보가 서서히 상세화되어 간다.
기호적인 URL 보다는 사람이 읽을 수 있는 URL이 사용자에게 조금이라도 더 많은 정보를 사전에 전달할 수 있다. 이는 HTTP 기반 웹API를 이용하는 프로그래머가 보더라도 프로그램을 이해하기 쉬워진다는 장점이 있다.
# 8 바디
HTTP/0.9 사양에서는 요청에 데이터를 포함할 수 없었다. 1.0에서는 요창과 응답 양쪽에 헤더가 포함돼 바디와 헤더를 분리할 필요가 있다. 또한 요청에도 콘텐츠를 포함할 수 있게 돼 새로운 역할이 늘어났다.
헤더 끝에 빈 줄을 넣으면 그 이후는 모두 바디가 된다.
HTTP에서 응답의 바디는 단순하다. 한 번 응답할 때마다 한 파일만 반환하기 때문이다. 폼이나 XMLHttpRequest를 사용해 클라이언트에서 서버로 데이터를 전송하는 경우도 요청에 바디가 포함된다는 것뿐이지 응답과 큰 차이가 없다.
속도를 위해 바디를 압축하는 경우 Content-Encoding에서 지정된 압축 알고리즘으로 읽어온 바디의 데이터를 전개할 필요가 있다. 이경우 Content-Length는 압축 후 통신 데이터크기이다.
HEAD 메서드에서 요청시에도 Content-Length 헤더를 반환할 필요가 있다.
curl 에서 송신 시에 바디를 서버에 보내려면 `-d` 옵션을 사용한다. 기본적으로 `ContentType`이 `application/x-www-form-urlencoded`가 된다.
정확히는 `-d`는 `--data` 혹은 `--data-ascii`의 줄임말이다. 텍스트 데이터용이다. URL에 사용할 수 없는 문자라도 변환하지 않는다. 이미 변환됐다고 전제한다. curl 커맨드로 변환하는 경우는 `--data-urlencode`를 사용한다. 이진 데이터를 전송할 경우는 `--data-binary`를 사용한다. 파일명 앞에 `@`을 붙임으로써 파일에서 읽은 내용을 송신할 수 있다.
## 8.1 GET 요청 시의 바디
RFC 2616에서는 서버는 메시지 바디를 읽어올 수 있어야 하지만, 요청된 메서드가 바디의 시맨틱스를 정하지 않는 경우는 요청을 처리할 때 메시지 바디는 무시돼야 한다고 쓰여있다.

#CS #Network 