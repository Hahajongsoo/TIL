HTTP의 틀과 구조는 1.1 이후에도 크게 변하지 않는다. HTTP/1.1의 변경 사항은 다음과 같다.
- 통신 고속화
	- keep-alive가 기본적으로 유효하다
	- 파이프라이닝
- TLS에 의한 암호화 통신을 지원한다.
- 새 메서드 추가
	- PUT과 DELETE가 필수 메서드가 됐다.
	- OPTION, TRACE, CONNECT 메서드가 추가 됐다.
- 프로토콜 업그레이드
- 이름을 사용한 가상 호스트를 지원
- 크기를 사전에 알 수없는 콘텐츠의 청크 전송 인코딩 지원
# 1 통신 고속화
Keep-Alive와 파이프라이닝은 좀 더 범용적으로 모든 HTTP 통신을 고속화하는 기능이다. 브라우저에서 서버로 동시에 접속할 때 HTTP/1.0에서 권장하는 값은 4였다. 병렬로 동시게 접속하는 이 값이 HTTP/1.1에서는 2로 내려갔다. Keep-Alive나 파이프라이닝의 효과를 고려한 결과라 생각한다. 프로토콜 버전 업으로 속도가 개선되고 서버의 부하고 내려간다.
# 1.1 Keep-Alive
HTTP 아래층인 TCP/IP 통신을 효율화 하는 구조이다. Keep-Alive를 사용하지 않으면 하나의 요청마다 통신을 닫아야 하지만, Keep-Alive를 사용하면 연속된 요청에는 접속을 다시 이용한다. 이로써 TCP/IP는 접속까지의 대기 시간이 줄어들고, 통신 처리량이 많아지므로 속도가 올라간 것처럼 느껴진다.
커넥션을 계속 열고 닫고를 반복하는 것과 커넥션을 계속 열고 있는 것의 차이
HTTP/1.0에서는 요청 헤더에 다음 헤더를 추가함으로써 Keep-Alive를 이용할 수 있었다.
```
Connection: Keep-Alive
```
이 헤더를 받아들인 서버가 Keep-Alive를 지원하면, 같은 헤더를 응답 헤더에 추가해서 반환한다.
HTTP/1.1에서는 이 동작이 기본으로 되어 있다. TLS 통신을 이용할 경우 특히 통신 시간을 많이 줄여준다. 패킷이 1회 왕복하는 시간을 1RTT로 부르며 TLS에서는 핸드셰이크 과정에서 2RTT만큼 시간이 걸린다. 이때 Keep-Alive를 이용하면 핸드셰이크 횟수를 줄일 수 있다. 여러 번 반복되는 핸드셰이크를 줄임으로써 응답 시간을 개선할 수 있다.
Keep-Alive를 이용한 통신은 클라이언트나 서버 중 한 쪽이 다음 헤더를 부여해 접속을 끊거나 타임아웃 될 때까지 연결이 유지된다.
```
Connection: Close
```
통신 종료가 규정되어 있긴 하지만, 모든 통신이 확실히 끝났는지를 서버가 판정할 수 없다. 자바스크립트를 이용하면 동적으로 요청을 발신할 수도 있으므로, HTML을 정적으로 해석하는 것만으로는 클라이언트 측에서 모든 통신의 완료를 탐지할 수 없다. 그 때문에 서버에서 Keep-Alive 종료를 명시적으로 보내는 것이 간단하지 않고, 실제로는 타임아웃으로 접속이 끊어지기를 기다리게 된다.
Keep-Alive 지속 시간은 클라이언트와 서버 모두 가지고 있다.
통신이 지속되는 동안 OS의 자원을 계속 소비하므로, 실제로 통신이 전혀 이루어지지 않는데 접속을 유지하는 것은 바람직하지 않다.
curl 커맨드는 복수의 요청을 나열함으로써 Keep-Alive를 사용해 복수의 요청을 계속 보낸다.
## 1.2 파이프라이닝
그대로 사용하는 일은 드물었지만, 그 후 개선의 기초가 됐다고 생각할 수 있으므로 소개한다.
파이프라이닝은 최초의 요청이 완료되기 전에 다음 요청을 보내는 기술이다. 다음 요청까지의 대기시간을 없앰으로써, 네트워크 가동률을 높이고 성능을 향상시킨다. Keep-Alive 이용을 전제로 하며, 서버는 요청이 들어온 순서대로 응답을 반환한다.
그대로 동작한다면, 왕복 시간이 오래걸리는 모바일 통신에서 큰 효과를 기대할 수 있다. 현재 기본으로 활성화환 브라우저는 별로 없다. 서버나 프록시가 바르게 구현하지 않는 경우가 있었고 브라우저에서 구현하지 않았거나 구현했어도 설정에서 꺼둔 브라우저도 있었다.
요청받은 순서대로 응답해야만 하므로, 응답 생성에 시간이 걸리거나 크기가 큰 파일을 반환하는 처리가 있으면 다른 응답에 영향을 준다. 이는 Head of Line blocing이라고 불리는 문제이다.
curl 커맨드 자체로는 파이프라이닝을 지원하지 않는다.
파이프라인이 쓸모없는 사양이었다는 것은 아니다. 파이프라인은 여러 문제를 해결하고, HTTP/2에서 스트림이라는 새로운 구조로 다시 태어났다.
# 2 전송 계층 보안(TLS)
HTTP/1.1과 병행해 통신 경로를 암호화하는 전송 계층 보안이 규격화됐다. TLS는 SSL(Secure Sockets Layer) 3.0을 바탕으로 1996년에 표준화가 시작됐지만, 완료된 것은 HTTP/1.1 이후의 일이다.
TLS는 HTTP/1.1과 함께 이용되는 것을 강하게 의식해서 만들어졌지만, TLS 암호화 자체는 HTTP뿐만 아니라 다양한 형식의 데이터를 양방향으로 흘려보낼 수 있다. TLS는 기존 프로토콜에 통신 경로의 안전성을 추가해 새로운 프로토콜을 만들어낼 수 있는 범용적인 구조로 되어있다. (ex. HTTP와 HTTPS, SMTP와 SMTPS)
HTTP/1.0과 1.1은 중간 프록시 서버나 캐시 장치가 요청과 응답의 내용을 직접 해석하고 가공할 수 있는 구조였기 때문에, 속도 개선 및 로드 분산 등의 목적으로 널리 활용되었다. 하지만 TLS(HTTPS)가 도입되면서, 통신 내용이 암호화되어 중간 장치가 더 이상 내용을 볼 수 없게 되었고, 이에 따라 캐싱이나 조작 기능이 제한되었다. 그럼에도 TLS는 웹 전반의 보안을 강화했으며, WebSocket, HTTP/2 같은 새로운 프로토콜의 기반 인프라로 자리잡았다. 이들 기술은 암호화 기반의 신뢰할 수 있는 통신 채널을 요구하기 때문에, 오히려 TLS가 보편화되면서 원활한 도입이 가능해졌습니다.
TLS에는 몇 가지 버전이 있으며, SSL이라고 불리던 시절도 있다. 다만 실제 SSL은 여러가지 취약성이 알려져 있어, RFC에서도 권장하지 않는다. 인터넷 서비스에서도 무효화된 것이 많고, 실제로 사용되는 것은 대부분 TLS이다.
## 2.1 해시함수
입력 데이터를 규칙에 따라 집약해감으로써 해시 값으로 불리는 짧은 데이터를 만들어낸다. 해시는 '잘게 저민 조각'이라는 뜻이다.
해시 함수에는 암호화 통신을 하는 데 편리한 수학적 특성이 있다. 해시 함수를 `h()` 입력 데이터를 `A, B...`, 산출된 해시 값을 `X, Y...`라고 하자.
- 같은 알고리즘과 같은 입력 데이터라면, 결과로서 생성되는 값은 같다. `h(A)=X`가 항상 성립한다.
- 해시 값은 알고리즘이 같으면 길이가 고정된다. 따라서 입력 데이터가 너무 작을 경우 해시 값이 더 커지지만, 기본적으로는 `len(X)<len(A)`다.
- 해시 값에서 원래 데이터를 유추하기 어렵다. (약한 충돌 내성)
- 같은 해시 값을 생성하는 다른 두 개의 데이터를 찾기 어렵다. (강한 충돌 내성)
해시 함수는 컴퓨터에서 다양한 용도로 쓰인다. 예를 들어 다운로드한 파일이 깨지지 않았는지 확인하는 방법으로 사용된다. 1바이트라도 데이터에 차이가 있으면 해시 값이 바귄다. 이런 용도로 이용될 때 해시 값은 체크섬 혹은 핑거프린트라고 불리기도 한다. Git에서는 파일을 관리할 때 파일명이 아니라 파일 내용을 바탕으로한 해시 값을 사용하고, 이 해시 값을 키로 해서 데이터베이스에 파일을 저장한다. 같은 내용의 파일이 여러 개 있을 때, 데이터의 실체는 하나이다. 커다란 데이터 파일을 모두 비교하지 않고 해시 값만 비교함으로써 재빨리 같은 파일인지 판정할 수 있다.
해시 값 충돌은 매우 드물게 일어나지만, 데이터양이 적으면 거의 일어날 수 없다. 충돌이 일어나기 어려운 특성은 알고리즘의 우수성을 나타내는 지표가 된다.
유명한 해시 함수로는 MD5(128비트), SHA-1(160)비트, SHA-2(SHA-224,SHA256, SHA-512 ...)등이 있는데 MD5와 SHA-1은 보안 용도로 추천하지 않는다. 
## 2.2 공통 키 암호와 공개 키 암호 그리고 디지털 서명
암호화에서 중요한 것은 알고리즘 자체를 비밀로 하는 것이 아니라, 알고리즘이 알려져도 안전하게 통신할 수 있는 것이다. 현재 많이 사용하는 브라우저의 대부분 핵심 소스 코드는 오픈 소스로서 공개된다. 그러므로 암호화 알고리즘 자체를 비밀로 해서는 안된다는 것을 알 수 있다. 현재 일반적으로 사용하는 방식은 암호화 알고리즘은 공개하고, 그 암호화에 사용하는 데이터(키)를 따로 준비하는 방식이다. TLS에서 사용되는 방식에는 공통 키 방식과 공개 키 방식 두 종류가 있다.
공통 키 방식은 자물쇠를 잠글 때와 열 때 모두 같은 열쇠를 사용하는 방식이다. 공통 키 방식은 대칭 암호라고도 불린다. 따라서 통신하는 사람끼리는 이 키를 공유할 필요가 있다. 물리적 세계에서 은닉화는 키를 숨기는 것이지만, 암호화는 키 데이터로 원본 데이터를 파괴한다. 키만 있으면 망가진 데이터를 원래대로 수리할 수 있으므로, 받은 쪽에서 데이터를 복원해 읽는다. 
공개 키 방식은 비대칭 암호라고도 불린다. 공개 키 방식에서 필요한 것은 공개 키와 비밀 키이다. 공개키는 전 세계에 공개되어도 문제가 없지만, 비밀 키는 다른 사람에게 알려져선 안된다. 공개 키 방식에선 집 열쇠와 달리 암호화 키와 암호해독 키가 따로 있다. 암호화하는 것이 공개 키고 해독하는 것은 비밀 키이다. 사물에 비유하면 공개키는 자물쇠이고 비밀키는 열쇠이다. 같은 자물쇠를 여러 개 갖고 있다가 상대방에게 보낸다. 비밀 통신을 원하는 사람은 그 자물쇠를 잠궈 반송한다. 다른 사람은 키를 갖고 있지 않아 열 수 없지만 비밀키를 가진 사람은 그 자물쇠를 열 수 있다.
공개 키 암호의 경우 키와 암호화된 데이터로 원본을 복원할 수는 있어도, 자물쇠인 비밀 키를 추출할 수는 없다.
암호화는 완벽하지 않다. 암호의 안전성은 알고리즘과 비트 수로 강도가 정해진다. 실제로는 상당한 계산량이 필요하지만, 현실적인 시간 내에서 해석이 가능한 경우 보안에 취약하다고 간주된다. 이미 몇몇 알고리즘은 CPU의 발달과 함께 권장하지 않게 됐다.
## 2.3 키교환
키 교환은 클라이언트와 서버 사이에 키를 교환하는 것이다. 간단한 방법으로는 클라이언트에서 공통 키를 생성한 다음 전술한 서버 인증서의 공개 키로 암호화해 보내는 방법이 있고, 키 교환 전용 알고리즘도 있다. 여기선 디피-헬먼 키 교환 알고리즘을 소개한다. 실제로는 이 알고리즘에서 파생된 일시 디피-헬먼을 사용한다.
이 알고리즘의 핵심은 키 자체를 교환하는게 아니라, 클라이언트와 서버에서 각각 키 재료를 만들어 서로 교환하고 각자 계산해서 같은 키를 얻는 것이다.
TLS상에서는 서버가 계산에 사용할 값 `p`와 `q`를 준비한다. 이 값들은 공개 정보로서 그대로 클라이언트에게 넘겨준다. `p`는 큰 소수이지만, 본문 예제에서는 계산을 간편하게 하고자 간단한 수치를 사용했다. `q`는 법`p`에 대한 원시근이다. 원시근이란 다음 조건을 만족하는 수이다. 
>g^1, g^2, ... g^(p-2)의 어느 수치도 q로 나눈 나머지가 1이 아니다.

또 한 가지 값을 계산한다. 이 값을 `Y`라고 한다. 이것도 비밀이다. 가령 `p=23`, `q=5`, `Y=6`이라고 치자. 교환용인 `Ys`를 다음 식으로 계산한다.
> Ys = (g ^ Y) mod p = (5 ^ 6) mod 23 = 8

Server Key Exchange(서버 키 교환) 메세지의 인수로서 `p,q,Ys`를 서버에서 클라이언트로 보낸다. 전송이 끝난 후의 상태는 다음과 같다.

| 변수  | 값   | 클라이언트 | 중간자 | 서버  |
| --- | --- | ----- | --- | --- |
| p   | 23  | 안다    | 안다  | 안다  |
| g   | 5   | 안다    | 안다  | 안다  |
| Y   | 6   | 모른다   | 모른다 | 안다  |
| Ys  | 8   | 안다    | 안다  | 안다  |
클라이언트도 랜덤하게 값 `X`를 생성한다. 마찬가지로 `Xs`를 계산한다. 가령 `X=15`라고 하자.
>Xs = (g ^ X) mod p = (5 ^ 15) mod 23 = 19

Client Key Exchange(클라이언트 키 교환) 메시지의 인수로서 `Xs`를 클라이언트 쪽에서 서버로 보낸다. 전송이 끝난 후의 상태는 다음과 같다.

| 변수  | 값   | 클라이언트 | 중간자 | 서버  |
| --- | --- | ----- | --- | --- |
| X   | 15  | 안다    | 모른다 | 모른다 |
| Xs  | 19  | 안다    | 안다  | 안다  |
클라이언트가 직접 생성한 값 `X`와 서버가 보내준 값 `Ys`로 공통 키의 시드를 생성한다.
>ZZ = Ys ^ X mod p = 8 ^ 15 mod 23 = 2

서버도 직접 생성한 값 `Y`와 클라이언트가 보내준 값 `Xs`로 공통키의 시드를 생성한다.
> ZZ = Xs ^ Y mod p = 19 ^ 6 mod 23 = 2

생성되는 키의 시드 `ZZ`는 나눗셈의 나머지이므로, 상위 비트에 0이 연속해서 치우침이 발생하는 경우가 많아 계산된 결과를 바탕으로 해서 해시 함수를 통해 최종적으로 이용할 키 `K`를 생성한다.
`ZZ`는 당연히 `p`를 넘지 않는 수가 된다. `p`의 길이로 키의 강도가 달라진다. 실제로는 1024비트, 2048비트와 같은 길이를 사용한다. 생성되는 키가 작으면 취약성으로 이어진다. 현재는 2048비트 이상의 길이를 권장한다. 이는 616자리 정도의 소수이다. `Xs`와 `Ys`도 나눈셈의 몫으로 이산하고 있고, 범위가 어느 정도 커서 원래 값을 역산하려면 시간이 걸린다. 프록시 등 중간자는 `p`와 `q`로 계산 중인 공개 값 `Xs`와 `Ys`를 알 수 있지만, 이것만으로는 `X`와  `Y`를 계산할 수 없으므로 오직 서버와 클라이언트만이 공통의 키를 얻을 수 있다.

# 2.4 공통 키 방식과 공개 키 방식을 구분해서 사용하는 이유
TLS는 이 양쪽 방식을 조합했다. TLS에서는 통신마다 한 번만 사용되는 공통 키를 만들어내고, 공개 키 방식을 사용해 통신 상대에게 신중히 키를 전달한 이후는 공통 키로 고속으로 암호화하는 2단계 방식을 이용한다. 공개 키 방식이 안전성이 높지만, 키를 가지고 있어도 암호화와 복호화에 필요한 계산량이 공통 키 방식보다 너무 많기 때문이다.
```go
package main

import (
	"crypto/aes"
	"crypto/cipher"
	"crypto/md5"
	"crypto/rand"
	"crypto/rsa"
	"io"
	"testing"
)

func prepareRSA() (sourceData, label []byte, privateKey *rsa.PrivateKey) {
	sourceData = make([]byte, 128)
	rand.Read(sourceData)
	label = []byte("test label")
	privateKey, _ = rsa.GenerateKey(rand.Reader, 2048)
	return sourceData, label, privateKey
}

func BenchmarkRSAEncryptDecrypt(b *testing.B) {
	sourceData, label, privateKey := prepareRSA()
	publicKey := &privateKey.PublicKey
	md5hash := md5.New()
	b.ResetTimer()
	for b.Loop() {
		rsa.EncryptOAEP(md5hash, rand.Reader, publicKey, sourceData, label)
	}
}

func BenchmarkRSADecrypt(b *testing.B) {
	sourceData, label, privateKey := prepareRSA()
	publicKey := &privateKey.PublicKey
	md5hash := md5.New()
	encrypted, _ := rsa.EncryptOAEP(md5hash, rand.Reader, publicKey, sourceData, label)
	b.ResetTimer()
	for b.Loop() {
		rsa.DecryptOAEP(md5hash, rand.Reader, privateKey, encrypted, label)
	}
}

func prepareAES() (sourceData, nonce []byte, gcm cipher.AEAD) {
	sourceData = make([]byte, 128)
	io.ReadFull(rand.Reader, sourceData)
	key := make([]byte, 32)
	io.ReadFull(rand.Reader, key)
	nonce = make([]byte, 12)
	io.ReadFull(rand.Reader, nonce)
	block, _ := aes.NewCipher(key)
	gcm, _ = cipher.NewGCM(block)

	return sourceData, nonce, gcm
}

func BenchmarkAESEncryptDecrypt(b *testing.B) {
	sourceData, nonce, gcm := prepareAES()
	b.ResetTimer()
	for b.Loop() {
		gcm.Seal(nil, nonce, sourceData, nil)
	}
}

func BenchmarkAESDecrypt(b *testing.B) {
	sourceData, nonce, gcm := prepareAES()
	encrypted := gcm.Seal(nil, nonce, sourceData, nil)
	b.ResetTimer()
	for b.Loop() {
		gcm.Open(nil, nonce, encrypted, nil)
	}
}

```
암호화와 복호화가 다른 컴퓨터에서 진행되는 점을 감안하면 실제 산출량은 더 느린 수치가 된다. 공개 키 암호에서는 비교적 성능이 좋은 컴퓨터를 사용해도 PHS 회선 정도의 속도밖에 안나온다. AES로는 기가비트 광회선에서도 병목이 일어나지 않는 속도로 그 차이는 1만 5천배이다.
## 2.5 TLS 통신 절차
TLS 통신은 크게 셋으로 나눌 수 있다. 
1. 핸드셰이크 프로토콜로 통신을 확립하는 단계
2. 레코드 프로토콜로 불리는 통신 단계
3. SessionTicket 구조를 이용한 재접속 시의 고속 핸드셰이크
### 서버의 신뢰성 확인
서버의 신뢰성을 보증하는 구조는 공개키를 보증하는 구조이기도 해서, 공개 키 기반 구조(public key infrastration)라고 불린다. 브라우저는 서버에서 그 서버의 SSL 서버 인증서를 가져오는 것부터 시작한다.
인증서는 X.509 형식으로 기술된 파일이다. 이 인증서에는 사이트 주체(Subject: 이름과 도메인명), 발행자, 소유자 서버의 공개 키, 유효 기간 등의 항목이 있다. 발행자는 인증기관(certificate authority, CA)라고도 불린다. 우선 사이트의 도메인명과 통신하고 싶은 도메인명은 일치할 것이다. 또한 사이트 주체의 이름은 브라우저의 주소창에 표시된다. 신뢰성 확인의 핵심은 발행자이다.
인증서에는 발행자의 디지털 서명이 있다. 그 발행자의 인증서를 취득함으로써 서명을 검증할 수 있다. 그리고 다시 상위 발행자의 인증서도 차례로 검증해간다. 최종적으로는 발행자와 주체자가 동일한 인증서가 나온다. 이것은 루트 인증기관이라고 불린다. 다만 루트 인증기관 자신의 신뢰성은 이 구조만으로는 보증할 수 없다. 따라서 브라우저와 OS에는 미리 신뢰할 수 있는 인증기관의 인증서가 설치되어 있다. 이 인증서와 대조함으로써 최종적으로 서버가 승인된 것임을 확인할 수 있다.
신뢰가 확인되지 않은 발행자와 주체가 같은 인증서는 '자가 서명 인증서' 라고 불린다. 인증서 자체는 OpenSSL 등의 도구로 손쉽게 만들 수 있다. 
### 키 교환과 통신 시작
공개 키 암호를 사용하는 방법과 키 교환 전용 알고리즘을 사용하는 방법이 있다. 어느 쪽을 쓸 것인지는 최초의 `Client Hello`, `Server Hello` 니고시에이션에서 결정된다.
클라이언트는 먼저 난수를 사용해 통신용 공통 키를 만든다. 난수의 질도 중요하다. 복수의 알고리즘과 난수 생성기를 조합해 난수를 읽기 어렵게 할 수도 있다.
공개 키를 사용하는 방법은 간단하다. 서버 인증서에 첨부된 공개 키로 통신용 공통 키를 암호화해 그 키를 서버에 보낸다. 서버는 인증서의 공개 키에 대응하는 비밀 키를 갖고 있으므로 건네받은 데이터를 복호화해 공통 키를 꺼낼 수 있다.

순방향 비밀성(forward secrecy, 시간적으로 앞으로도 계속 보안이 유지될 것이라는 의미)이 우수하므로, 앞으로 키 교환에서 주류가 되는 것은 키 교환 전용 알고리즘 방식이다. 현재 책정 중인 TLS 1.3 버전에서는 공개 키 암호를 이용한 키 교환은 폐지된다. 공개 키로 암호화된 키 교환 통신 내용이 모두 기록된 경우, 서버의 비밀 키가 유출되면 공통 키가 해독되고 기록된 통신 내용도 해독될 가능성이 있다. 키 교환 전용 알고리즘에서 사용하는 키는 동적으로 계산되고 파일로 저장되지 않기 때문에, 키가 유출될 일이 없다. 공개 키 암호인 RSA 또한 키 교환에는 권장되지 않는다. 
### 통신
통신을 할 때도 기밀성과 무결성(조작 방지)을 위해 암호화를 한다. 암호화에는 공통 키 암호 알고리즘을 이용한다.
TLS 1.2 이전 버전에서는 통신 내용의 해시 값을 계산한 다음, 공통 키 암호로 암호화하는 방법을 지원했다. 이 방법은 전송 내용의 바이트 열에서 생성한 해시 값을 전송 데이터 끝에 붙여 조작을 탐지한다. 이 기법에 대한 공격이 발견됐으므로 TLS 1.3 이후에는 다른 인증암호로 제한된다. 
예를 들어 TLS 1.2의 AES+GCM에서는 암호화와 복호화를 할 때, 일반 공통 키와 별개로 12바이트의 키가 필요하다. 이 중 8바이트는 전송 시 랜덤하게 만들어 부여하고, 4바이트는 핸드셰이크 떄 교환한 서버와 클라이언트의 난수를 재료로 해서 해시 함수를 이용해 생성한다.
### 통신의 고속화
TLS와 HTTP에는 왕복 시간을 줄이기 위한 장치가 몇 가지 구현돼 있다.
1. Keep-Alive를 이용하면 세션이 지속되므로 최초 요청 이후의 통신에서는 RTT가 1이된다.
2. TLS 1.2에는 세션 재개 기능이 있어 최초의 핸드셰이크에서 전에 사용하던 세션ID를 보내면 이후의 키 교환이 생략되므로 1RTT로 세션이 재개된다. 1.3에서는 사전에 키를 공유해 둠으로써 0RTT로 최초 요청부터 정보를 전송할 수 있게 된다.
3. TLS 1.3에서는 키 교환과 비밀 키 암호가 분리되어 암호화 스위트로 비밀 키 암호를 니고시에이션한 결과를 기다리지 않고, 최초의 `Client Hello`로 클라이언트 쪽에서 키를 교환할 수 있게 된다. 통신이 1 왕복 줄어 1RTT로 인증이 완료된다.
TLS 아래 계층을 핸드셰이크가 필요하지 않고 재전송 및 흐름제어도 하지 않는 UDP로 대체해, 애플리케이션 계증에서 재전송하는 QUIC가 있다. UDP는 핸드셰이크를 하지 않으므로 0RTT로 연결할 수 있다. 
## 2.6 암호강도
알고리즘의 수학적 특성에 따라 어느 정도의 강도인지 기준이 되는 수치가 있다. 이 수치는 다음 절의 암호와 해시 알고리즘을 선택할 때 지표가 된다. 이 지표는 비트 안전성으로 불리고, 각 줄의 왼쪽에 있는 공통 키 암호 방식의 비트 수로 레벨이 나뉜다. 비트 수가 1 증가하면 두 배 강해진다.

| 공통 키 암호 방식 | RSA/DSA/DH | 타원 곡선 암호 | 해시 값 |
| ---------- | ---------- | -------- | ---- |
| 80         | 1024       | 160      | 160  |
| 112        | 2048       | 224      | 224  |
| 128        | 3072       | 256      | 256  |
| 256        | 15360      | 512      | 512  |
64비트에서는 소규모 조직의 극히 짧은 기간의 공격으로도 해독되며, 80비트에서는 단기간의 조직적인 공격으로 해독된다고 한다. 96비트, 112비트, 128비트에서 각각 10년, 20년, 30년을 견딜 수 있고, 256비트는 양자 컴퓨터 공격에 대한 내성이 있다고 간주한다.
## 2.7 암호화 스위트
TLS는 HTTP와는 또 다른 방식으로 사양에 유연성을 부여한다. TLS의 골격이 되는 '서버를 인증하고, 키를 교환해서 통신한다'는 흐름은 TLS 1.0에서 1.3까지 크게 달라지지 않는다. 키 교환 방법, 메시지 암호화, 메시지 서명 방식 등 각각의 장면에서 사용하는 알고리즘 조합을 리스트화해 관리하고 서버/클라이언트에서 공통으로 사용할 수 있는 것을 선택하는 시스템을 만들어, 새로운 알고리즘을 조금씩 도입하거나 낡은 알고리즘을 비추천하는 작업을 버전 간에서 시행하기 쉬워졌다. 이 알고리즘 세트를 암호화 스위트라고 부른다.
암호화 스위트에는 많은 조합이 있다. 다음 명령으로 어떤 것이 있는지 볼 수 있다.
```shell
$ openssl ciphers -v
ECDHE-RSA-AES128-GCM-SHA256  TLSv1.2  Kx=ECDH/RSA     Au=ECDH  Enc=AESGCM(128)  Mac=AEAD
ECDHE-ECDSA-AES128-GCM-SHA256 TLSv1.2  Kx=ECDH/ECDSA  Au=ECDH Enc=AESGCM(128) Mac=AEAD
:
```
이 목록은 네 항목의 조합으로 만들어진다.

| 값                             | 의미                | 사용되는 값의 예                      |
| ----------------------------- | ----------------- | ------------------------------ |
| `ECDHE-RSA-AES256-GCM-SHA384` | 암호화 스위트를 식별하는 이름  |                                |
| `TLSv1.2`                     | 암호가 지원된 프로토콜 버전   | `TLSv1.2`등                     |
| `Kx=ECDH/RSA`                 | 교환 키 알고리즘/서명 알고리즘 | `DH/RSA`, `ECDH/ECDSA`         |
| `Au=RSA`                      | 인증 알고리즘           | `RSA/ECDSA`                    |
| `Enc=AESGCM(256)`             | 레코드 암호 알고리즘       | `AES=GCM`, `CHACHA20-POLY1305` |
| `Mac`                         | 메시지 서명            | `AEAD`, `SHA386`               |
단 이 중에는 하위 호환성 때문에 들어있지만 현재는 이용을 권장하지 않는 것도 많다. TLS 1.3에서는 그 이전과 비교할 때 권장하는 조합이 많이 바뀐다. TLS 1.3을 예상하고 책정된 HTTP/2의 RFC 7540에는 사용해서는 안 될 암호화 스위트의 블랙리스트가 정의되어 있다.
- 몇몇 암호 방식(DES, RC4, MD5, SHA-1)이 안전하지 않다고 간주됐고, 안전한 암호 방식이라도 키 길이가 짧은 것은 강도 부족으로 보고 선택 사항에서 제외했다.
- 스트림 암호인 RC4도 블록 암호인 MAC 후 암호화 방식도 취약하다고 고 인증된 암호(AEAD)만 사용하게 됐다.
- 공통 키 알고리즘에서 사용할 수 있는 알고리즘이 AES뿐이라 AES가 안전하지 않게 됐을 때 다른 수단이 없어지므로, 안전을 위해 다른 알고리즘이 추가 됐다.
## 2.8 프로토콜 선택
TLS가 제공하는 기능 중에는 애플리케이션 계층 프로토콜을 선택하는 확장 기능이 있다.
ALPN(Application-Layer Protocol Negotiation)에서는 TLS의 최초 핸드셰이크 시 (ClientHello) 클라이언트가 서버에 '클라이언트가 이용할 수 있는 프로토콜 목록'을 첨부해서 보낸다. 서버는 그에 대한 응답(ServerHello)으로 키 교환을 하고 인증서와 함께 선택한 프로토콜을 보낸다. 클라이언트가 보낸 목록에서 서버가 사용할 프로토콜을 하나 골라 반환하는 바법은 콘텐트 니고시에이션과 같다.
TLS는 통신 내용을 암호화하여 중간 프록시가 간섭하지 못하게 하고, 서버와의 버전 협상을 통해 통신이 가능하도록 하며,이 덕분에 중간 장비가 허용하지 않는 새로운 혹은 비표준 프로토콜도 문제 없이 사용할 수 있게 한다.
## 2.9 TLS가 지키는 것
TLS는 통신 경로의 안전을 지키기 위한 구조이고, 클라이언트와 서버 간 통신 경로를 전혀 신뢰할 수 없는 상태에서도 안전하게 통신할 수 있도록 설계됐다. 통신 경로를 신뢰할 수 없다는 것은 중간자가 통신을 감청하거나 통신 내용을 자유롭게 변경하거나 클라이언트로 속여 요청을 보낼 수 있다는 뜻이지만, TLS는 그 상태에서도 도청도 조작도 사칭도 할 수 없는 안전한 통신을 제공한다.
TLS는 통신 경로 밖의 정보는 숨겨주지 않는다. 브라우저의 쿠키를 빼내는 크래킹은 TLS로 보호하고 있어도, 브라우저를 오작동시켜 의도치 않은 서버로 보낼 수 있다. 서버가 크랙됐을 때도 정보가 보호되지 않는다. 사용자의 패스워드를 평문으로 데이터베이스에 저장하지 않고, 해시화해서 보호하는 것은 TLS와 관계없이 꼭 해야 하는 일이다.
# 3 PUT메서드와 DELETE 메서드의 표준화
HTTP/1.0에서는 옵션이었던 `PUT`과 `DELETE`메서드도 필수 메서드로 추가됐다. 이로써 DB에서 데이터를 다룰 때 사용하는 기본적인 네 개 메서드(CRUD)가 갖춰져, HTTP는 데이터를 취급하는 프로토콜로도 이용할 수 있게 됐다.

| HTTP 메서드 | 대응하는 CRUD 조작 | SQL      |
| -------- | ------------ | -------- |
| `GET`    | `Read`       | `select` |
| `POST`   | `Create`     | `insert` |
| `PUT`    | `Update`     | `update` |
| `DELETE` | `Delete`     | `delete` |
실제로는 HTTP는 도큐먼드를 다루는 고수준 API고 CRUD는 프리미티브한 조작이라는데 차이가 있다. 실제로 CRUD와 메서드를 일대일로 대응시켜 HTTP를 거쳐서 이용하는 데이터베이서 관리 시스템을 만들 일은 없다. 예를 들어 `POST` 메서드로 내용을 게시한다고 했을 때 DB에는 여러 테이블을 조작하게 될 수 있다.
DB의 경우는 트랜잭션이라는 큰 테두리 안에서 데이터의 불일치가 일어나지 않도록 CRUD를 사용한 1회 액션으로 데이터를 갱신한다. HTTP에는 트랜잭션이 없고, 1회 액션에 해당하는 조작이 HTTP의 1요청이다. HTTP의 경우는 비록 수면 아래에서 복잡한 일이 일어나도 겉보기에 1액션으로 보이게 할 필요가 있다.
새로 늘어난 `PUT`과 `DELETE`는 HTML의 폼으로 보낼 수 없고, `XMLHttpRequest`를 사용해야 한다. 웹 API의 시맨틱스에 관해서는 REST API 에서 다시 소개한다.
# 4 OPTIONS, TRACE, CONNECT 메서드 추가
## 4.1 OPTIONS
`OPTIONS` 메서드는 서버가 받아들일 수 있는 메서드 목록을 반환한다. curl 배포 사이트에서 불러내보면 다음과 같다.
```shell
$ curl -X OPTIONS -v https://curl.se
:
* using HTTP/1.x
> OPTIONS / HTTP/1.1
> Host: curl.se
> User-Agent: curl/8.13.0
> Accept: */*
>
* TLSv1.3 (IN), TLS handshake, Newsession Ticket (4):
* Request completely sent off
< HTTP/1.1 200 OK
< Connection: keep-alive
< Content-Length: 0
< Server: nginx/1.21.1
< Content-Type: text/html
< X-Frame-Options: SAMEORIGIN
< Allow: GET,POST,OPTIONS,HEAD
< Cache-Control: max-age=60
< Expires: Tue, 06 May 2025 03:54:16 GMT
< X-Content-Type-Options: nosniff
< Content-Security-Policy: default-src 'self' curl.haxx.se www.curl.se curl.se; style-src 'unsafe-inline' 'self' curl.haxx.se www.curl.se curl.se; require-trusted-types-for 'script';
:
```
응답 중에서 `Allow`헤더에 결과가 들어있다. 이 서버가 `OPTIONS`, `GET`, `HEAD`, `POST`메서드를 받을 수 있다는 것을 알 수 있다.
그러나 대부분 웹 서버는 `OPTIONS` 메서드를 허용하지 않는다. nginx도 기본적으로 다룰 수 없고 `405 Method Not Allowed`를 반환한다. `OPTIONS` 메서드는 브라우저가 다른 서버에 요청을 보낼 때, 사전 확인에 사용되는 경우가 있다. 자세한 내용은 CORS에서 다룬다.
