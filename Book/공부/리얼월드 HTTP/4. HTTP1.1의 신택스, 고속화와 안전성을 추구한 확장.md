HTTP의 틀과 구조는 1.1 이후에도 크게 변하지 않는다. HTTP/1.1의 변경 사항은 다음과 같다.
- 통신 고속화
	- keep-alive가 기본적으로 유효하다
	- 파이프라이닝
- TLS에 의한 암호화 통신을 지원한다.
- 새 메서드 추가
	- PUT과 DELETE가 필수 메서드가 됐다.
	- OPTION, TRACE, CONNECT 메서드가 추가 됐다.
- 프로토콜 업그레이드
- 이름을 사용한 가상 호스트를 지원
- 크기를 사전에 알 수없는 콘텐츠의 청크 전송 인코딩 지원
# 1 통신 고속화
Keep-Alive와 파이프라이닝은 좀 더 범용적으로 모든 HTTP 통신을 고속화하는 기능이다. 브라우저에서 서버로 동시에 접속할 때 HTTP/1.0에서 권장하는 값은 4였다. 병렬로 동시게 접속하는 이 값이 HTTP/1.1에서는 2로 내려갔다. Keep-Alive나 파이프라이닝의 효과를 고려한 결과라 생각한다. 프로토콜 버전 업으로 속도가 개선되고 서버의 부하고 내려간다.
# 1.1 Keep-Alive
HTTP 아래층인 TCP/IP 통신을 효율화 하는 구조이다. Keep-Alive를 사용하지 않으면 하나의 요청마다 통신을 닫아야 하지만, Keep-Alive를 사용하면 연속된 요청에는 접속을 다시 이용한다. 이로써 TCP/IP는 접속까지의 대기 시간이 줄어들고, 통신 처리량이 많아지므로 속도가 올라간 것처럼 느껴진다.
커넥션을 계속 열고 닫고를 반복하는 것과 커넥션을 계속 열고 있는 것의 차이
HTTP/1.0에서는 요청 헤더에 다음 헤더를 추가함으로써 Keep-Alive를 이용할 수 있었다.
```
Connection: Keep-Alive
```
이 헤더를 받아들인 서버가 Keep-Alive를 지원하면, 같은 헤더를 응답 헤더에 추가해서 반환한다.
HTTP/1.1에서는 이 동작이 기본으로 되어 있다. TLS 통신을 이용할 경우 특히 통신 시간을 많이 줄여준다. 패킷이 1회 왕복하는 시간을 1RTT로 부르며 TLS에서는 핸드셰이크 과정에서 2RTT만큼 시간이 걸린다. 이때 Keep-Alive를 이용하면 핸드셰이크 횟수를 줄일 수 있다. 여러 번 반복되는 핸드셰이크를 줄임으로써 응답 시간을 개선할 수 있다.
Keep-Alive를 이용한 통신은 클라이언트나 서버 중 한 쪽이 다음 헤더를 부여해 접속을 끊거나 타임아웃 될 때까지 연결이 유지된다.
```
Connection: Close
```
통신 종료가 규정되어 있긴 하지만, 모든 통신이 확실히 끝났는지를 서버가 판정할 수 없다. 자바스크립트를 이용하면 동적으로 요청을 발신할 수도 있으므로, HTML을 정적으로 해석하는 것만으로는 클라이언트 측에서 모든 통신의 완료를 탐지할 수 없다. 그 때문에 서버에서 Keep-Alive 종료를 명시적으로 보내는 것이 간단하지 않고, 실제로는 타임아웃으로 접속이 끊어지기를 기다리게 된다.
Keep-Alive 지속 시간은 클라이언트와 서버 모두 가지고 있다.
통신이 지속되는 동안 OS의 자원을 계속 소비하므로, 실제로 통신이 전혀 이루어지지 않는데 접속을 유지하는 것은 바람직하지 않다.
curl 커맨드는 복수의 요청을 나열함으로써 Keep-Alive를 사용해 복수의 요청을 계속 보낸다.
## 1.2 파이프라이닝
그대로 사용하는 일은 드물었지만, 그 후 개선의 기초가 됐다고 생각할 수 있으므로 소개한다.
파이프라이닝은 최초의 요청이 완료되기 전에 다음 요청을 보내는 기술이다. 다음 요청까지의 대기시간을 없앰으로써, 네트워크 가동률을 높이고 성능을 향상시킨다. Keep-Alive 이용을 전제로 하며, 서버는 요청이 들어온 순서대로 응답을 반환한다.
그대로 동작한다면, 왕복 시간이 오래걸리는 모바일 통신에서 큰 효과를 기대할 수 있다. 현재 기본으로 활성화환 브라우저는 별로 없다. 서버나 프록시가 바르게 구현하지 않는 경우가 있었고 브라우저에서 구현하지 않았거나 구현했어도 설정에서 꺼둔 브라우저도 있었다.
요청받은 순서대로 응답해야만 하므로, 응답 생성에 시간이 걸리거나 크기가 큰 파일을 반환하는 처리가 있으면 다른 응답에 영향을 준다. 이는 Head of Line blocing이라고 불리는 문제이다.
curl 커맨드 자체로는 파이프라이닝을 지원하지 않는다.
파이프라인이 쓸모없는 사양이었다는 것은 아니다. 파이프라인은 여러 문제를 해결하고, HTTP/2에서 스트림이라는 새로운 구조로 다시 태어났다.
# 2 전송 계층 보안(TLS)
HTTP/1.1과 병행해 통신 경로를 암호화하는 전송 계층 보안이 규격화됐다. TLS는 SSL(Secure Sockets Layer) 3.0을 바탕으로 1996년에 표준화가 시작됐지만, 완료된 것은 HTTP/1.1 이후의 일이다.
TLS는 HTTP/1.1과 함께 이용되는 것을 강하게 의식해서 만들어졌지만, TLS 암호화 자체는 HTTP뿐만 아니라 다양한 형식의 데이터를 양방향으로 흘려보낼 수 있다. 