HTTP의 틀과 구조는 1.1 이후에도 크게 변하지 않는다. HTTP/1.1의 변경 사항은 다음과 같다.
- 통신 고속화
	- keep-alive가 기본적으로 유효하다
	- 파이프라이닝
- TLS에 의한 암호화 통신을 지원한다.
- 새 메서드 추가
	- PUT과 DELETE가 필수 메서드가 됐다.
	- OPTION, TRACE, CONNECT 메서드가 추가 됐다.
- 프로토콜 업그레이드
- 이름을 사용한 가상 호스트를 지원
- 크기를 사전에 알 수없는 콘텐츠의 청크 전송 인코딩 지원
# 1 통신 고속화
Keep-Alive와 파이프라이닝은 좀 더 범용적으로 모든 HTTP 통신을 고속화하는 기능이다. 브라우저에서 서버로 동시에 접속할 때 HTTP/1.0에서 권장하는 값은 4였다. 병렬로 동시게 접속하는 이 값이 HTTP/1.1에서는 2로 내려갔다. Keep-Alive나 파이프라이닝의 효과를 고려한 결과라 생각한다. 프로토콜 버전 업으로 속도가 개선되고 서버의 부하고 내려간다.
# 1.1 Keep-Alive
HTTP 아래층인 TCP/IP 통신을 효율화 하는 구조이다. Keep-Alive를 사용하지 않으면 하나의 요청마다 통신을 닫아야 하지만, Keep-Alive를 사용하면 연속된 요청에는 접속을 다시 이용한다. 이로써 TCP/IP는 접속까지의 대기 시간이 줄어들고, 통신 처리량이 많아지므로 속도가 올라간 것처럼 느껴진다.
커넥션을 계속 열고 닫고를 반복하는 것과 커넥션을 계속 열고 있는 것의 차이
HTTP/1.0에서는 요청 헤더에 다음 헤더를 추가함으로써 Keep-Alive를 이용할 수 있었다.
```
Connection: Keep-Alive
```
이 헤더를 받아들인 서버가 Keep-Alive를 지원하면, 같은 헤더를 응답 헤더에 추가해서 반환한다.
HTTP/1.1에서는 이 동작이 기본으로 되어 있다. TLS 통신을 이용할 경우 특히 통신 시간을 많이 줄여준다. 패킷이 1회 왕복하는 시간을 1RTT로 부르며 TLS에서는 핸드셰이크 과정에서 2RTT만큼 시간이 걸린다. 이때 Keep-Alive를 이용하면 핸드셰이크 횟수를 줄일 수 있다. 여러 번 반복되는 핸드셰이크를 줄임으로써 응답 시간을 개선할 수 있다.
Keep-Alive를 이용한 통신은 클라이언트나 서버 중 한 쪽이 다음 헤더를 부여해 접속을 끊거나 타임아웃 될 때까지 연결이 유지된다.
```
Connection: Close
```
통신 종료가 규정되어 있긴 하지만, 모든 통신이 확실히 끝났는지를 서버가 판정할 수 없다. 자바스크립트를 이용하면 동적으로 요청을 발신할 수도 있으므로, HTML을 정적으로 해석하는 것만으로는 클라이언트 측에서 모든 통신의 완료를 탐지할 수 없다. 그 때문에 서버에서 Keep-Alive 종료를 명시적으로 보내는 것이 간단하지 않고, 실제로는 타임아웃으로 접속이 끊어지기를 기다리게 된다.
Keep-Alive 지속 시간은 클라이언트와 서버 모두 가지고 있다.
통신이 지속되는 동안 OS의 자원을 계속 소비하므로, 실제로 통신이 전혀 이루어지지 않는데 접속을 유지하는 것은 바람직하지 않다.
curl 커맨드는 복수의 요청을 나열함으로써 Keep-Alive를 사용해 복수의 요청을 계속 보낸다.
## 1.2 파이프라이닝
그대로 사용하는 일은 드물었지만, 그 후 개선의 기초가 됐다고 생각할 수 있으므로 소개한다.
파이프라이닝은 최초의 요청이 완료되기 전에 다음 요청을 보내는 기술이다. 다음 요청까지의 대기시간을 없앰으로써, 네트워크 가동률을 높이고 성능을 향상시킨다. Keep-Alive 이용을 전제로 하며, 서버는 요청이 들어온 순서대로 응답을 반환한다.
그대로 동작한다면, 왕복 시간이 오래걸리는 모바일 통신에서 큰 효과를 기대할 수 있다. 현재 기본으로 활성화환 브라우저는 별로 없다. 서버나 프록시가 바르게 구현하지 않는 경우가 있었고 브라우저에서 구현하지 않았거나 구현했어도 설정에서 꺼둔 브라우저도 있었다.
요청받은 순서대로 응답해야만 하므로, 응답 생성에 시간이 걸리거나 크기가 큰 파일을 반환하는 처리가 있으면 다른 응답에 영향을 준다. 이는 Head of Line blocing이라고 불리는 문제이다.
curl 커맨드 자체로는 파이프라이닝을 지원하지 않는다.
파이프라인이 쓸모없는 사양이었다는 것은 아니다. 파이프라인은 여러 문제를 해결하고, HTTP/2에서 스트림이라는 새로운 구조로 다시 태어났다.
# 2 전송 계층 보안(TLS)
HTTP/1.1과 병행해 통신 경로를 암호화하는 전송 계층 보안이 규격화됐다. TLS는 SSL(Secure Sockets Layer) 3.0을 바탕으로 1996년에 표준화가 시작됐지만, 완료된 것은 HTTP/1.1 이후의 일이다.
TLS는 HTTP/1.1과 함께 이용되는 것을 강하게 의식해서 만들어졌지만, TLS 암호화 자체는 HTTP뿐만 아니라 다양한 형식의 데이터를 양방향으로 흘려보낼 수 있다. TLS는 기존 프로토콜에 통신 경로의 안전성을 추가해 새로운 프로토콜을 만들어낼 수 있는 범용적인 구조로 되어있다. (ex. HTTP와 HTTPS, SMTP와 SMTPS)
HTTP/1.0과 1.1은 중간 프록시 서버나 캐시 장치가 요청과 응답의 내용을 직접 해석하고 가공할 수 있는 구조였기 때문에, 속도 개선 및 로드 분산 등의 목적으로 널리 활용되었다. 하지만 TLS(HTTPS)가 도입되면서, 통신 내용이 암호화되어 중간 장치가 더 이상 내용을 볼 수 없게 되었고, 이에 따라 캐싱이나 조작 기능이 제한되었다. 그럼에도 TLS는 웹 전반의 보안을 강화했으며, WebSocket, HTTP/2 같은 새로운 프로토콜의 기반 인프라로 자리잡았다. 이들 기술은 암호화 기반의 신뢰할 수 있는 통신 채널을 요구하기 때문에, 오히려 TLS가 보편화되면서 원활한 도입이 가능해졌습니다.
TLS에는 몇 가지 버전이 있으며, SSL이라고 불리던 시절도 있다. 다만 실제 SSL은 여러가지 취약성이 알려져 있어, RFC에서도 권장하지 않는다. 인터넷 서비스에서도 무효화된 것이 많고, 실제로 사용되는 것은 대부분 TLS이다.
## 2.1 해시함수
입력 데이터를 규칙에 따라 집약해감으로써 해시 값으로 불리는 짧은 데이터를 만들어낸다. 해시는 '잘게 저민 조각'이라는 뜻이다.
해시 함수에는 암호화 통신을 하는 데 편리한 수학적 특성이 있다. 해시 함수를 `h()` 입력 데이터를 `A, B...`, 산출된 해시 값을 `X, Y...`라고 하자.
- 같은 알고리즘과 같은 입력 데이터라면, 결과로서 생성되는 값은 같다. `h(A)=X`가 항상 성립한다.
- 해시 값은 알고리즘이 같으면 길이가 고정된다. 따라서 입력 데이터가 너무 작을 경우 해시 값이 더 커지지만, 기본적으로는 `len(X)<len(A)`다.
- 해시 값에서 원래 데이터를 유추하기 어렵다. (약한 충돌 내성)
- 같은 해시 값을 생성하는 다른 두 개의 데이터를 찾기 어렵다. (강한 충돌 내성)
해시 함수는 컴퓨터에서 다양한 용도로 쓰인다. 예를 들어 다운로드한 파일이 깨지지 않았는지 확인하는 방법으로 사용된다. 1바이트라도 데이터에 차이가 있으면 해시 값이 바귄다. 이런 용도로 이용될 때 해시 값은 체크섬 혹은 핑거프린트라고 불리기도 한다. Git에서는 파일을 관리할 때 파일명이 아니라 파일 내용을 바탕으로한 해시 값을 사용하고, 이 해시 값을 키로 해서 데이터베이스에 파일을 저장한다. 같은 내용의 파일이 여러 개 있을 때, 데이터의 실체는 하나이다. 커다란 데이터 파일을 모두 비교하지 않고 해시 값만 비교함으로써 재빨리 같은 파일인지 판정할 수 있다.
해시 값 충돌은 매우 드물게 일어나지만, 데이터양이 적으면 거의 일어날 수 없다. 충돌이 일어나기 어려운 특성은 알고리즘의 우수성을 나타내는 지표가 된다.
유명한 해시 함수로는 MD5(128비트), SHA-1(160)비트, SHA-2(SHA-224,SHA256, SHA-512 ...)등이 있는데 MD5와 SHA-1은 보안 용도로 추천하지 않는다. 
## 2.2 공통 키 암호와 공개 키 암호 그리고 디지털 서명
암호화에서 중요한 것은 알고리즘 자체를 비밀로 하는 것이 아니라, 알고리즘이 알려져도 안전하게 통신할 수 있는 것이다. 현재 많이 사용하는 브라우저의 대부분 핵심 소스 코드는 오픈 소스로서 공개된다. 그러므로 암호화 알고리즘 자체를 비밀로 해서는 안된다는 것을 알 수 있다. 현재 일반적으로 사용하는 방식은 암호화 알고리즘은 공개하고, 그 암호화에 사용하는 데이터(키)를 따로 준비하는 방식이다. TLS에서 사용되는 방식에는 공통 키 방식과 공개 키 방식 두 종류가 있다.
공통 키 방식은 자물쇠를 잠글 때와 열 때 모두 같은 열쇠를 사용하는 방식이다. 공통 키 방식은 대칭 암호라고도 불린다. 따라서 통신하는 사람끼리는 이 키를 공유할 필요가 있다. 물리적 세계에서 은닉화는 키를 숨기는 것이지만, 암호화는 키 데이터로 원본 데이터를 파괴한다. 키만 있으면 망가진 데이터를 원래대로 수리할 수 있으므로, 받은 쪽에서 데이터를 복원해 읽는다. 
공개 키 방식은 비대칭 암호라고도 불린다. 공개 키 방식에서 필요한 것은 공개 키와 비밀 키이다. 공개키는 전 세계에 공개되어도 문제가 없지만, 비밀 키는 다른 사람에게 알려져선 안된다. 공개 키 방식에선 집 열쇠와 달리 암호화 키와 암호해독 키가 따로 있다. 암호화하는 것이 공개 키고 해독하는 것은 비밀 키이다. 사물에 비유하면 공개키는 자물쇠이고 비밀키는 열쇠이다. 같은 자물쇠를 여러 개 갖고 있다가 상대방에게 보낸다. 비밀 통신을 원하는 사람은 그 자물쇠를 잠궈 반송한다. 다른 사람은 키를 갖고 있지 않아 열 수 없지만 비밀키를 가진 사람은 그 자물쇠를 열 수 있다.
공개 키 암호의 경우 키와 암호화된 데이터로 원본을 복원할 수는 있어도, 자물쇠인 비밀 키를 추출할 수는 없다.
암호화는 완벽하지 않다. 암호의 안전성은 알고리즘과 비트 수로 강도가 정해진다. 실제로는 상당한 계산량이 필요하지만, 현실적인 시간 내에서 해석이 가능한 경우 보안에 취약하다고 간주된다. 이미 몇몇 알고리즘은 CPU의 발달과 함께 권장하지 않게 됐다.
## 2.3 키교환
키 교환은 클라이언트와 서버 사이에 키를 교환하는 것이다. 간단한 방법으로는 클라이언트에서 공통 키를 생성한 다음 전술한 서버 인증서의 공개 키로 암호화해 보내는 방법이 있고, 키 교환 전용 알고리즘도 있다. 여기선 디피-헬먼 키 교환 알고리즘을 소개한다. 실제로는 이 알고리즘에서 파생된 일시 디피-헬먼을 사용한다.
이 알고리즘의 핵심은 키 자체를 교환하는게 아니라, 클라이언트와 서버에서 각각 키 재료를 만들어 서로 교환하고 각자 계산해서 같은 키를 얻는 것이다.
TLS상에서는 서버가 계산에 사용할 값 `p`와 `q`를 준비한다. 이 값들은 공개 정보로서 그대로 클라이언트에게 넘겨준다. `p`는 큰 소수이지만, 본문 예제에서는 계산을 간편하게 하고자 간단한 수치를 사용했다. `q`는 법`p`에 대한 원시근이다. 원시근이란 다음 조건을 만족하는 수이다. 
>g^1, g^2, ... g^(p-2)의 어느 수치도 q로 나눈 나머지가 1이 아니다.

또 한 가지 값을 계산한다. 이 값을 `Y`라고 한다. 이것도 비밀이다. 가령 `p=23`, `q=5`, `Y=6`이라고 치자. 교환용인 `Ys`를 다음 식으로 계산한다.
> Ys = (g ^ Y) mod p = (5 ^ 6) mod 23 = 8

Server Key Exchange(서버 키 교환) 메세지의 인수로서 `p,q,Ys`를 서버에서 클라이언트로 보낸다. 전송이 끝난 후의 상태는 다음과 같다.

| 변수  | 값   | 클라이언트 | 중간자 | 서버  |
| --- | --- | ----- | --- | --- |
| p   | 23  | 안다    | 안다  | 안다  |
| g   | 5   | 안다    | 안다  | 안다  |
| Y   | 6   | 모른다   | 모른다 | 안다  |
| Ys  | 8   | 안다    | 안다  | 안다  |
클라이언트도 랜덤하게 값 `X`를 생성한다. 마찬가지로 `Xs`를 계산한다. 가령 `X=15`라고 하자.
>Xs = (g ^ X) mod p = (5 ^ 15) mod 23 = 19

Client Key Exchange(클라이언트 키 교환) 메시지의 인수로서 `Xs`를 클라이언트 쪽에서 서버로 보낸다. 전송이 끝난 후의 상태는 다음과 같다.

| 변수  | 값   | 클라이언트 | 중간자 | 서버  |
| --- | --- | ----- | --- | --- |
| X   | 15  | 안다    | 모른다 | 모른다 |
| Xs  | 19  | 안다    | 안다  | 안다  |
클라이언트가 직접 생성한 값 `X`와 서버가 보내준 값 `Ys`로 공통 키의 시드를 생성한다.
>ZZ = Ys ^ X mod p = 8 ^ 15 mod 23 = 2

서버도 직접 생성한 값 `Y`와 클라이언트가 보내준 값 `Xs`로 공통키의 시드를 생성한다.
> ZZ = Xs ^ Y mod p = 19 ^ 6 mod 23 = 2

생성되는 키의 시드 `ZZ`는 나눗셈의 나머지이므로, 상위 비트에 0이 연속해서 치우침이 발생하는 경우가 많아 계산된 결과를 바탕으로 해서 해시 함수를 통해 최종적으로 이용할 키 `K`를 생성한다.
`ZZ`는 당연히 `p`를 넘지 않는 수가 된다. `p`의 길이로 키의 강도가 달라진다. 실제로는 1024비트, 2048비트와 같은 길이를 사용한다. 생성되는 키가 작으면 취약성으로 이어진다. 현재는 2048비트 이상의 길이를 권장한다. 이는 616자리 정도의 소수이다. `Xs`와 `Ys`도 나눈셈의 몫으로 이산하고 있고, 범위가 어느 정도 커서 원래 값을 역산하려면 시간이 걸린다. 프록시 등 중간자는 `p`와 `q`로 계산 중인 공개 값 `Xs`와 `Ys`를 알 수 있지만, 이것만으로는 `X`와  `Y`를 계산할 수 없으므로 오직 서버와 클라이언트만이 공통의 키를 얻을 수 있다.
