앞 장에서 HTTP의 기본 네 요소를 설명했다.
- 메서드와 경로
- 헤더
- 바디
- 스테이터스 코드
브라우저가 기본 요소들을 어떻게 응용하고 기본 기능을 실현하는지 살펴본다.
# 1 단순한 폼 전송(x-www-form-urlencoded)
HTTP/1.0의 바디 수신은 클라이언트가 지정한 콘텐츠가 그대로 저장될 뿐이다. 기본적으로 한 번 HTTP가 응답할 때마다 한 파일밖에 반환하지 못하기 때문이다. 즉 응답의 본체를 지정한 바이트 수만큼 읽어오면 그만이다. 
폼을 사용한 `POST` 전송에는 몇 가지 방식이 있다. 가장 단순한 전송 방식은 다음과 같다.
```HTML
<form method="POST">
	<input name="title">
	<input name="author">
	<input name="submit">
</form>
```
일반적인 웹에서 볼 수 있는 폼이며 method에는 `POST`가 설정돼 있다. 다음처럼 curl 커맨드를 사용하면 폼과 같은 형식으로 전송할 수 있다.
```shell
$ curl --http1.0 -d title="The Art of Community" -d author="Jono Bacon" http://localhost:8080
```
curl 커맨드는 `-d`옵션이 지정도미ㅕㄴ 브라우저와 똑같이 헤더로 `Content-Type:application/x-www-form-urlencoded`를 설정한다. 이때 바디는 키와 값이 `=`로 연결되고, 각 항목이 `&`로 연결된 문자열이 된다.
```
title=The Art of Community&author=Jono Bacon
```
실제로는 이 커맨드가 생성하는 바디는 브라우저의 웹 폼에서 전송하는 것과는 약간 차이가 있다. curl에서는 실제 보내는 데이터에 구분문자인 `&`와 `=`가 들어있는 경우 그대로 연결해버린다. 브라우저는 RFC 1866에서 책정한 변환 포맷에 따라 변환을 실시한다. 이 포맷에서는 알파벳, 수치, 별표, 하이픈, 마침표, 언더스코어의 여섯 종류 문자 외에는 변환이 필요하다.
```
title=Head+First+PHP+%26+MySQL&author=Lynn+Beighley%2C+Michael+Morrison
```
curl에는 이와 가까운 기능을 하는 `data-urlencode`가 있다. 이때 RFC 3986에서 정의된 방법으로 변환된다.
웸 폼의 GET의 경우 바디가 아니라 쿼리로서 URL에 부여된다고 RFC 1866에 정의되어 있다.

# 2 폼을 이용한 파일 전송
HTML의 폼에서는 옵션으로 멀티파트 폼 형식이라는 인코딩 타입을 선택할 수 있다. 옵션을 사용해서 파일을 보낼 수 있다. RFC 1867에 정의돼 있다. 
```
<form action="POST" enctype="multipart/form-data">
</form>
```
보통 HTTP 응답은 한 번에 한 파일씩 반환하므로, 빈 줄을 찾아 그곳부터 `Content-Length`로 지정된 바이트 수만큼 읽기만 하면 데이터를 통째로 가져올 수 있다. 하지만 멀티파트를 이용하는 경우는 한 번의 요청으로 복수의 파일을 전송할 수 있으므로 받는 쪽에서 파일을 나눠야 한다.
다음은 크롬 브라우저의 멀티파트 폼 형태로 출력했을 때의 헤더이다. 경계 문자열인 하나의 속성이 추가적으로 부여돼있다.
```
Content-Type: multipart/form-data; boundary=---WebKitFormBoundaryy0YfbccgoID172j7
```
바디는 다음과 같이 경계 문자열로 두 개의 블록으로 나뉜 것을 알 수 있다. 각각의 블록 내부도 HTTP와 같은 구성으로, 헤더+빈 줄+콘텐츠로 되어있다. 헤더에는 `Content-Disposition` 이라는 항목이 포함된다. Disposition은 기질, 성질이란 뜻으로, 대체로 `Content-Type`과 같은 것이다. 여기서는 항목의 이름을 붙이고 폼의 데이터라고 선언했다.
```
------WebKitFormBoundaryy0YfbccgoID172j7
Content-Disposition: form-data; name="title"

The Art of Community
------WebKitFormBoundaryy0YfbccgoID172j7
Content-Disposition: form-data; name="author"

Jono Bacon
------WebKitFormBoundaryy0YfbccgoID172j7--
```
여러 줄인 `X-www-form-urlencoded`와 다를 바 없지만 파일을 전송해보면 다르다.
```
<input name="attachment-file" type="file"
```
이 폼을 전송하면 다음과 같은 결과가 표시된다. `multipart/form-data`는 항목마다 추가 메타정보를 태그로 가질 수 있다. 파일을 전송할 때 이름, 파일명, 파일 종류, 그리고 파일 내용이라는 세 가지 정보가 전송되는 것을 알 수 있다. `x-www-form-urlencoded`는 파일 전송에 필요한 정보를 모두 보낼 수 없어, 파일 이름만 전송해버린다.
```
------WebKitFormBoundaryy0YfbccgoID172j7
Content-Disposition: form-data; name="attachment-file"; filename="test.txt"
Content=type: text/plain

hello world

------WebKitFormBoundaryy0YfbccgoID172j7--
```
`-F`를 사용하면 curl 커맨드는 `enctype="multipart/form-data`가 설정된 폼과 같은 형식으로 송신한다. `-d`와 `-F`를 섞어 쓸 수는 없다. 
```
#파일 내용을 test.txt에서 취득. 파일명은 로컬 파일명과 같다. 형식도 자동 설정.
$ curl --http1.0 -F attachment-file@test.txt http://localhost:8080

#파일 내용을 test.txt에서 취득. 형식은 수동 설정.
$ curl --http1.0 -F "attachment-file@test.txt;type=text/html" http://localhost:8080

#파일 내용을 test.txt에서 취득. 파일명은 지정한 파일명을 이용.
$ curl --http1.0 -F "attachment-file@test.txt;filename=sample.txt" http://localhost:8080
```
# 3 폼을 이용한 리디렉트
스테이터스 코드를 사용한 리디렉트의 경우 몇 가지 제한이 있다.
- URL에는 2000자 이내라는 기준이 있어 `GET`의 쿼리로 보낼 수 있는 데이터양에 한계가 있다.
- 데이터가 URL에 포함되므로, 전송하는 내용이 액세스 로그 등에 남을 우려가 있다.
이런 문제를 피하고자 종종 이용되는 방법이 HTML의 폼을 이용한 리디렉트이다. 서버로부터는 리디렉트할 곳으로 보내고 싶은 데이터가 `<input type="hidden">` 태그로 기술된 HTML이 되돌아 온다. 폼에서 보내는 곳이 리디렉트할 곳이다. 브라우저가 이 HTML 을 열면 로드 직후 발생하는 이벤트로 폼을 전송하므로 즉시 리디렉트해 이동하게 된다.
순간적으로 빈 페이지가 표시된다는 점과 전환 버튼이 표시되긴 하지만 자바스크립트가 비활성화 되어 있으면 자동으로 전환되지 않는다는 단점이 있다.

# 4 콘텐트 니고시에이션
서버와 클라이언트는 따로 개발되므로 양쪽이 기대하는 형식이나 설정이 항상 일치할 수는 없다. 통신 방법을 최적화하고자 하나의 요청 안에서 서버와 클라이언트가 서로 최고의 설정을 공유하는 시스템이 콘텐트 니고시에이션이다. 콘텐트 니고시에이션에는 헤더를 이용한다. 

| 요청 헤더           | 응답                           | 니고시에이션 대상 |
| --------------- | ---------------------------- | --------- |
| Accept          | Content-Type 헤더              | MIME 타입   |
| Accept-Language | Content-Language 헤더/ html 태그 | 표시 언어     |
| Accept-Charset  | Content-Type 헤더              | 문자의 문자셋   |
| Accept-Encoding | Content-Encoding 헤더          | 바디 압축     |
## 4.1 파일 종류 결정
```
Accept: text/html,application/xhtml,xml,application/xml;q=0.9,image/webp,*/*;q=0.8
```
구글 크롬의 요청 헤더에서 가져왔다. 이미지 항목에 집중해 설명한다. 우선 콤마로 항목을 나눈다.
- `image/webp`
- `*/*;q=0.8`
q는 품질 계수라는 것으로 0에서 1까지의 수치로 설정한다. 기본은 1.0이고 이때는 q가 생략된다. 이 수치는 우선순위를 나타낸다. 웹 서버가 Webp(구글이 권장하는 PNG보다 20%파일 크기가 작아지는 이미지 형식)을 지원하면 Webp를 , 그렇지 않으면 PNG등 다른 포맷(우선순위0.8)을 서버에 보낼 것을 요구하고 있다.
서버는 요청에서 요구한 형식 중에서 파일을 반환한다. 우선순위를 해석해 위에서부터 차례로 지원하는 포맷을 찾고, 일치하면 그 포맷으로 반환한다. 만약 서로 일치하는 형식이 없으면 서버가 `406 Not Acceptable` 오류를 반환한다.
## 4.2 표시 언어 결정
클라이언트가 지원하는 언어 종류를 나타낸다. 표시 언어도 기본은 같다.
```
Accept-Language: en-US,en;=0.8,ko;q=0.6
```
다시 말해, `en-US`, `en`, `ko` 라는 우선 순위로 요청ㅇ르 보낸다. 언어 정보를 담는 상자로서 `Content-Language` 헤더가 있지만, 대부분 이 헤더는 사용하지 않는 것 같다. 다음과 같이 HTML 태그 안에서 반환하는 페이지를 많이 볼 수 있다.
```html
<html lang="ko">
```

## 4.3 문자셋 결정
어느 모던 브라우저도 `Accept-Charset`을 송신하지 않는다. 아마도 브라우저가 모든 문자셋 인코더를 내장하고 있어, 미리 니고시에이션할 필요가 없어졌기 때문으로 여겨진다. 문자셋은 MIME 타입과 세트로 `Content-Type` 헤더에 실려 통지된다.
```
Content-Type: text/html; charset=UTF-8
```
HTML의 경우 문서 안에 쓸 수도 있다. 이 방식은  RFC 1866의 HTML/2.0으로 이미 이용할 수 있다. HTML을 로컬에 저장했다가 다시 표시하는 경우도 많으므로, 이 방식도 함께 많이 사용한다.
```
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
```
HTML의 `<meta http-equiv>` 태그는 HTTP 헤더와 똑같은 지시를 내려 문서 내부에 삽입해서 반환하는 상자이다. HTML5에서는 다음과 같이 표기할 수도 있다.
```
<meta charset="UTF-8">
```

## 4.4 압축을 이용한 통신 속도 향상
콘텐츠 압축은 전송 속도 향상을 위한 것이다. 콘텐츠 내용에 따라 다르지만, 현재 일반적으로 사용되는 압축 알고리즘을 적용하면 텍스트 파일은 1/10 크기로 압축된다. 통신에 걸리는 시간보다 압축과 해제가 짧은 시간에 이루어지므로, 압축을 함으로써 웹페이지를 표시할 때 걸리는 전체적인 처리 시간을 줄일 수 있다.
콘텐츠 압축 니고시에이션은 모두 HTTP의 헤더 안에서 완료한다. 우선 클라이언트가 수용 가능한 압축 방식을 헤더에서 지정한다.
```
Accept-Encoding: deflate, gzip
```
curl 커맨드에서 `--compressed` 옵션을 지정하면 `-H` 옵션으로 위 헤더를 기술한 것과 같다.
서버는 전송받은 목록 중 지원하는 방식이 있으면, 응답할 때 그 방식으로 압축하거나 미리 압축된 콘텐츠를 반환한다. 서버가 gzip을 지원하면, 조금 전에 받은 요청에 대한 응답으로 다음과 같은 헤더가 부여된다.
```
Content-Encoding: gzip
```
서버가 지원하지 않으면 양쪽에서 다 지원하는 다른 인코딩으로 대체된다. 이처럼 HTTP 헤더라는 틀을 이용해 한 번의 왕복의 짧은 요청과 응답 속에서 하위 호환성을 유지하면서도 서로 최적의 통신을 할 수 있게 시스템이 정비됐다.
흔히 압축 알고리즘(슬라이드 사전)은 파일의 일부와 'x 바이트 앞의 내용을 여기에 x바이트 만큼 전개한다'라는 지시를 함께 저장한다. '경기도안양시안양동안안양아트센터'라는 문자열은 다음처럼 된다.
```
경기도안양시[3글자 앞에서 2글자 복사]동[3글자 앞에서 2글자 복사]아트센터
```
# 5 쿠키
쿠키란 웹사이트의 정보를 브라우저 쪽에서 저장하는 작은 파일이다. 일반적으로 DB는 클라이언트가 DBMS에 SQL을 발행해서 데이터를 저장하지만, 쿠키의 경우는 거꾸로 서버가 클라이언트에 '이 파일을 보관해줘'라고 쿠키 저장을 지시한다.
쿠키도 HTTP 헤더를 기반으로 구현됐다. 서버에서는 다음과 같이 응답 헤더를 보낸다. 이 서버는 최종 액세스 날짜와 시간을 클라이언트에 저장하려고 한다.
```
Set-Cookie: LAST_ACCESS_DATE=Jul/31/2016
Set-Cookie: LAST_ACCESS_TIME=12:0
```
클라이언트는 이 값을 저장해둔다. 다음번에 방문할 때는 다음과 같은 형식으로 보낸다. 서버는 이 값을 읽고, 클라이언트가 마지막으로 엑세스한 시간을 알 수 있다.
```
Cookie: LAST_ACCESS_DATE=Jul/31/2016
Cookie: LAST_ACCESS_TIME=12:10
```
해당 쿠키 값으로 표시 내용을 바꾸는 코드를 작성할 수 있다.
서버 프로그램이 볼 땐 마치 데이터베이스처럼 외부에 데이터를 저장해두고, 클라이언트가 액세스할 때마다 데이터를 로드하는 것과 같다.

#CS #Network 