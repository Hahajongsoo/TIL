# 산술 연산자

| 구분               | 연산자                                      | 피연산자 타입                                                                                        |
| ------------------ | ------------------------------------------- | ---------------------------------------------------------------------------------------------------- |
| 사칙 연산과 나머지 | `+`<br>`-`<br>`*`<br>`/`<br>`%`             | 정수, 실수, 복소수, 문자열<br>정수, 실수, 복소수<br>정수, 실수, 복소수<br>정수, 실수, 복소수<br>정수 |
| 비트연산           | `&` <br> \| <br> `^`(XOR)<br> `&^`(비트 클리어) | 정수<br>정수<br>정수<br>정수                                                                         |
| 시프트 연산        | `<<`<br>`>>`                                | 정수<<양의정수<br>정수>>양의정수                                                                                                     |

## 연산의 결과 타입
- Go 언어에서 모든 연산자의 각 항의 타입은 항상 같아야 한다.(시프트 연산은 예외)
	- 타입이 다른 경우 타입 변환을 한 후 연산을 수행해야한다.
- 연산의 결과 타입도 인수 타입과 같다. 
	- 나머지 연산은 정수 타입만 가능하다.

```go
func main() {
    var x int32 = 7
    var y int32 = 3

    var s float32 = 3.14
    var t float32 = 5

    fmt.Println("x + y = ", x+y)
    fmt.Println("x - y = ", x-y)
    fmt.Println("x * y = ", x*y)
    fmt.Println("x / y = ", x/y)
    fmt.Println("x % y = ", x%y)

    fmt.Println("s * t = ", s*t)
    fmt.Println("s / t = ", s/t)
}
```

```
x + y =  10
x - y =  4
x * y =  21
x / y =  2
x % y =  1
s * t =  15.700001
s / t =  0.628
```

- 정수에서 나눗셈 결과 나누어 떨어지지 않는 경우 소수점 이하는 버리는 것을 확인 가능

## 비트 연산자
- 정수만 피연산자가 될 수 있다.
- 각 비트 단위로 연산을 수행한다. 따라서 정수를 2진수로 표현한 뒤 계산한다.
- `^`는 단독으로 사용하는 경우 비트 반전을 한다.

```go
package main

import "fmt"

func main() {
	var x1 int8 = 34
	var x2 int16 = 34
	var x3 uint8 = 34
	var x4 uint16 = 34

	fmt.Printf("^%d = %5d,\t %08b\n", x1, ^x1, uint8(^x1))
	fmt.Printf("^%d = %5d,\t %016b\n", x2, ^x2, uint16(^x2))
	fmt.Printf("^%d = %5d,\t %08b\n", x3, ^x3, ^x3)
	fmt.Printf("^%d = %5d,\t %016b\n", x4, ^x4, ^x4)
}
```

```
^34 =   -35,     11011101
^34 =   -35,     1111111111011101
^34 =   221,     11011101
^34 = 65501,     1111111111011101
```
- 부호가 있는 경우 비트 반전한 것을 2진수로 표현하면 바뀐 비트를 출력하는 대신 부호를 출력하게 된다. 따라서 타입 변환을 해준 것

### `&^` 비트 클리어 연산자
- 먼저 `^` 연산을 수행하고 `&` 연산을 수행한다. 결과적으로 특정 비트를 0으로 만들고자 할 때 비트 클리어 연산자를 사용하는 것이다. 

## 시프트 연산자
- 비트를 왼쪽 또는 오른쪽으로 밀거나 당기는 연산자이다. 

### 왼쪽 시프트(`<<`)
- 오른쪽 피연산자 값 만큼 전체 비트를 왼쪽으로 밀어낸다. 
- 빈 자리는 0이 채워지고 자리수를 벗어난 비트는 버려진다. 
- 옮길 비트 수를 나타내는 오른쪽 피연산자는 반드시 양의 정수여야한다.

```go
package main

import "fmt"

func main() {
	var x int8 = 4
	var y int8 = 64

	fmt.Printf("x:%08b x<<2: %08b x<<2: %d\n", x, x<<2, x<<2)
	fmt.Printf("y:%08b y<<2: %08b y<<2: %d\n", y, y<<2, y<<2)
}
```

```
x:00000100 x<<2: 00010000 x<<2: 16
y:01000000 y<<2: 00000000 y<<2: 0
```

- 연산 결과는 2의 승수배 (여기서는 2^2=4) 만큼 곱한 결과가 나올 것을 예측할 수 있다.
- 하지만 64의 경우 비트 자리수를 넘기게 되어 0이 됐다. 

### 오른쪽 시프트(>>)
- 비트를 오른쪽으로 밀어낸다. 마찬가지로 오른쪽 피연산자는 양수여야한다.
- 왼쪽에 추가되는 비트는 최상위 비트값과 같은 비트값이 추가된다.
	- 부호가 있는 정수의 경우 왼쪽 비트에 부호와 같은 값으로 채워진다. 음수면 1 양수면 0으로 채워진다.
	- 부호가 없는 정수면 0으로 채워진다.

```go
package main

import "fmt"

func main() {
	var x int8 = 16
	var y int8 = -128
	var z int8 = -1
	var w uint8 = 128

	fmt.Printf("x:%08b x>>2: %08b x>>2: %d\n", x, x>>2, x>>2)
	fmt.Printf("y:%08b y>>2: %08b y>>2: %d\n", uint8(y), uint8(y>>2), y>>2)
	fmt.Printf("z:%08b z>>2: %08b z>>2: %d\n", uint8(z), uint8(z>>2), z>>2)
	fmt.Printf("w:%08b w>>2: %08b w>>2: %d\n", uint8(w), uint8(w>>2), w>>2)
}
```

```
x:00010000 x>>2: 00000100 x>>2: 4
y:10000000 y>>2: 11100000 y>>2: -32
z:11111111 z>>2: 11111111 z>>2: -1
w:10000000 w>>2: 00100000 w>>2: 32
```

- 왼쪽 시프트와 반대로 2의 승수 만큼 나누는 결과로 예상할 수 있다.
	- 물론 모든 결과가 그런 것은 아니다.
- 비트를 옮기더라도 해당 부호를 유지하는 것을 확인할 수 있다.

# 비교 연산자
- 양변을 비교해서 조건에 만족하면 `true`, 만족하지 못하면 `false`를 반환하는 연산자이다.
- `==, !=, <, >, <=, >=` 연산자를 제공한다.
- 비교 연산자를 사용할 때 몇가지 주의할 점이 있다.
	- 정수 오버플로
	- 정수 언더플로
	- 실수끼리 비교

## 정수 오버플로
- 정수가 정수 타입의 범위를 벗어난 경우 값이 비정상으로 변화하는 현상을 오버플로라고 한다.
	- `x`가 정수 타입일 때, `x < x + 1` 을 항상 만족하지 못할 수 있다.

```go
package main

import "fmt"

func main() {
	var x int8 = 127

	fmt.Printf("%d < %d + 1: %v\n", x, x, x < x+1)
	fmt.Printf("x\t= %4d, %08b\n", x, x)
	fmt.Printf("x + 1\t= %4d, %08b\n", x+1, x+1)
	fmt.Printf("x + 2\t= %4d, %08b\n", x+2, x+2)
	fmt.Printf("x + 3\t= %4d, %08b\n", x+3, x+3)

	var y int8 = -128

	fmt.Printf("%d > %d - 1: %v\n", y, y, y > y-1)
	fmt.Printf("y\t= %4d, %08b\n", y, y)
	fmt.Printf("y - 1\t= %4d, %08b\n", y-1, y-1)
	fmt.Printf("y - 2\t= %4d, %08b\n", y-2, y-2)
	fmt.Printf("y - 3\t= %4d, %08b\n", y-3, y-3)
}
```

```
127 < 127 + 1: false
x       =  127, 01111111
x + 1   = -128, -10000000
x + 2   = -127, -1111111
x + 3   = -126, -1111110
-128 > -128 - 1: false
y       = -128, -10000000
y - 1   =  127, 01111111
y - 2   =  126, 01111110
y - 3   =  125, 01111101
```

- 부호가 있는 경우 최상위 비트는 부호를 나타내는 역할을 한다.
	- 1인 경우 `-` , 0인 경우 `+`
	- 따라서 127(`0111 1111`) 에 1을 더하면 128이 되는 것이 아니라 `1000 0000`이 되어 -128을 나타내게 된다.
	- 또한 -128 에서 1을 빼는 경우도 마찬가지다. `1000 0000` 에서 1을 빼면 `0111 1111`이 되기 때문에 -129가 되는 것이 아니라 127이 된다. 이 경우가 언더 플로이다.

## float 비교 연산
- 컴퓨터에서 실수값을 표현할 때 지수부와 소수부로 나눠서 표현하고 2진수 기준으로 되어있다. 따라서 10진수 실수를 정확히 표현하기 어려운 문제가 있다.
- 2의 마이너스 승수 들을 차례대로 더하는 식으로 되어있기 때문에 정확도 면에서 차이가 날 수 밖에 없다. 
- 따라서 float에서 `==` 으로 연산을 수행하는 경우 10진수 체계에서는 동일한 결과이지만 컴퓨터에서 연산 결과는 다를 수 있다. 

### 오차 없애기
- 실수 표현은 지수부와 소수부로 나눠지기 때문에 해당 지수부 표현에서 가장 작은 차이는 가장 오른쪽 비트값 하나만큼이다.
- 따라서 해당 비트만큼만 차이가 나는지 확인해보면 된다.
- 이때 `math` 패키지의 `Nextafter()` 함수를 사용하면 된다.

```
func Nextafter(x, y float64) (r float64)
```

- `float64` 타입 두 개를 받아서 `float64` 타입 하나를 반환한다.
	- `x`에서 `y`로 1비트 만큼만 조정한 값을 반환한다.
	- `x`가 `y`보다 크면 1비트 감소시키고 반대면 1비트 증가시킨다.

```go
package main

import (
	"fmt"
	"math"
)

func equal(a, b float64) bool {
	return math.Nextafter(a, b) == b
}

func main() {
	var a float64 = 0.1
	var b float64 = 0.2
	var c float64 = 0.3

	fmt.Printf("%0.18f + %0.18f = %0.18f\n", a, b, a+b)
	fmt.Printf("%0.18f == %0.18f : %v\n", a+b, c, equal(a+b, c))

	a = 0.0000000000004
	b = 0.0000000000002
	c = 0.0000000000007

	fmt.Printf("%g + %g = %g\n", a, b, a+b)
	fmt.Printf("%g == %g : %v\n", a+b, c, equal(a+b, c))
}
```

```
0.100000000000000006 + 0.200000000000000011 = 0.300000000000000044
0.300000000000000044 == 0.299999999999999989 : true
4e-13 + 2e-13 = 6.000000000000001e-13
6.000000000000001e-13 == 7e-13 : false
```

- 오차가 매우 작을 뿐 정확한 계산은 아니다. 오차를 무시한 방법이었을 뿐이다.
- 정확도가 중요한 프로그램이라면 `math/big` 패키지에서 제공하는 `Float` 객체를 사용해야한다.
	- 정밀도를 직접 조정할 수 있기 때문에 정밀도를 높여서 더 정확한 수치 계산을 할 수 있다.

```go
package main

import (
	"fmt"
	"math/big"
)

func main() {
	a, _ := new(big.Float).SetString("0.1")
	b, _ := new(big.Float).SetString("0.2")
	c, _ := new(big.Float).SetString("0.3")

	d := new(big.Float).Add(a, b)
	fmt.Println(a, b, c, d)
	fmt.Println(c.Cmp(d))
}
```

```
0.1 0.2 0.3 0.3
0
```

- Cmp 메소드의 독스트링은 다음과 같다.
```
Cmp compares x and y and returns:

  -1 if x <  y
   0 if x == y (incl. -0 == 0, -Inf == -Inf, and +Inf == +Inf)
  +1 if x >  y
```

# 논리 연산자
- 논리 연산자는 불리언 피연산자를 대상으로 연산해 결과로 `true`나 `false`를 반환한다.
- `&&, ||, !` 연산자를 제공한다.

# 대입 연산자
- `=` 대입 연산자는 우변값을 좌변(메모리 공간)에 복사한다. 좌변은 반드시 저장할 공간이 있는 변수가 와야한다.

```
var a int
var b int
a = b = 10
```

- `b = 10`이 결과를 반환하지 않기 때문에, 이 경우는 불가능하다. 

## 복수 대입 연산자
- 여러 값을 한 번에 대입할 수 있다.
```
a, b = 1, 3
```

## 복합 대입 연산자
- 대입 연산자 앞에 다른 산술 연산자를 붙여서 변수의 값과 연산의 결과를 다시 변수에 대입하게 할 수 있다.
```
var a = 10
a += 2
```
- 모든 산술 연산자가 가능하다. 비트 연산자, 시프트 연산자도 전부 가능하다.

## 증감 연산자
- 변수값을 1 증감 하는 것은 자주 사용되어 증감문을 제공한다.
	- `++`: 정수 타입 변수 뒤에 붙여쓰며, 해당 변수값을 1 증가시킨다.
	- `--`: 정수 타입 변수 뒤에 붙여쓰며, 해당 변수값을 1 감소시킨다.

## 그외 연산자

| 연산자 | 설명                                                  | 참조     |
| ------ | ----------------------------------------------------- | -------- |
| `[]`   | 배열의 요소에 접근할 때 사용                          | 12장     |
| `.`    | 구조체나 패키지 요소에 접근할 때 사용                 | 13, 16장 |
| `&`    | 변수의 메모리 주소값을 반환한다.                      | 14장     |
| `*`    | 포인터 변수가 가리키는 메모리 주소에 접근한다.        | 14장     |
| `...`  | 슬라이스 요소들에 접근하거나 가변 인수를 만들 때 사용 | 18, 21장 |
| `:`    | 배열의 일부분을 집어올 때 사용한다.                   | 18장     |
| `<-`   | 채널에서 값을 빼거나 넣을 때 사용한다.                | 25장     | 

# 연산자 우선순위

| 우선순위 | 연산자             |
| -------- | ------------------ |
| 5        | `* / % << >> & &^` |
| 4        | `+ -` \| `^`       |
| 3        | `== != < <= > >=`  |
| 2        | `&&`               |
| 1        | \|\|                   |
