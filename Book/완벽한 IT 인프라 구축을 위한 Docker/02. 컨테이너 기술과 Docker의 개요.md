# 컨테이너
- 호스트 OS상에 논리적인 구획(컨테이너)을 만들고, 애플리케이션을 작동시키기 위해 필요한 라이브러리나 애플리케이션등을 하나로 모아, 마치 별도의 서버인 것 처럼 사용할 수 있게 만든 것
- 호스트 OS의 리소스를 논리적으로 분리시키고 여러개의 컨테이너가 공유하여 사용
- 물리 서버상에 설치한 호스트 OS의 경우 하나의 OS 상에서 동작하는 여러 애플리케이션은 똑같은 시스템 리소스를 사용한다. 이때 애플리케이션들은 데이터를 저장하는 디렉토리를 공유하고, 서버에 설정된 동일한 IP로 통신한다. 
- 컨테이너를 사용하면 OS, 디렉토리, IP 주소등과 같은 시스템 자원을 마치 각 애플리케이션이 점유하고 있는 것 처럼 보이게 할 수 있다. 
- 오버헤드가 적기 때문에 가볍고 고속으로 작동한다.

컨테이너 기술과 서버 가상화 기술은 매우 비슷하지만 목적이 다르다. ==컨테이너 기술은 애플리케이션의 실행 환경을 모음으로써 이식성을 높이고 확장성이 좋은 환경에서 작동하는 것을 지향==하고 있는 반면, ==가상화 기술의 대부분은 서로 다른 환경을 어떻게 효율적으로 에뮬레이트할지라는 점을 지향==하고 있다.

## 컨테이너 역사
FreeBSD라는 오픈소스 Unix의 FreeBSD Jail 이나 상용 Unix인 Solaris의 Solaris Containers 등이 있다. 
### FreeBSD
오픈 소스 Unix인 FreeBSD의 기술이다. 2000년에 릴리즈된 FreeBSD 4.0에서 도입되었다. FreeBSD 시스템을 Jail이라고 부르는 독립된 작은 구획에 나눠 시스템을 분할할 수 있다.
주요 특징은 다음과 같다. 
1. 프로세스의 구획화
	- 똑같은 Jail에서 작동하는 프로세스만 액세스할 수 있도록 프로세스를 분리한다. Jail에서 실행중인 프로세스는 Jail 밖의 프로세스에 대해 영향을 줄 수 없다.
2. 네트워크의 구획화
	- Jail은 하나하나에 IP주소가 할당되어 있다. 여러 개의 주소를 할당할 수도 있다.
	- Jail의 외부에는 네트워크를 경유해야 액세스 할 수 있다. 
3. 파일 시스템의 구획화
	- Jail에서 사용하는 파일 시스템을 구획화함으로써 조작할 수 있는 명령이나 파일등을 제한한다.
Jail의 특징은 관리자 권한의 범위가 Jail 안으로 제한되기 때문에 시스템 관리자는 종료와 같은 시스템 전체를 조작하는 권한을 부여하지 않고도 일반 사용자에게 관리자 권한을 부여할 수 있다는 점이다.

### Solaris Containers
Solaris에서 사용하는 컨테이너 기술이다. 2005년에 릴리즈된 Solaris 10에서 추가된 기능이다. 다음의 주요 두 가지 기능이 있다.
1. Solaris 존 기능
	- 하나의 OS 공간을 가상적으로 분할하여 여러 OS가 작동하고 있는 것 처럼 보여주는 소프트웨어 파티셔닝 기능
	- Solaris 환경을 독립적인 여러 개의 존으로 구획화한다.
	- 베이스가 되는 OS의 영역을 global zone, 구획화 된 가상 존을 non-global zone 이라고 한다. 이 비 글로벌 존에서 애플리케이션의 서버 기능을 작동시킨다. 
	- 비 글로벌 존끼리는 격리되어 있어서 한 비 글로벌 존에서 작동하고 있는 프로세스에는 다른 비 글로벌 존에서 액세스 할 수 없다.
2. Solaris 리소스 매니저 기능
	- 비 글로벌 존에서 하드웨어 리소스를 배분하는 리소스 관리 기능
	- 중요도가 높은 시스템에 우선적으로 리소스를 할당하여 시스템 요건에 따라 하드웨어를 적절히 할당하게 할 수 있다. 

#### Linux Containers
- Linux 상에서 사용하는 컨테이너 환경이다. LXC는 Linux 커널의 컨테이너 기능을 이용하기 위한 툴이나 API를 제공한다. 
- 컨테이너는 namespace와 cgroups라는 리소스 관리 장치를 사용하여 분리된 환경을 만든다. 
- 데이터 영역에 대해서는 특정 디렉토리를 루트 디렉토리로 변경하는 chroot를 이용하여 분리 환경을 만든다. 

# Docker 개요
도커는 애플리케이션의 실행에 필요한 환경을 하나의 이미지로 모아두고, 그 이미지를 사용하여 다양한 환경에서 애플리케이션 실행 환경을 구축 및 운용하기 위한 오픈소스 플랫폼이다. 도커는 내부에서 컨테이너 기술을 사용하고 있는 것이 특징이다. 
## 프로그래머에게 Docker란?
- 도커에서는 인프라 환경을 컨테이너로 관리한다. 애플리케이션 실행에 필요한 모든 파일 및 디렉토리들을 컨테이너로서 모아버린다. 
- 컨테이너의 바탕이 되는 도커 이미지를 Docker Hub와 같은 리포지토리에서 공유한다.
- 프로그래머는 도커를 사용하여 개발한 애플리케이션의 실행에 필요한 모든 것이 포함되어 있는 도커 이미지를 작성한다. 이 이미지는 컨테이너의 바탕이 된다. 
- 이미지는 도커가 설치되어 있는 환경이면 기본적으로 어디서든 작동되므로 개발/테스트 환경에서는 동작하지만 제품 환경에서는 동작하지 않는다 라는 리스크를 줄일 수 있다. 

### 애플리케이션에서 이식성(portability)
- 한 번 만들면 어디서든지 동작하는 소프트웨어의 특성을 이식성이라고 한다. 
- 도커는 이식성이 높기 때문에 클라우드 시스템과의 친화력도 높은 것이 특징이다. 
- 개발한 업무 애플리케이션을 온프레미스 환경에 대한 이전 뿐만 아니라 온프레미스 환경과 클라우드 환경사이에서 이전도 시스템 요건이나 예산에 따라 손쉽게 실행 환경을 선택할 수 있다. 
- 시스템 개발에서는 애플리케이션의 실행 환경에 제약이 많으면 특정 업체에 의존하는 시스템이 되어버리거나 개발 속도가 떨어지는 경우가 있다. 인프라에 얽매여 필요 이상으로 복잡한 구성으로 시스템을 운용할 수 밖에 없는 상황에 빠지거나 비즈니스 속도를 따라갈 수 없는 업무 시스템이 되어버리는 경우도 많다.

# Docker의 기능
## Docker 이미지를 만드는 기능(Build)
- Docker는 애플리케이션의 실행에 필요한 프로그램 본체, 라이브러리, 미들웨어, OS나 네트워크 설정 등을 하나로 모아서 Docker 이미지를 만든다.
- Docker에서는 하나의 이미지에는 하나의 애플리케이션만 넣어두고 여러 개의 컨테이너를 조합하여 서비스를 구축하는 방법을 권장
- Docker 이미지는 애플리케이션의 실행에 필요한 파일들이 저장된 디렉토리이다. Docker 명령을 사용하면 이미지를 tar 파일로 출력할 수 있다.
- Docker 이미지는 Docker의 명령으로 수동으로 만들 수도 있고 Dockerfile이라는 설정파일을 이용하여 자동으로 만들 수도 있다. 하지만 CI/CD 관점에서 코드에 의한 인프라 구성 관리를 생각하면 Dockerfile을 사용하여 관리하는 것이 바람직하다.
- Docker 이미지는 layer를 이용하여 겹쳐서 사용할 수도 있다. Docker에서는 구성에 변경이 있었던 부분을 차분(이미지 레이어)으로 관리한다. 
## Docker 이미지를 공유하는 기능(Ship)
- Docker 이미지는 Docker 레지스트리에서 공유가능, Docker의 공식 레지스트리는 Docker Hub이다.
- 공식 이미지 외에도 개인이 작성한 이미지를 Docker Hub에서 자유롭게 공개하여 공유할 수 있다. 
- docker 명령을 사용하여 Docker Hub에 로그인하여 레지스트리에 있는 이미지를 검색, 업로드, 다운로드할 수 있다. 
- GitHub이나 Bitbucket등과 연계하여 automated build를 할 수도 있다.

### Docker 이미지의 변조 방지 및 취약성 검사 기능
- Docker Container Trust는 Docker 이미지의 제공자를 검증할 수 있는 기능이다. 
- 이미지 제공자는 Docker 레지스트리에 이미지를 송신하기 전에 로컬 환경에서 비밀키를 사용하여 이미지에 서명한다. 이후 이미지를 이용할 때는 이미지 제공자의 공개키를 사용하여 사용하려는 이미지를 검증한다. 이미지가 변조된 경우는 이미지를 무효로 만든다.
- Docker Security Scanning은 이미지를 검사하여 이미 알려진 보안상의 취약성이 없다는 것을 확인하여 이미지의 안전성을 확인할 수 있는 기능이다.
- 비밀 정보를 이미지에 포함 시키는 것은 보안 관점에서 피해야한다.

## Docker 컨테이너를 작동시키는 기능(Run)
- Docker는 Linux 상에서 컨테이너 단위로 서버 기능을 작동시킨다. 
- 컨테이너의 바탕이 되는 것이 Docker 이미지 이고 이미지가 있고 Docker가 설치된 환경이라면 어디서든지 컨테이너를 실행시킬 수 있다. 
- 도커 이미지를 가지고 여러 개의 컨테이너를 실행할 수도 있다. 컨테이너의 실행, 정지, 삭제는 docker 명령을 사용한다. 
- 다른 가상화 기술로 서버 기능을 실행하렬면 OS의 실행부터 시작하기 때문에 시간이 걸리지만 도커의 경우 이미 동작하는 OS 상에서 프로세스를 실행시키는 것과 거의 똑같은 속도로 실행시킬 수 있다. 
- Docker는 하나의 Linux 커널을 여러 개의 컨테이너에서 공유하고 있다. 컨테이너 안에서 작동하는 프로세스를 하나의 그룹으로 관리하고, 그룹마다 각각 파일 시스템이나 호스트명, 네트워크 등을 할당한다. 그룹이 다르면 프로세스나 파일에 대한 액세스를 할 수 없다. 이를 실행하기 위해 Linux 커널 기능 기술이 사용된다.
- 제품 환경에서 모든 도커 컨테이너를 한 대의 호스트 머신에서 작동 시키는 것은 드물며, 시스템의 트래픽 증감이나 가용성 요건, 신뢰도 요건을 고려하여 여러 대의 호스트 머신으로 된 분산 환경을 구축한다. 컨테이너 관리에 대해서는 오케스트레이션 툴을 사용한다. 

### Docker 컴포넌트
핵심 기능이 되는 Docker Engine을 중심으로 컴포넌트를 조합하여 애플리케이션 실행 환경을 구축한다.
#### Docker Engine(Docker의 핵심 기능)
Docker 이미지를 생성하고 컨테이너를 실행하기 위한 Docker의 핵심 기능이다. Docker명령의 실행이나 Dockerfile에 의한 이미지도 생성한다.

#### Docker Registry(이미지 공개 및 공유)
컨테이너의 바탕이 되는 Docker 이미지를 공개 및 공유하기 위한 레지스트리 기능이다. 

#### Docker Compose(컨테이너 일원 관리)
여러 개의 컨테이너 구성 정보를 코드로 정의하고, 명령을 실행함으로써 애플리케이션의 실행 환경을 구성하는 컨테이너들을 일원 관리하기 위한 툴이다.

#### Docker Machine(Docker 실행 환경 구축)
로컬 호스트 용인 VirtualBox를 비롯하여 AWS EC2나 Azure 와 같은 클라우드 환경에 Docker의 실행 환경을 명령으로 자동 생성하기 위한 툴이다.

#### Docker Swarm(클러스터 관리)
여러 Docker 호스트를 클러스터화 하기 위한 툴이다. Docker Swarm에서는 클러스터를 관리하거나 API를 제공하는 역할은 Manager가, Docker 컨테이너를 실행하는 역할은 Node가 담당한다. 

# Docker의 작동 구조
도커는 리눅스 커널의 기술이 베이스로 되어 있다. 하지만 리눅스 커널은 OS의 핵심 기능이며 하드웨어나 네트워크 같은 하위 레이어 기술과 밀접하게 관련이 있기 때문에 애플리케이션 개발자에게는 익숙하지 않은 기술 영역이기도 하다.

## 컨테이너를 구획화하는 장치(namespace)
- 도커는 컨테이너라는 독립된 환경을 만들고 그 컨테이너를 구획화하여 애플리케이션의 실행 환경을 만든다. 이 컨테이너를 구획하는 기술은 리눅스 커널의 namespace라는 기능을 사용한다. 
- namespace는 한 덩어리의 데이터에 이름을 붙여 분할함으로써 충돌 가능성을 줄이고, 쉽게 참조할 수 있게 하는 개념이다. 이름과 연결된 실체는 그 이름이 어떤 namespace에 속해 있는지에 따라 고유하게 정해진다. 따라서 namespace가 다르면 동일한 이름이라도 다른 실체로 처리된다. 
- 리눅스 커널의 namespace 기능은 리눅스의 오브젝트에 이름을 붙임으로써 다음과 같은 6개의 독립된 환경을 구축할 수 있다. 

### PID namespace
PID란 리눅스에서 각 프로세스에 할당 된 고유한 ID를 의미한다. PID namespace는 PID와 프로세스를 격리시킨다. namespace가 다른 프로세스끼리는 서로 액세스할 수 없다.
### Network namespace
네트워크 디바이스, IP 주소, 포트 번호, 라우팅 테이블, 필터링 테이블 등과 같은 네트워크 리소스를 격리된 namespace 마다 독립적으로 가질 수 있다. 
호스트 OS 상에서 사용중인 포트가 있더라도 컨테이너 안에서 동일한 번호의 포트를 사용할 수 있다. 
### UID namespace
UID, GID를 namespace별로 독립적으로 가질 수 있다. namespace안과 호스트 OS 상의 UID/GID가 서로 연결되어 이름공간 안과 밖에서 서로 다른 UID/GID를 가질수 있다. 예를 들어 namesapce 안에서는 UID/GID가 0인 root 사용자를 호스트 OS 상에서는 일반 사용자로서 취급할 수 있다. 이것은 namespace안의 관리자계정은 호스트 OS에 대해서는 관리 권한을 갖지 않는 다는 것을 의미하므로 보안성이 높은 환경으로 격리시킬 수 있다. 
### MOUNT namespace
마운트 조작을 통해 namespace 안에 격리된 파일 시스템 트리를 만든다. namespace 안에서 수행한 마운트는 호스트 OS나 다른 namespace에서는 액세스 할 수 없게 되어있다. 
### UTS namespace
UTS namespace는 namespace별로 호스트명이나 도메인명을 독자적으로 가질 수 있다.
### IPC namespace
프로세스 간의 통신(IPC) 오브젝트를 namespace별로 독립적으로 가질수 있다. IPC는 System V 프로세스 간의 통신 오브젝트라고 하는 공유 메모리나 세마포어/메시지 큐를 말한다. 세마포어란 프로세스가 요구하는 자원 관리에 이용되는 배타제어 장치이며, 메시지 큐란 여러 프로세스 간에서 비동기 통신을 할 때 사용되는 큐잉 장치이다. 

## 릴리즈 관리 장치(cgroups)
도커에서는 물리 머신 상의 장치 자원을 여러 컨테이너가 공유하여 작동한다. 이때 리눅스 커널의 기능은 control groups(cgroups) 기능을 사용하여 자원의 할당 등을 관리한다. 
리눅스에서는 프로그램을 프로세스로서 실행한다. 프로세스는 하나 이상의 스레드 모음으로 움직인다. cgroups는 프로세스와 스레드를 그룹화하여, 그 그룹 안에 존재하는 프로세스와 스레드에 대한 관리를 수행하기 위한 기능이다.
예를 들어 호스트 OS의 CPU나 메모리와 같은 자원에 대해 그룹별로 제한을 둘 수 있다. cgroups로 컨테이너 안의 프로세스에 대해 자원을 제한함으로써 어떤 컨테이너가 호스트 OS의 자원을 모두 사용하여 다른 컨테이너에 영향을 주는 것을 막을 수 있다. 
cgroups는 계층 구조를 사용하여 프로세스를 그룹화하여 관리할 수 있다. 사용자 애플리케이션과 서버와 같은 데몬 프로세스를 나눠, 각각의 그룹에 CPU 사용량을 할당할 수 있다. 부모자식 관계에서는 자식이 부모의 제한을 물려받는다. 

## 네트워크 구성(가상 브리지/가상 NIC)
리눅스는 Docker를 설치하면 서버의 물리 NIC가 docker0 이라는 가상 브리지 네트워크로 연결된다. 
```
[root@docker ~]# ip addr
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 

...

4: docker0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc noqueue state DOWN group default 
    link/ether 02:42:1f:21:cc:db brd ff:ff:ff:ff:ff:ff
    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0
       valid_lft forever preferred_lft forever
    inet6 fe80::42:1fff:fe21:ccdb/64 scope link 
       valid_lft forever preferred_lft forever

```
이 docker0은 Docker를 실행시킨 후에 디폴트로 만들어진다. Docker 컨테이너가 실행되면 컨테이너에 172.12.0.1/16이라는 서브넷 마스크를 가진 프라이빗 IP주소가 eth0으로 자동으로 할당된다. 이 가상 NIC는 OSI 참조 모델의 레이어 2인 가상 네트워크 인터페이스로, 페어인 NIC와 터널링 통신을 한다. 
docker 컨테이너와 외부 네트워크가 통신을 할 때는 가상 브리지 docker0와 호스트 OS의 물리 NIC에서 패킷을 전송하는 장치가 필요하다. Docker에서는 NAPT 기능을 사용하여 연결한다.
NAPT(Network Address Port Translation)란 하나의 IP 주소를 여러 컴퓨터가 공유하는 기술로, IP 주소와 포트 번호를 변환하는 기능이다. 프라이빗 IP 주소와 글로벌 IP 주소를 투과적으로 상호 변환하는 기술로, TCP/IP의 포트 번호까지 동적으로 변환하기 때문에 하나의 글로벌 IP 주소로 여러 대의 머신이 동시에 연결할 수 있다. Docker에서는 NAPT에 리눅스의 iptables를 사용하고 있다. 
Docker에서 이 기능을 사용할 때는 컨테이너 시작시에 컨테이너 안에서 사용하고 있는 포트를 가상 브리지인 docker0에 대해 개방한다. 예를 들어 컨테이너 시작시에 컨테이너 안의 웹서버가 사용하는 80번 포트를 호스트 OS의 8080번 포트로 전송하도록 설정한다. 그러면 외부 네트워크에서 호스트 OS의 8080번 포트에 액세스하면 컨테이너 안의 80번 포트로 연결된다. 

### NAT와 IP 마스커레이드의 차이
- NAT(Network Adress Translation)
	- 프라이빗 IP 주소가 할당된 클라이언트가 인터넷상에 있는 서버에 액세스 할때 NAT 라우터는 클라이언트의 프라이빗 IP 주소를 NAT가 갖고 있는 글로벌 IP주소로 변환하여 요청을 송신한다. 응답은 NAT 라우터가 송신처를 클라이언트의 프라잇 IP주소로 변환하여 송신한다. 
	- 이러한 주소변환에 의해 프라이빗 네트워크 상의 컴퓨터와 인터넷상의 서버 간의 통신이 성립된다. NAT의 경우 글로벌 IP 주소와 프라이빗 IP 주소를 1:1로 변환하기 때문에 동시에 여러 클라이언트가 액세스할 수가 없다. 
- NAPT(Network Adress Port Translation)
	- 프라이빗 IP주소와 함께 포트 번호도 같이 변환하는 기술이다. 프라이빗 IP 주소를 글로벌 IP 주소로 변환할 때 프라이빗 IP 주소별로 서로 다른 포트 번호로 변환한다. 
	- 예를 들어 클라이언트 A가 보낸 요청 포트번호 1500으로 하고, 클라이언트 B가 보내온 요청은 포트번호 1600으로 한다. 인터넷 상의 서버로부터 NAPT의 글로벌 IP주소의 서로 다른 포트번호 앞으로 응답이 되돌아온다. NAPT는 포트 번호를 바탕으로 프라이빗 IP 주소로 변환할 수 있다. 하나의 글로벌 IP 주소와 여러개의 프라이빗 IP 주소를 변환할 수 있다.

## Docker 이미지의 데이터 관리 장치
어떤 데이터를 복사할 필요가 생겼을 때는 새로운 빈 영역을 확보하고 거기에 복사를 한다. 복사한 데이터의 변경이 없다면 그 복사는 낭비가 되게 된다.
복사를 요구 받아도 바로 복사하지 않고 원래의 데이터를 그대로 참조시켜, 원본 또는 복사 어느 쪽에 수정이 가해진 시점에 비로소 새로운 빈 영역을 확보하고 데이터를 복사한다. 이러한 장치를 Copy On Write라고 부른다. 도커에서는 Copy On Write 방식으로 컨테이너의 이미지를 관리한다. 
도커의 이미지를 관리하는 스토리지 디바이스로는 다음과 같은 것이 있다. 
### AUFS
다른 파일 시스템의 파일이나 디렉토리를 투과적으로 겹쳐서 하나의 파일 트리를 구성할 수 있는 파일 시스템
### Btrfs
리눅스용 Copy On Write 파일 시스템이다. 롤백 기능이나 스냅샷 기능을 가지고 있다.
### Device Mapper
리눅스 커널 2.6에 들어간 리눅스의 블록 디바이스 드라이버와 그것을 지원하는 라이브러리들이다. 파일 시스템의 블록 I/O와 디바이스의 매핑 관계를 관리한다. thin-provisionig 기능과 스냅샷 기능을 가지고 있다. Red Hat OS 나 ubuntu 등에서 도커를 이용할 때 사용된다.
### OverlayFS
UnionFS 중 하나로 파일 시스템에 다른 파일 시스템을 투과적으로 머징하는 장치이다. 리눅스 커널 3.18에 도입되어 읽기 전용 파일 시스템에 읽어들이기가 가능한  파일 시스템을 겹침으로써, 읽기 전용 파일 시스템 상의 디렉토리나 파일에 대한 읽어들이기, 변경이 가능해진다. 도커에서는 overlay와 overlay2라는 2종류의 드라이버를 이용할 수 있다.
### ZFS
볼륨관리, 스냅샷, 체크섬 처리, 리플리케이션등을 지원한다. ZFS on Linux에 대한 충분한 경험이 없는 경우 사용하는 것은 권장되지 않는다 .























