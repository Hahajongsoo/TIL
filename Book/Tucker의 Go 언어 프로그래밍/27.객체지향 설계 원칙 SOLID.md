# 객체 지향 설계 5가지 원칙 SOLID
SOLID란 객체지향 설계 5가지 원칙의 영문명 앞글자를 따서 만든 용어이다.
- 단일 책임 원칙(Single Responsibility Principle, SRP)
- 개방-폐쇄 원칙(Open-Closed Principle, OCP)
- 리스코프 치환 원칙(Liskov Substitusiton Principle, LSP)
- 인터페이스 분리 원칙(Interface Segregation Principle, ISP)
- 의존 관계 역전 원칙(Dependency Inversion Principle, DIP)
반드시 지켜야하는 의무사항은 아니지만이 원칙들에 입각해서 설계하면 더 좋은 설계를 할 수 있다.

## 왜 설계를 잘해야 하는가?
설계는 프로그램 코드를 이루는 각 모듈 간 의존 관계를 정의하는 것이다. 현대  프로그래밍은 매우 복잡하여 수십에서 수백 명이 각자 맡은 바 코드를 구현한다. 그렇게 맡은 코드를 모듈 단위로 볼 수 있는데, 이러한 모듈이 모여 프로그램을 이루다 보니 설계를 잘하지 않으면 많은 문제가 발생할 수 있다.

### 나쁜 설계
- 경직성(rigidity)
	- 모듈 간의 결합도(coupling)가 너무 높아서 코드를 변경하기 매우 어려운 구조를 말한다. 때론 모듈 간 의존 관계가 거미줄 처럼 얽혀 있어서 어디부터 손대야 할지 모를 정도로 복잡한 구조를 갖기도 한다.
- 부서지기 쉬움(fagility)
	- 한 부분을 건드렸더니 다른 부분 까지 망가지는 경우이다. 언제 어떤 부분이 망가질지 모르기 때문에 프로그램을 변경하기가 매우 힘들다.
- 부동성(immobility)
	- 코드 일부분을 현재 어플리케이션에서 분리해서 다른 프로젝트에도 쓰고 싶지만 모듈 간 결합도가 너무 높아서 옮길 수 없는 경우이다. 그렇게 되면 코드 재사용률이 급격히 감소하므로 같거나 비슷한 기능을 매번 새로 구현해야한다.
언급한 3가지 경우를 ==**상호 결합도가 매우 높고 응집도가 낮다.**== 로 정리할 수 있다. '상호 결합도가 높다'는 것은 모듈이 서로 강하게 결합되어 있어 떼어낼 수 없다는 뜻이다. 상호 결합도가  높으면 경직성이 증가되고 그로 인해 한 모듈의 수정이 다른 모듈로 전파되어 예기치 못한 문제가 생기고 코드 재사용성을 낮추게 된다. '응집도가 낮다'는 얘기는 하나의 모듈이 스스로 자립하지 못한다는 뜻이다. 즉 하나의 모듈이 스스로 완성되지 못하고 다른 모듈에 의존적인 관계를 가지고 있는 경우이다.

### 좋은 설계
좋은 설계란 나쁜 설계 요소가 없는 설계를 말한다. 즉 ==**상호 결합도가 낮고 응집도가 높은 설계**== 이다. 상호 결합도가 낮기 때문에 모듈을 쉽게 떼어내서 다른 곳에 사용할 수 있고 모듈 간 독립성이 있기 때문에 한 부분을 변경하더라도 다른 모듈에 문제를 발생시키지 않는다. 그럼으로써 자연스럽게 모듈 완성도가 높아져서 응집도가 높아진다.

# 단일 책임 원칙
정의
- 모든 객체는 책임을 하나만 져야 한다.
- 객체나 모듈은 변경하려는 단 하나의 이유만을 가져야 한다.
이점
- 코드 재사용성을 높여준다.

```go
type FinanaceReport struct { // 회계 보고서
	report string
}

func (r *FinanceReport) SendReport(email string) { // 보고서 전송
	...
}
```

FinanaceReport는 회계 보고서 객체이다. 이메일로 전송하는 SendReport() 메서드를 가지고 있다. 문제 없어 보이는 코드지만 단일 책임 원칙을 위배했다. FinanceReport는 말 그대로 회계 보고서를 담당하는 객체이다. 즉 회계 보고서라는 책임을 지고 있다. 그런데 이 코드는 보고서를 전송하는 책임 까지 지고 있어서 책임이 두 개가 되므로 단일 책임 원칙 위배이다.

마케팅 보고서라는 객체도 만들었다고 가정해보자.
```go
type MarketingReport struct { // 마케팅 보고서
	report string
}

func (r *MarketingReport) SendReport(email string) { // 보고서 전송
	...
}
```
MarketingReport는 FinanceReport의 SendReport() 메서드를 사용할 수 없다. SendReport() 메서드는 FinanceReport에  포함된 기능이라서 다른 타입의 객체가 사용할 수 없기 때문이다. 구현이 비슷한 SendReport() 메서드를  MarketingReport 객체 안에 만든다고 치면 또 다른 종류의 보고서가 늘어나면 그 때마다 보고서를 전송하는 메서드를 작성해야한다. 이는 나중에 코드 수정이 필요할 때 더 심각해진다. 

단일 책임 원칙에 입각한 설계는 FinanceReport는 Report 인터페이스를 구현하고 ReportSender는 Report 인터페이스를 이용하는 관계를 형성하면 된다. 

```go
type Report interface {
	Report() string
}

type FinanceReport struct {
	report string
}

func (r *FinanceReport) Report() string {
	return r.report
}

type ReportSender struct {
	...
}

func (s *ReportSender) SendReport(report Report) {
	...
}
```

# 개방-폐쇄 원칙
정의
- 확장에는 열려있고 변경에는 닫혀있다.
이점
- 상호 결합도를 줄여 새 기능을 추가할 때 기존 구현을 변경하지 않아도 된다.
프로그램에 기능을 추가할 때 기존 코드의 변경을 최소화해야 한다 정도롤 이해하고 예시를 보자.
```go
func SendReport(r *Report, method SendType, receiver string) {
	switch method {
	case Email:
		// 이메일 전송
	case Fax:
		// 팩스 전송
	case PDF:
		// pdf 파일 생성
	case Printer:
		// 프린팅
	...
	}
}
```

전송 방식을 추가하려면 새로운 case를 만들어 구현을 추가해주면 된다. 즉 기존 SendReport() 함수 구현을 변경하게 되는 것이다. 따라서 개방-폐쇄 원칙에 위배된다. 만약 SendType에 따른 switch 문이 코드 여러 곳에 퍼져있다면 변경 범위가 늘어나게 되고 그만큼 버그를 발생시킬 위험성도 커진다.
```go
type ReportSender interface {
	Send(r *Report)
}

type EmailSender struct {
}

func (e *EmailSender) Send(r *Report) {
	// 이메일 전송
}

type FaxSender struct{
}

func (f *FaxSender) Send(r *Report) {
	// 팩스 전송
}
```
EmailSender 와 FaxSender는 모두 ReportSender라는 인터페이스를 구현한 객체이다. 여기에 새로운 전송 방식을 추가한다면 ReportSender를 구현한 새로운 객체를 추가해주면 된다. 새 기능을 추가했지만, 기존 구현을 변경하지 않아도 되는 것이다. 

# 리스코프 치환 원칙
정의
- q(x)를 타입 T의 객체 x에 대해 증명할 수 있는 속성이라 하자. S가 T의 하위 타입이라면 q(y)는 타입 S의 객체 y에 대해 증명할 수 있어야 한다.
이점
- 예상치 못한 작동을 예방할 수 있다.
```go
type T interface {
	Somthing()
}

type S struct {
}

func (s *S) Somthing() { // T 인터페이스 구현
}

type U struct {
}

func (u *U) Something() {
}

func q(t T) {
	...
}

var y = &S{} // S 타입 y
var u = &U{} // U 타입 u
q(y)
q(u)      // 둘 다 잘 동작해야 한다.
```
T 인터페이스가 있다. 이것을 S 객체와 U 객체가 구현하고 있다. 그리고 함수 q()는 인터페이스 T를 인수로 받는다. 이때 q() 함수는 S객체 인스턴스인 y와 U 객체 인스턴스인 u 모두에 대해서 잘 동작해야한다는 이야기이다. 
S와 U가 T의 하위 타입이기 때문에 당연히 상위 타입인 T를 인수로 받는 함수에 인스턴스를 넣어도 잘 동작해야 한다. 하지만 실제로는 그렇지 않은 경우가 발생한다. 어떤 함수를 만들면 이것은 그 함수를 호출하는 호출자와 함수 구현간의 계약 관계가 발생한다고 볼 수 있다.
```go
type Report interface {
	Report() string
}

func SendReport(r Report)
```

위 SendReport() 함수의 호출자는 이 함수를 호출하면 Report를 전송할 것으로 생각한다. 이것이 바로 호출자와 함수 간 계약이 성립한다고 말하는 것이다. 그런데 이 함수를 호출했는데 Report가 전송되지 않고 다른 일이 발생된다면 호출자가 예상하지 못한 버그가 발생하게 될 것이다.

```go
type Report interface {
	Report() string
}

type MarketingReport {
}

func (m *MarketingReport) Report() string {
	...
}

func SendReport(r Report) {
	if _, ok := r.(MarketingReport); ok {  // r이 마케팅 보고서일 경우 패닉
		panic("Can't send MarketingReport")
	}
	...
}

var report = &MarketingReport{}
SendReport(report) // 패닉 발생
```

Report 인터페이스가 있고, MarketingReport 객체가 Report 인터페이스를 구현한다. SendReport() 함수는 Report 인터페이스를 인수로 받는다. MarketingReport는 Report인터페이스를 구현하고 있기 때문에 SendReport()의 인수로 사용될 수 있다. 호출자 입장에서는 당연히 MarketingReport 인스턴스도 전송이 잘 될거라 예상하지만 실제로는 패닉이 발생한다.
상위 타입 Report에 대해서 작동하는 SendReport() 함수는 하위 타입인 MarketingReport에 대해서도 똑같이 작동해야 하지만 이 코드는 그렇지 못하기 때문에 리스코프 치환 원칙을 위배한 코드가 된다.
리스코프 치환 원칙에 입각한 코드는 함수 계약 관계를 준수하는 코드를 말한다. 사실 리스코프 치환 원칙은 Go 언어보다는 상속을 지원하는 다른 언어에서 더 큰 문제를 발생시킨다. 
