![](images/Pasted%20image%2020221221223417.png)
- 컴퓨터라는 세상은 하드웨어와 소프트웨어 두 가지로 이루어져 있다. 
- 하드웨어에 전산 자원이 집중되어있다. 이것을 소프트웨어가 활용하는 것
- 소프트웨어는 OS같은 시스템 소프트웨어와 유저모드의 어플리케이션 소프트웨어로 나뉜다.
- 운영체제에서 프로세스는 자신만의 고유 공간( 메모리 )를  보장받는다.
	- 이때 메모리는 가상 메모리를 사용한다. 가상 메모리는 하드 디스크 같은 2차 메모리를 주 기억장치인 램과 합쳐서 하나의 메모리로 가상화를 하는 것이다. 
		- 예를 들어  프로세스가 32비트면 운영체제는 4GB의 가상메모리를 부여한다.
		- 하지만 프로세스는 1.7GB 정도 밖에 사용하지 못한다고 한다. 또한 프로세스마다 1.7GB를 다 사용하지 못한다.  
		- 프로세스들이 떠있는 것을 생각해보면 10개만 떠있어도 40GB이며 이것이 떠있을 수 있는 것은 운영체제가 가상 메모리형태로 메모리 추상화를 해줬기 때문이다.
	- 가상 메모리는 프로세스마다 독립적이다. 이미 여러 프로세스가 동시에 작동될 수 있게 되어있고 이러한 것을 멀티 태스킹 운영체제라고 한다. 

# vmware에서의 예시
![](images/Pasted%20image%2020221221230713.png)
- NIC(Network Interface Card)는 하나밖에 없고 TCP/IP 드라이버가 있고 어떤 프로그램이 작동 중이고 만약 네트워크 입출력을 한다고 하자.(이때 파일은 소켓이다.) 
	- 물리적 NIC는 1개이고 실제로 하드웨어를 움직이는 디바이스 드라이브도 한 개가 있다.
	- 그런데 vmware를 설치하면 이러한 드라이버가 여러 개가 생기게 된다. 
- 윈도우즈 안에 새로운 리눅스를 설치한다고 하면 위와 같이 하드웨어가 위에 다시 소프트웨어(유저모드/커널모드)가 올라와있는 형태가 된다.
	- 호스트OS와 새로운 리눅스에도 똑같이 프로세스, TCP/IP, NIC의 형태가 있을 것이다. 
	- 이때 생긴 NIC들은 소프트웨어 NIC이다. 즉 소프트웨어를 하드웨어로 구현한 것이다. 
- 실제 NIC는 한 장밖에 없고 그것을 통해 인터넷으로 나가게 되는데 게스트 운영체제들이 인터넷이 되는 원리는 다음과 같다. 
	- S/W NIC은 Virtual NIC Driver에 연결된다. 이것은 실제 NIC가 아니라 드라이버만 있는 소프트웨어이다. 
	- 게스트 OS의 S/W NIC는 호스트의 Virtual NIC를 마치 L2 스위치 처럼 쓴다. 
	- 게스트 OS의 네트워크 출력은 내부 추상화를 타고 내려가서 Virtual NIC Driver 1 번을 거쳐서 0번으로 가게 되고 보통 0번은 NAT를 제공한다. 즉 공유기의 역할을 한다.  그리고 이것이 호스트 OS의 드라이버를 거쳐 외부로 나가게 된다. 소프트 웨어로 공유기를 구현한 것이다. 
- 해당 컴퓨터의 정체성은 보통 어떤 소프트웨어를 사용하느냐에 따라서 결정된다. (게임을 하느냐 엑셀을 하느냐 등에 따라서) 컴퓨터를 범용 컴퓨터라고 부르는 이유가 바로 여러 프로그램을 띄워서 그때마다 다른 목적으로 사용할 수 있기 때문이다. 

# 도커로의 전환
![](images/Pasted%20image%2020221221231438.png)
- 호스트에서 1. 프로세스, 2. 운영체제, 게스트1 에서 3. 프로세스, 4. 운영체제, 5. S/W NIC, 게스트2 에서 6. 프로세스, 7. 운영체제, 8. S/W NIC로 상당히 많은 프로세스들이 실행되고 있다.
- 그런데 각각의 게스트 OS는 해당 프로그램을 실행하기 위해 사용된다고 한다면 4, 5 번과 7, 8번은 과연 꼭 필요한 것일까? 그래서 생겨난 것이 도커이다.

# 도커
![](images/Pasted%20image%2020221221234153.png)
- 호스트와 게스트 OS가 같다면 APP 실행에 필요한 바이너리와 라이브러리를 한데 묶어서 추상화를 한다. 그리고 이외에 필요한 가상화 기술을 적용시켜주는 하이퍼바이저가 하는 역할을 컨테이너 런타임이 대신 해준다. 
- 컨테이너 런타임이 OS의 역할을 대신 해준다. OS도 프로그램으로 생각해본다면 그저 OS가 여러번 실행되기만 한다면 해결 될 수 있는 것이다. 컨테이너 런타임을 이용하여 OS를 여러번 실행하여 따로 독립적으로 각각의 프로세스에 연결만 해주면 된다.
- 만약 호스트 OS가 리눅스이고 게스트 OS도 리눅스라면 게스트의 가상화된 하드웨어는 호스트의 하드웨어와 같고 게스트의 OS도 호스트의 OS와 같으므로 없앤다. 그리고 어플리케이션 프로세스가 실행되는데 필요한 바이너리와 라이브러리를 한데 묶어서 담은 것을 컨테이너라고 한다. 
	- 아래 커널과 하드웨어가 나와야하지만 그것을 컨테이너 런타임(예를들어 도커엔진)이 그것을 대신 해준다. 
	- 시스템 콜을 하면 호스트 OS에 물어다가 다시 response해준다. 하드웨어 자원이 필요하면 하드웨어 자원을 써서 연산을 마친 후에 알려준다. 
	- 가상화에서 사용했던 OS와 하드웨어 프로그램을 돌릴 필요가 없어지게되고 효율이 엄청 높아지게 된다. 
- 컨테이너를 사용하면 배포하기 매우 편해진다. Web, WAS, DB등 필요한 서버들을 컨테이너에 담아서 실행하면 된다.
	- 이후 발생하는 오류들을 자동으로 제어하기 위한 기술이 컨테이너 오케스트레이션 그중 대표가 쿠버네티스