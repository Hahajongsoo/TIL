#datacamp #study

# Why unit test?
함수를 구현했다고 했을 때, 해당 구현이 올바른지 어떻게 확인할 수 있을까? 가장 쉬운 방법은 인터프리터를 열고 제대로 작동하는 것이다. 이런 방법은 쉽지만 매우 비효율적이다.

## Life cycle of a funtion
![[Pasted image 20221027092658.png]]
- 기능 구현
- 테스트
	- 패스 시 - 해당 구현 accept
		- 새로운 기능 요청, 기능 리팩토링 요청있다면 이후 다시 테스트
		- 새로운 버그 발견시 버그 픽스 후 다시 테스트
	- 실패 시 - 버그 픽스 
		- 이후 다시 테스트
- 수명 주기를 보면 테스트가 상당히 빈번하게 이루어짐을 확인할 수 있다. 버그 수정, 새로운 기능 구현 등 함수를 수정할 때마다 테스트를 해야한다.

### Test example
![[Pasted image 20221027093220.png]]
- row를 인수로 받아서 두 개의 element를 포함하는 함수 작성
- 인수에는 정해진 포맷이 있는데 데이터는 클린하지 않으므로 예외가 발생한다.
- 해당 경우에는 return value가 none이어야 한다.
- 이 함수를 테스트 하려면 모든 데이터를 확인해야 한다.

### Manual testing vs unit tests
unit test는 테스트 시간을 확실하게 줄여줄 수 있다.

## Write a simple unit test using pytest
파이썬에서는 다양한 unit test library가 있다.
- pytest
- unittest
- nosetests
- doctest

### 1. Create a file
- 파일을 명명할 때, 파일명은 `test_` 로 시작해야한다.
- unit test를 포함하는 파일을 테스트 모듈이라고도 한다.

### 2. Imports
```python
import pytest
import row_to_list
```
- 테스트 모듈에 pytest와 테스트할 함수를 포함하는 모듈을 Import한다.

### 3. Unit test are Python functions
```python
import pytest
import row_to_list


def test_for_clean_row():
```
- 모듈명을 명명했던 것 처럼 함수명도 같게 명명한다.
- 유닛 테스트는 일반적으로 인수 및 반환 값 테이블의 하나의 항목에 해당한다.
- 유닛 테스트는 특정 인수로 호출될 때, 예상되는 반환 값이 있는지 확인한다.

### 4. Assertion
#### First unit test
```python
import pytest
import row_to_list


def test_for_clean_row():
	assert row_to_list("2,081\t314,942\n") == ["2,081", "314,942"]
```
- 일반적으로 테스트는 `assert` 문으로 수행되며, 모든 테스트에는 `assert` 문이 포함되어야 한다.
	- `assert` 의 조건이 `True` 이면 아무것도 반환하지 않고
	- `False` 이면 `AssertionError`가 발생한다.

#### Second unit test
```python
import pytest
import row_to_list


def test_for_clean_row():
	assert row_to_list("2,081\t314,942\n") == ["2,081", "314,942"]


def test_for_missing_area():
	assert row_to_list("\t293,410") is None
```

Third unit test 
```python
import pytest
import row_to_list


def test_for_clean_row():
	assert row_to_list("2,081\t314,942\n") == ["2,081", "314,942"]


def test_for_missing_area():
	assert row_to_list("\t293,410") is None


def test_fo_missing_tab():
	assert row_to_list("1,463238,765\n") is None
```

### 5. Running unit test
`row_to_list()`가 수명주기에서 언제든지 작동하는지 테스트 하려면 테스트 모듈을 실행하기만 하면 된다.
`pytest test_row_to_list.py` 로 해당 파이썬 스크립트를 pytest로 실행한다.


## Understanding test result report
pytest 의 출력을 test result report 라고 하며 버그 수정에 도움이 되는 정보를 포함한다.

### Section 1
![[Pasted image 20221027103537.png]]
운영 체제, python 버전, pytest 패키지 버전, 작업 디렉토리 및 pytest 플러그인 등에 대한 정보를 포함한다.

### Section 2: test result
![[Pasted image 20221027103730.png]]
- `collected 3 items` 실행할 테스트 3개를 찾았음을 의미한다.
- 그 다음 줄에 테스트 모듈 이름이 표시 되고 테스트 결과를 반환한다.
	- `F` 는 테스트가 실패했음을 의미한다. `AssertionError` 이거나 그 이전에 다른 에러가 발생한 경우이다.
	- `.` 은 테스트를 통과했음을 의미한다.

### Section 3: INformation on failed tests
![[Pasted image 20221027104111.png]]
실패한 테스트에 대한 자세한 정보가 포함되어 있다.
- 어떤 유닛 테스트가 실패했는지 알 수 있다.
-  `>` 은 해당 라인이 에러가 발생했음을 알려준다.
-  `E` 는 예외에 대한 세부 정보가 포함되어 있다. 어떤 에러가 발생했는지, 실제로 반환된 값이 무엇인지 에 대한 정보등을 포함한다. 예상 값과 실제 값의 불일치는 디버깅의 시작점이 된다.

### Section 4: Test result summary
![[Pasted image 20221027104508.png]]
몇 개의 테스트가 실패하고 통과했는지, 시간이 얼마나 걸렸는지 의 요약 내용이다.

## More benefits and test types
단위 테스트의 는 시간 절약 이상의 이점을 가지고 있다. 
- unit tests serve as documentation
	- 유닛 테스트의 내용을 보고 테스트 하는 함수가 무슨 일을 수행하는지 알 수 있으므로 도큐멘테이션의 역할을 할 수 있다.
- more trust
	- 사용자가 유닛 테스트를 실행하고 기능이 작동하는지 확인할 수 있으므로 패키지에 대한 신뢰도를 높인다.
	- github에서 설정해놓은 배지로 코드 커버리지가 얼마나 되는지, CI는 통과했는지 등을 확인할 수 있다.
- reduce downtime
	- 실제 제공되는 시스템에 error를 유발하는 코드를 포함하는 내용을 push 한다면 해당 시스템은 다운되어 에러가 복구될 때 까지 기다려야 한다.
	- 하지만 CI 를 시스템에 포함한다면 이러한 가능성을 줄일 수 있다. CI는 push되는 내용에 대해서 유닛테스트를 실행하며 실패하는 경우 변경을 거부하여 다운 타임을 방지한다.
	- 또한 코드를 수정해야 함을 알려준다.
### test 종류
- unit test
	unit은 작은 독립 코드 조각이며 Python 함수, 클래스 등이 될 수 있다. 그리고 unit test는 이러한 unit들이 제대로 동작하는지 테스트한다. 
- Integration test
	통합 테스트는 여러 단위가 작동하는지 확인한다. 
- End to end test
	전체 소프트웨어를 한 번에 확인한다.

# Mastering assert statements

## Test result report with message
assert 문을 사용할 때 첫 번째 인수로 bool 변수만 사용했었는데, 두 번째 인수로 message 라는 것을 추가할 수 있다. 해당 메세지는 AssertionError가 발생할 때 프린트 되는 메세지이므로 해당 에러가 발생한 이유에 대한 정보를 포함해야 한다.

### Recommendations
- assert 문을 사용할 때에는 message를 포함하는 것이 좋다. 자동으로 출력되는 것 보다 읽고 이해하기 훨씬 쉽다.
- message 에서는 디버깅과 관련될 수 있는 변수의 값을 출력한다.

### Beware of float return values
- 파이썬에서는 float 값의 비교가 항상 생각하는 것 처럼 이루어 지지는 않는다. 
- 파이썬이 부동 소수점을 나타내는 방식 때문에 실제 값과 예상 하는 값이 다르기 때문에 assert문에서 float을 비교할 때 부동 소수점을 비교하는 일반적인 방법을 사용해서는 안된다.
- 대신에 `pytest.approx()` 를 사용하여 예상되는 return value를 wrapping 해야한다.
- 이 방식은 numpy array에도 적용할 수 있다.

### Multiple assertions in one unit test
- 하나의 유닛 테스트에 여러 개의 assert 문이 적용될 수도 있다.
- 예를 들어, 콤마를 포함하는 문자열을 정수로 바꾸는 함수를 테스트 하는 경우 
	- 변환된 결과가 int 인지
	- 원하는 값으로 제대로 변환됐는지
	의 두 가지 조건을 모두 확인해 볼 수 있다. 그리고 두 assert 문을 모두 만족해야 유닛테스트가 통과 된다.

## Testing for exceptions instead of return values

- 지금까지는 assert 문을 이용하여 함수가 예상하는 값을 반환하는지 확인했다. 그러나 일부 함수는 아무것도 반환하지 않고 특정 인수에 대해서 호출 될 때 예외를 발생시킬 수 있다.
- 해당 함수를 테스팅할 때에는 with문과 `pytest.raises()` 를 통해 특정 error가 발생하는지 테스팅 한다.
### Theoretical structure of a with statement
![[Pasted image 20221028000950.png]]
- with 문 안에 있는 모든 코드를 컨텍스트 라고 한다.
- with 문은 컨텍스트 관리자라고 하는 단일 인수를 사용한다. 그리고 컨텍스트 매니저는 컨텍스트에 들어가고 나가기 전에 몇 가지 코드를 실행한다.
- 지금의 경우에는 `pytest.raises()` 가 컨텍스트 매니저가 된다. 단일 인수를 받으며 해당 인수는 우리가 확인하는 예외 유형이다.
- 이 컨텍스트 매니저는 컨텍스트에 들어갈 때는 아무 코드도 실행하지 않지만 컨텍스트에서 나올 때 코드를 실행한다.
- 컨텍스트의 코드에서 ValueError가 발생하면 컨텍스트 관리자가 해당 오류를 무시한다. 그러나 ValueError 가 발생하지 않는다면 자체적으로 예외를 발생시킨다.
### Testing the error message
- 예외가 발생하는 경우에서 좀 더 디테일하게 유닛테스트를 진행할 수도 있다. 예를 들어 에러메세지가 원하는대로 출력되는지 테스트 해볼 수 있다.
![[Pasted image 20221028001656.png]]
- 이때는 `pytest.raises()`  로 with 문을 사용할 때, as 도 추가한다. 그리고 해당 변수의 match 메서드를 이용하여 인수로 넣는 문자열이 에러 메세지에 포함되는지 확인한다.