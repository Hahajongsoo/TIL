템플릿은 웹프로그래밍에서 중요한 요소로 사용자가 템플릿을 사용해 웹 페이지를 개인화할 수 있게 해준다.
템플릿은 일종의 양식 서류이다. 일정한 양식이 있는 서류는 데이터베이스의 모든 사용자가 맞춤화하고 개인화할 수 있다. 
데이터베이스에서 데이터를 가져와 템플릿에 표시하는 것이다. 
표준 라이브러리에는 text 템플릿과 HTML 템플릿이 있다. text 템플릿은 템플릿의 기초를 설계한다. HTML 템플릿은 text 템플릿이 수행하는 모든 역할과 HTML 페이지상에서 활용할 수 있는 추가 기능을 제공해준다. 

# 배열 합치기를 통한 템플레이팅
텍스트만 사용하여 데이터와 결합된 HTML 파일을 만들 방법이 있을까? HTML의 경우 단순한 텍스트이기 때문에 문자열을 덧붙이기만 하면 된다. 

## 파이프라인을 이용하여 표준출력 덤프하기
```go
package main

import "fmt"

func main() {
	name := "Todd McLeod"

	tpl := `
	<!DOCTYPE html>
	<html lang="en">
	<head>
	<meta charset="UTF-8">
	<title>Hello World!</title>
	</head>
	<body>
	<h1>` + name + `</h1>
	</body>
	</html>
	`
	fmt.Println(tpl)
}
```

```shell
go run main.go > index.html
```

## os 패키지로 파일 생성하기

```go
package main

import (
	"fmt"
	"io"
	"log"
	"os"
	"strings"
)

func main() {
	name := "Jongsoo Ha"

	str := fmt.Sprint(`
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Hello World!</title>
</head>
<body>
<h1>` + name + `</h1>
</body>
</html>
	`)
	nf, err := os.Create("./index.html")
	if err != nil {
		log.Fatal("error creating file", err)
	}
	defer nf.Close()

	io.Copy(nf, strings.NewReader(str))
}
```

```shell
go run main.go
```

## args 로 템플레이팅

```go
package main

import (
	"fmt"
	"io"
	"log"
	"os"
	"strings"
)

func main() {
	name := os.Args[1]
	fmt.Println(os.Args[0])
	fmt.Println(os.Args[1])
	str := fmt.Sprint(`
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Hello World!</title>
</head>
<body>
<h1>` + name + `</h1>
</body>
</html>
	`)
	nf, err := os.Create("./index.html")
	if err != nil {
		log.Fatal("error creating file", err)
	}
	defer nf.Close()

	io.Copy(nf, strings.NewReader(str))
}

```

```shell
go run main.go Hajong
```

# text/template 패키지
위의 장에서 첫 번째 예시 코드에는 문제가 있다. 모든 코드가 패키지 main과 func main에 있다는 점이다. 이를 추상화 하여 재사용 가능하게 만들어본다. 가능한 방법은 해당 문자열을 func main 밖에 두는 것이고 이를 위한 최적의 방식은 HTML 파일 전체를 프로그램 내부로 가져와 사용하는 것이다. 이를 위해 `text/template` 패키지를 사용한다.

파일을 프로그램으로 가져와 사용할 수 있게 하는 것을 파일을 `파싱`한다고 한다. 파일이 많이 있는 경우에도 이를 프로그램으로 가져와 사용할 수 있다.

먼저 파싱할 템플릿 파일을 생성한다. go 에서 관습적으로 `.gohtml` 확장자로 사용한다.

이전에 `text/template` 패키지에 대해 살펴본다. 해당 패키지의 index를 살펴보면 `Template` 타입이 존재하는 것을 확인할 수 있다. 해당 타입에는 템플릿에 대한 포인터인 `*Template` 을 생성하는 함수들이 있다. 그리고 그 후에는 포인터를 이용한 메서드들을 사용할 수 있다.

![](images/Pasted%20image%2020230704171201.png)

## template.ParseFiles
```go
package main

import (
	"log"
	"os"
	"text/template"
)

func main() {
	tpl, err := template.ParseFiles("./tpl.gohtml")
	if err != nil {
		log.Fatal(err)
	}
	err = tpl.Execute(os.Stdout, nil)
	if err != nil {
		log.Fatal(err)
	}
}
```

- `ParseFiles` 는 0개 이상의 문자열을 받을 수 있다. 파일을 파싱하여 저장하는데 `ParseFiles` 는 템플릿에 대한 포인터와 오류를 반환한다. 이때 반환받는 포인터는 파싱한 모든 템플릿을 보유하고 있다. 
- `Execute` 는 `io.Writer` 를 인수로 받는데 `Writer` 인터페이스는 `Write` 메소드를 구현하고 있으면 된다. 이때 `os.Stdout` 은 `os.File` 로 `Write` 메소드를 구현하고 있다. `os.Create` 또한 `File`을 반환하기 때문에 해당 파일에 `Execute` 를 쓰기 위해 `os.Stdout` 이 아닌 `os.Create` 를 이용하여 바로 HTML 파일을 생성하게 할 수 있다.

```go
package main

import (
	"log"
	"os"
	"text/template"
)

func main() {
	tpl, err := template.ParseFiles("./tpl.gohtml")
	if err != nil {
		log.Fatal(err)
	}

	nf, err := os.Create("index.html")
	if err != nil {
		log.Fatal(err)
	}
	defer nf.Close()

	err = tpl.Execute(nf, nil)
	if err != nil {
		log.Fatal(err)
	}
}

```

## `*Template.ParseFiles`
- 파싱한 데이터에 추가로 파싱하고자 할 때 사용한다. 이미 `template.ParseFiles` 로 생성된 포인터에 파싱한 데이터를 추가한다. 
- 파싱한 데이터가 여러 개인 경우 즉, 템플릿이 여러 개인 경우 어떠한 템플릿을 실행할지 명시해야한다. 이때는 `Execute` 대신 `ExecuteTemplate` 을 사용한다. `Execute` 를 사용하는 경우 가장 먼저 넣은 템플릿을 실행하게 된다.

```go
package main

import (
	"log"
	"os"
	"text/template"
)

func main() {
	tpl, err := template.ParseFiles("one.gmao")
	if err != nil {
		log.Fatal(err)
	}
	tpl, err = tpl.ParseFiles("two.gmao", "three.gmao")
	if err != nil {
		log.Fatal(err)
	}
	err = tpl.Execute(os.Stdout, nil)
	if err != nil {
		log.Fatal(err)
	}

	err = tpl.ExecuteTemplate(os.Stdout, "two.gmao", nil)
	if err != nil {
		log.Fatal(err)
	}
	err = tpl.ExecuteTemplate(os.Stdout, "three.gmao", nil)
	if err != nil {
		log.Fatal(err)
	}
	err = tpl.ExecuteTemplate(os.Stdout, "one.gmao", nil)
	if err != nil {
		log.Fatal(err)
	}
}
```

## `ParseGlob`
- 파싱 할 때 파일 이름이 아닌 패턴을 사용하는 경우에 사용한다. 와일드 카드를 이용하여 특정 디렉토리 내 특정 확장자를 갖는 모든 파일을 파싱할 수 있다. 

```go
package main

import (
	"log"
	"os"
	"text/template"
)

func main() {
	tpl, err := template.ParseGlob("templates/*.gmao")
	if err != nil {
		log.Fatal(err)
	}

	err = tpl.Execute(os.Stdout, nil)
	if err != nil {
		log.Fatal(err)
	}

	err = tpl.ExecuteTemplate(os.Stdout, "two.gmao", nil)
	if err != nil {
		log.Fatal(err)
	}
	err = tpl.ExecuteTemplate(os.Stdout, "three.gmao", nil)
	if err != nil {
		log.Fatal(err)
	}
	err = tpl.ExecuteTemplate(os.Stdout, "one.gmao", nil)
	if err != nil {
		log.Fatal(err)
	}
}

```

## `template.Must`
- 프로그램의 성능 준수를 위해서 각 파일들을 한 번씩 만 파싱했는지 확인하는 것이 필요할 수 있다. `Must`의 경우 `ParseFiles` 나 `ParseGlob` 등의 결과에 대한 오류처리를 대신 해준다. 파싱하는 함수들의 반환 값은 템플릿의 포인터와 에러이고 `Must` 는 템플릿의 포인터와 에러를 인수로 받고 템플릿의 포인터를 반환한다. 

# 템플릿에 데이터 입력하기