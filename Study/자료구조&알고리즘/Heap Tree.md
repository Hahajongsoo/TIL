# Heap Tree
- 부모 노드는 자식 노드에 비해서 크거나 작은 트리
- 부모가 큰 트리를 Max Heap Tree 라고 한다.
- 부모가 작은 트리를 Min Heap Tree 라고 한다.
- 형제 간 대소 비교는 중요하지 않다.

## Max Heap Tree

![](images/Pasted%20image%2020230619225237.png)

## Min Heap Tree

![](images/Pasted%20image%2020230619225310.png)

## 구현

### Push
- 맨 뒤로 추가하려는 노드를 추가한다.
- 부모와 비교해서 클 경우 서로 바꾼다.
- 이것을 부모보다 작을 때 까지 반복한다. (Min Heap Tree의 경우 반대)
- 이 과정을 Up heapify 라고 한다.

### Pop
- Pop은 항상 루트 노드에서 발생
- 맨 마지막 노드와 루트 노드를 바꾼다.
- 맨 마지막 노드를 없앤다.
- 루트부터 시작해서 자식 노드와 비교하여 작으면 바꾼다.
- 더 이상 자식이 없거나 자식 노드보다 클 때 까지 반복한다.
- 이 과정을 Down heapify 라고 한다.

### 구현
- 요소가 맨 뒤에서 추가되고 삭제되기 때문에 보통 Array로 구현한다.
	- 노드의 형태로 구현하는 경우 맨 뒤를 찾는 과정에서 부르트포스로 $O(N)$이 되기 때문에 비효율적이 된다.
- 시간 복잡도는 Push 와 Pop 모두 $O(logN)$ 이다.

- 부모노드 인덱스 : `(현재 노드 인덱스 - 1) / 2 `
- 왼쪽 자식 인덱스 : `(현재 인덱스 * 2) + 1`
- 오른쪽 자식 인덱스: `(현재 인덱스 * 2) + 2`


### 코테에서 예시
- 상위 몇 등을 구하는 경우 Min Heap을 사용하고 하위 몇 등을 구하는 경우 Max Heap을 사용한다.
	- 예를 들어 상위 5등을 구하는 경우에 길이가 5인 Min Heap을 유지하게 하면 전체에서 상위 5위까지가 구해질 때 까지 계속 그 보다 작은 값들을 Pop 하면서 길이가 5인 트리를 유지하기 때문에 마지막에는 top 5만 남게 되고 루트 노드에는 5위의 값이 들어가게 된다.

## 힙소트
- 힙 트리를 이용한 소트 방법
- 시간 복잡도: $O(NlogN)$
- 분산처리가 될 수 없기 때문에 merge sort 보다는 느리다.

## Go에서 제공하는 힙트리
- "container/heap" 패키지에서 제공
- 인터페이스 형태로 제공해서 자료구조에 독립적이지만 슬라이스로 구현하는 것이 편하다.

# 우선 순위 큐
- 우선 순위 큐의 구현에 heap을 이용한다.