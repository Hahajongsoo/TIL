# 오픈소스
## 예시
todo list를 작성하는 예시를 생각해보자. 가장 처음에는 3 tier로 
### CI/CD
#### harbor
- 도커 허브와 유사
- 컨테이너 이미지, 헬름 차트 저장
- 취약점 스캔
- 구현언어: GO 언어
#### helm
- 쿠버네티스 배포에 필요한 리소스 사전 정의 (Chart=packaging format)
- values.yaml 로 변하는 부분을 지정
- 템플릿을 harbor 등에서 가져올 수 있고 이를 배포할 수 있다.
### Observability
#### OpenTelemetry
- Telemetry
- traces, metirics 수집
#### Jeager
- 서비스간 의존관계 분석
- 마이크로서비스 환경 모니터링
### Chaos Engineering
- 클라우드 네이티브에서 어느 부분에서 에러가 발생하는지 그리고 이에 대해 회복력을 가지고 있는지 확인하는 방법 중 하나는 일부러 특정 부분에 에러를 발생시키는 것이다.
- Litimus는 chaos engineering 을 진행하는 툴이다.
- 앱에서 뿐 만 아니라 앱에 연결된 DB, k8s 리소스, 이를 제공하는 인프라 에도 에러를 발생시킨 후 회복하는지 확인할 수 있다.
### Reversproxy
#### traefik
-  오픈소스 컨트리뷰션 아카데미
- lfx mentorship
# GO test

# 당근에서 Go
## 프로젝트 현황
- 레포 200+ 개
- 인원 50+ 명
- 1초에 Req/sec 이 8만, 3만 5천 개를 받는 서비스들이 있다. 첫 번째의 경우 2코어 10기가 100개 파드를 사용한다고 한다.

## Go의 장단점
- 빠른 컴파일
- 빠른 앱시작
- 동시성 제어에
- 성능 튜닝에도 용이함
- 에러 처리가 번거로움, 코드 복잡도가 높아짐
- GC는 대규모 힙을 가진 시스템에서 성능 저하를 일으킬 수 있음
## Go의 성능 이슈
### mutex
- mutex가 동작하는 모드가 상황마다 다르다.
- mutex가 normal 모드와 starvation mode가 있다.
## CPU Throttling
- NumCPU가 cgroup 보다 크게 잡히는 경우
- uber-go/automaxprocs
## 메모리 최적화 및 GC 튜닝
- 코드 개선
	- 불필요한 메모리 할당 최소화
		- 슬라이스와 맵에서 cap 할당한다. 슬라이스와 map은 더블링을 사용하기 때문에 특정 크기에 도달하면 크기를 두 배씩 늘린다.
	- 어쩔 수 없는 경우, 재사용
- 메모리 사용 개선하기
	- GC 튜닝하기
	- GC cycle의 횟수 줄이기
	- GO runtime은 많은 튜닝 옵션을 주지 않는다 (GOGC, MemoryLimit 2가지)
	- 당근에서는 GOGC 를 튜닝하기보다는 MemoryLimit 을 조절하는 것으로 튜닝했다고 한다.

## CPU/Memory 관리를 위한 autopprof
- daangn/autopprof

- 도메인 복잡도가 올라가면서 변화하는 코드 변화
- gRPC 서비스 최적화하기

- go 마스터하기, head first go 도서
# 컨텍스트를 이용한 상태관리
## 컨텍스트
- 컨텍스트 주석 내용 참고
- `context.Background()` 함수는 빈 컨텍스트를 생성한다. 기능이 없음, 모든 컨텍스트의 부모 역할을 할 수 있다.
- `TODO()`
### cancel
- `context.WithCancel()` 함수로 생성
- 취소 될 수 있다. 취소 신호를 전파할 수 있다.
### timber context
- WithDeadline() 로 생성
- 타임아웃이 존재한다. 취소 신호를 전파할 수 있고 타임아웃 신호를 전파할 수 있다.
### value context
- withvalue
- 값을 가진다. 값을 전파할 수 있다.
## 예시
### 작업 영역에 대한 정의 및 제한 설정
### 요청 범위 안에서의 데이터 전파
- 밸류 컨텍스트에 타입 앨리어싱을 사용하여 런타임에서 타입 비교를 빠르게 할 수 있게 한다.
- 요약된 부분은 http.responswriter 에 401 에러를 쓰는 것
### 작업 종료 후 소멸자 역할
- `context.afterfunc` 
	- 트리거를 가지고 있고, 컨텍스트가 취소 됐을 때 실행된다. (따라서 취소 가능한 컨텍스트를 넘겨주어야 한다.)
- 컨텍스트가 종료되면 `sync.Pull` 이 실행되도록하여 소멸자 역할을 하게 한다.
### 같은 작업 영역 안에서의 에러 전파
- `context.Cause`
	- 컨택스트가 취소됐을 때 어떤 에러 때문에 종료되었는지 확인할 수 있다.
- 컨텍스트를 이용하면 특정 로직 없이 리시버들에게 에러를 전파할 수 있다.
- 메인 함수에는 나와있지 않지만 alertQueue 를 제어할 로직이 있어야 한다. 
## 결론
# API 서버 테스트코드 A-Z
## go test 개요
- go에서는 table driven testing 을 주로 사용한다.
## 테스트를 어렵게 만드는 요소
- 결합도 & 응집도
	- 하드코딩하는 경우
	- 응집도가 낮으면 함수가 커질 뿐만 아니라 테스트해야하는 케이스가 많아져서 어려워지게 된다.
- 복잡한 매개변수와 반환값
	- 추가적으로 가독성도 떨어지게 된다. 
- 고루틴 & 채널
	- 더 많은 고려사항이 필요하다.
- 외부 의존성
	- 외부에서 변화가 생기면 미리 작성해놓은 테스트 코드가 무너지게 된다. 서드파티의 응답은 일관되지 않을 수 있다.
- 코드 구조와 설계
	- go clean architecture 참조하는 것을 추천

- golang project layout
	- go starndard project 참조
	- 인터페이스는 한 패키지에 몰아져있는 것이 좋다.
	- 상위레이어는 하위 레이어를 참조할 수 있지마 하위 레이어는 상위 레이어가 있는지 알지도 못한다.
	- delivery의 경우는 참조할 것이 없기 때문에 인터페이스를 사용하지 않는다. 
## Layer별 테스트 usecase
= TestMain 
- Repository layer에서 데이터 일관성을 유지하는 방안
	- docker
	- in memory database
	- mock
		- 상황에 따라 적합하지 않을 수 있다. 실제로 API가 변경되었는데 알지 못하는 경우가 생길 수도 있다.
		- sqlmock 의 경우 비즈니스 로직이 복잡해지는 경우 sqlmock으로 구현하는 것이 어려워 질 수 있다.
- usecase
	- repository에서 모두 잘 동작한다고 생각하고 mock을 이용한다. 시간이 충분치 않기에 취할것은 취하고 버릴 것은 버리도록 함
	- 비즈니스 로직에 집중할 수 있고 레포지토리에 추가적으로 접근하는 것을 막을 수 있다.
- delivery
	- 프레젠테이션 레이어이므로 외부로 잘 반환하는지에 집중한다.
## 어려운 테스트 usecase
- 런타임에 정해지는 값들
	- 원하는 형태로 주입하도록 한다.
	- 대안으로 go-cmp, 변하는 값들에 대해서 테스트를 무시한다. 모킹하는 경우에도 크게 보면 무시하는 것과 맥락이 같다고 볼 수 있기 때문
- 어쩔 수 없이 비대해지는 함수들
	- 내부함수를 별도로 검증하고 , 무결하다고 가정하고 모킹한다.
- 고루틴 & 채널
# Go와 k8s로 만드는 datacenter autopilot
- k8s 오퍼레이터 패턴
	- 오퍼레이터 모듈이 커스텀리소스를 watch 하고 잇다가 자원의 변화가 생기면 event를 받는다.
	- 생기는 변화는 자원의 생성, 수정, 삭제 등이다.
	- event를 기준으로 개발자가 미리 구현한 특정 행동들을 할 수 있다.
- 커스텀 리소스의 스펙들은 go의 구조체로 정의하면 된다. 
- 자동화하고 싶은 부분은 `Reconcile` 함수에 넣도록 한다.
# profiling and racing tips in go : OLAP 데이터베이스를 개발하며 얻은 교훈들
- pprof 를 이용하여 특정 단계, 함수에서 memory, cpu 사용을 줄일 수 있는 방안을 찾도록 한다.
# eBPF 도구를 이용해 Go 애플리케이션 추적하기
## eBPF
- 자바스크립트가 웹 안에서 해당 기능을 확장하는 것 처럼 eBPF는 커널에서 기능을 확장하게 해준다. 
- eBPF 언어는 여러 개발할 수 있다.
## eBPF 이벤트 소스
- 운영 체제에서 다양한 event가 있고 이를 추적하는 probe를 나타낸다.
## bpftrace 소개
### Go 애플리케이션 추적
### 결론
