# 반복문
- 반복적인 작업을 효율적으로 하기 위해 사용
- loop 구문을 사용해서 각 작업에 대한 반복 작업 수행 가능
- 변수 값을 변경하면서 모듈을 실행( item이라는 이름의 변수 사용 )
- 조건식과는 다르게 block 단위의 반복 작업은 불가
	- 조건식과 함께 사용하는 방식은 가능
- loop 구문에서 변수 선언 시에 리스트 형태 구성도 가능
- 중첩 기능도 제공

## 단순 반복문

```yaml
- name: Loop test
  hosts: ansi-node1
  gather_facts: false
  tasks:
    - name: Add serveral users
      ansible.builtin.user:
        name: "{{ item }}"
      loop:
        - testuser1
        - testuser2
```

```
vagrant@ansi-master1:~/ansitest
$ ansible-playbook ./playbooks/loop_test.yaml 
[WARNING]: Skipping plugin (/home/vagrant/.local/lib/python3.9/site-packages/ansible/plugins/connection/winrm.py), cannot
load: invalid syntax (spawnbase.py, line 224)

PLAY [Loop test] ************************************************************************************************************

TASK [Add serveral users] ***************************************************************************************************
changed: [ansi-node1] => (item=testuser1)
changed: [ansi-node1] => (item=testuser2)

PLAY RECAP ******************************************************************************************************************
ansi-node1                 : ok=1    changed=1    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0   

vagrant@ansi-master1:~/ansitest
$ ssh ansi-node1 cat /etc/passwd | tail -3
ubuntu:x:1001:1001:Ubuntu:/home/ubuntu:/bin/bash
testuser1:x:1002:1002::/home/testuser1:/bin/sh
testuser2:x:1003:1003::/home/testuser2:/bin/sh
```

## 반복문에 변수 참조
- loop에 목록 변수를 직접 지정할 수 있다.

```yaml
- name: Loop test
  hosts: ansi-node1
  gather_facts: false
  vars:
    user_names:
      - list_testuser1
      - list_testuser2
  tasks:
    - name: Add serveral users
      ansible.builtin.user:
        name: "{{ item }}"
      loop:
        "{{ user_names }}"

```

```
vagrant@ansi-master1:~/ansitest
$ ansible-playbook ./playbooks/loop_test.yaml 
[WARNING]: Skipping plugin (/home/vagrant/.local/lib/python3.9/site-packages/ansible/plugins/connection/winrm.py), cannot
load: invalid syntax (spawnbase.py, line 224)

PLAY [Loop test] ****************************************************************************************

TASK [Add serveral users] ***************************************************************************************************
changed: [ansi-node1] => (item=list_testuser1)
changed: [ansi-node1] => (item=list_testuser2)

PLAY RECAP ****************************************************************************************
ansi-node1                 : ok=1    changed=1    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0   

vagrant@ansi-master1:~/ansitest
$ ssh ansi-node1 cat /etc/passwd | tail -3
testuser2:x:1003:1003::/home/testuser2:/bin/sh
list_testuser1:x:1004:1004::/home/list_testuser1:/bin/sh
list_testuser2:x:1005:1005::/home/list_testuser2:/bin/sh
```

```yaml
- name: Loop test
  hosts: ansi-node1
  gather_facts: false
  tasks:
    - name: Command ls 
      ansible.builtin.command:
        cmd: "ls -al /root"
      register: result
    - name: Print stdout
      ansible.builtin.debug:
        msg: "{{ item }}"
      loop:
        "{{ result.stdout_lines }}"

```

```
$ ansible-playbook ./playbooks/loop_test.yaml 
[WARNING]: Skipping plugin (/home/vagrant/.local/lib/python3.9/site-packages/ansible/plugins/connection/winrm.py), cannot
load: invalid syntax (spawnbase.py, line 224)

PLAY [Loop test] ****************************************************************************************

TASK [Command ls] ****************************************************************************************
changed: [ansi-node1]

TASK [Print stdout] ****************************************************************************************
ok: [ansi-node1] => (item=total 20) => {
    "msg": "total 20"
}
ok: [ansi-node1] => (item=drwx------  3 root root 4096 Jan 30 02:51 .) => {
    "msg": "drwx------  3 root root 4096 Jan 30 02:51 ."
}
ok: [ansi-node1] => (item=drwxr-xr-x 24 root root 4096 Jan 30 02:51 ..) => {
    "msg": "drwxr-xr-x 24 root root 4096 Jan 30 02:51 .."
}
ok: [ansi-node1] => (item=-rw-r--r--  1 root root 3106 Apr  9  2018 .bashrc) => {
    "msg": "-rw-r--r--  1 root root 3106 Apr  9  2018 .bashrc"
}
ok: [ansi-node1] => (item=-rw-r--r--  1 root root  148 Aug 17  2015 .profile) => {
    "msg": "-rw-r--r--  1 root root  148 Aug 17  2015 .profile"
}
ok: [ansi-node1] => (item=drwx------  2 root root 4096 Jan 30 02:51 .ssh) => {
    "msg": "drwx------  2 root root 4096 Jan 30 02:51 .ssh"
}

PLAY RECAP ****************************************************************************************
ansi-node1                 : ok=2    changed=1    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0  
```

## 사전 목록 반복
- 변수를 참조하는 방법은 `item.<dict_key>` 형식으로 참조
```yaml
- name: Loop test
  hosts: ansi-node1
  gather_facts: false
  vars:
    info:
      - name: Lee
        age: 15
      - name: Kim
        age: 28
      - name: Ha
        age: 29
  tasks:
    - name: Print vars
      ansible.builtin.debug:
        msg: "name: {{ item.name }}, age: {{ item.age }}"
      loop:
        "{{ info }}"

```

```
$ ansible-playbook ./playbooks/loop_test.yaml 
[WARNING]: Skipping plugin (/home/vagrant/.local/lib/python3.9/site-packages/ansible/plugins/connection/winrm.py), cannot
load: invalid syntax (spawnbase.py, line 224)

PLAY [Loop test] ****************************************************************************************

TASK [Print vars] ****************************************************************************************
ok: [ansi-node1] => (item={'name': 'Lee', 'age': 15}) => {
    "msg": "name: Lee, age: 15"
}
ok: [ansi-node1] => (item={'name': 'Kim', 'age': 28}) => {
    "msg": "name: Kim, age: 28"
}
ok: [ansi-node1] => (item={'name': 'Ha', 'age': 29}) => {
    "msg": "name: Ha, age: 29"
}

PLAY RECAP ****************************************************************************************
ansi-node1                 : ok=1    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0 
```

## 중첩 목록 반복
- 여러 개의 목록을 결합(데카르트 곱) 가능
```yaml
- name: Loop test
  hosts: ansi-node1
  gather_facts: false
  vars:
    list1:
      - 1
      - 2
    list2:
      - a
      - b
      - c
  tasks:
    - name: Print multi list vars
      ansible.builtin.debug:
        msg: "number: {{ item[0] }}, alphabet: {{ item[1] }}"
      loop:
        "{{ list1 | product(list2) | list }}"

```

```
$ ansible-playbook ./playbooks/loop_test.yaml 
[WARNING]: Skipping plugin (/home/vagrant/.local/lib/python3.9/site-packages/ansible/plugins/connection/winrm.py), cannot
load: invalid syntax (spawnbase.py, line 224)

PLAY [Loop test] ****************************************************************************************

TASK [Print multi list vars] ****************************************************************************************
ok: [ansi-node1] => (item=[1, 'a']) => {
    "msg": "number: 1, alphabet: a"
}
ok: [ansi-node1] => (item=[1, 'b']) => {
    "msg": "number: 1, alphabet: b"
}
ok: [ansi-node1] => (item=[1, 'c']) => {
    "msg": "number: 1, alphabet: c"
}
ok: [ansi-node1] => (item=[2, 'a']) => {
    "msg": "number: 2, alphabet: a"
}
ok: [ansi-node1] => (item=[2, 'b']) => {
    "msg": "number: 2, alphabet: b"
}
ok: [ansi-node1] => (item=[2, 'c']) => {
    "msg": "number: 2, alphabet: c"
}

PLAY RECAP ****************************************************************************************
ansi-node1                 : ok=1    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0
```

## 인벤토리 반복
- 인벤토리 호스트 목록을 반복문을 통해 가져올 수 있다.


# 조건문
## 조건문
- ansible은 조건문을 사용하여 특정 조건을 충족하는 작업 또는 플레이를 실행할 수 있다.
- 서비스를 설치하거나 구성하기 전에 관리 호스트에서 사용 가능한 메모리를 확인하는 데 조건 문을 사용할 수 있다.
- 조건문을 사용하여 관리자가 관리 호스트간의 차이점을 구분하고 충족된 조건을 기반으로 하여 기능 역할을 할당할 수 있다.
- 플레이북 변수, 등록된 변수 및 Ansible 팩트는 모두 조건문을 사용하여 테스트 할 수 있다.
- Ansible 조건부에서 테스트 및 필터를 사용
- 테스트는 표현식을 평가하고 True와 False를 반환한다.
- 조건문에서 변수를 참조하더라도 변수명에 {{}} 이중 중괄호를 사용하지 않는다. 

## Test systax 
jinja의 테스트 문법을 사용하여 true 혹은 false를 반환하게 하여 조건문을 작성할 수 있다. jinja의 테스트 문법은 다음의 꼴이고,
```
variable is test_name
```
예를 들면 다음과 같다.
```
result is failed
```

### 문자열 테스트
- match 의 경우 해당 패턴을 문자열의 시작 부분에서 찾으면 성공하게 된다. 
- search 의 경우 해당 패턴을 문자열 어디서든 찾을 수 있다면 성공하게 된다. 
```yaml
- name: Condition test
  hosts: ansi-node1
  gather_facts: false
  vars:
    url: "http://www.nobreak.co.kr/guest/document/index.html"
  tasks:
    - name: Test1
      ansible.builtin.debug:
        msg: "match pattern 1"
      when: url is match("nobreak")
    - name: Test1-1
      ansible.builtin.debug:
        msg: "match pattern 1"
      when: url is search("nobreak")
    - name: Test2
      ansible.builtin.debug:
        msg: "match pattern 2"
      when: url is match(".*nobreak")
    - name: Test3
      ansible.builtin.debug:
        msg: "match pattern 3"
      when: url is match("http://[a-z]*.nobreak")
    - name: Test4
      ansible.builtin.debug:
        msg: "match pattern 4"
      when: url is match("http://.*html")

```

- 문자열 시작에서 매칭되지 않는 경우 skip 되는 것을 확인할 수 있다.  
```
$ ansible-playbook ./playbooks/condision.yaml 

PLAY [Condition test] ***************************************************************************************

TASK [Test1] ****************************************************************************************
skipping: [ansi-node1]

TASK [Test1-1] ****************************************************************************************
ok: [ansi-node1] => {
    "msg": "match pattern 1"
}

TASK [Test2] ****************************************************************************************
ok: [ansi-node1] => {
    "msg": "match pattern 2"
}

TASK [Test3] ****************************************************************************************
ok: [ansi-node1] => {
    "msg": "match pattern 3"
}

TASK [Test4] ****************************************************************************************
ok: [ansi-node1] => {
    "msg": "match pattern 4"
}

PLAY RECAP ****************************************************************************************
ansi-node1                 : ok=4    changed=0    unreachable=0    failed=0    skipped=1    rescued=0    ignored=0 
```

### 버전 비교 테스트
- version을 사용하고 가능한 연산자들은 다음과 같다. 
	- `<, lt, <=, le, >, gt, >=, ge, ==, =, eq, !=, <>, ne`
- version_type 
```yaml
- name: Condition test
  hosts: ansi-node1
  gather_facts: false
  vars:
    my_version: 1.2.1
  tasks:
    - name: Test1
      ansible.builtin.debug:
        msg: "version is greater than 1.0.5"
      when: my_version is version('1.0.5', '>')
    - name: Test2
      ansible.builtin.debug:
        msg: "version is less than 1.0.0"
      when: my_version is version('1.0.0', 'lt')

```

```
$ ansible-playbook ./playbooks/condition.yaml 

PLAY [Condition test] ****************************************************************************************

TASK [Test1] ****************************************************************************************
ok: [ansi-node1] => {
    "msg": "version is greater than 1.0.5"
}

TASK [Test2] ****************************************************************************************
skipping: [ansi-node1]

PLAY RECAP ****************************************************************************************
ansi-node1                 : ok=1    changed=0    unreachable=0    failed=0    skipped=1    rescued=0    ignored=0 
```

### 경로 테스트
- 컨트롤러에 있는 경로를 체크하는데 사용할 수 있다. 
```yaml
- name: path
  hosts: ansi-node1
  gather_facts: no
  vars:
    path_list:
      - /etc/passwd
      - /etc/
      - /home/vagrant/
      - /home/vagrant/filea
      - /etc/
      - /
  tasks:
  - debug:
      msg: "{{ item }} is file"
    loop: "{{ path_list }}"
    when: item is file

  - debug:
      msg: "{{ item }} is dir"
    loop: "{{ path_list }}"
    when: item is directory

  - debug:
      msg: "{{ item }} is exists"
    loop: "{{ path_list }}"
    when: item is exists

  - debug:
      msg: "{{ item }} is mount"
    loop: "{{ path_list }}"
    when: item is mount
```
- 관리 노드 파일을 확인하는 경우는 stat을 활용한다.
```yaml
- name: Condition test
  hosts: ansi-node1
  tasks:
    - name: Get file info using stat
      ansible.builtin.stat:
        path: /home/vagrant/testa
      register: rt
    - name: Create file if it does not exist
      ansible.builtin.file:
        path: /home/vagrant/testa
        state: touch
        mode: 0644
        owner: vagrant
      when: not rt.stat.exists

```

### 작업 상태 테스트
```yaml
- name: Condition test
  hosts: ansi-node1
  tasks:
    - name: Excute shell
      ansible.builtin.shell:
        cmd: ls
        executable: /bin/bash/foo
      register: result
      ignore_errors: true
    - name: Test1
      ansible.builtin.debug:
        msg: "it failed"
      when: result is failed

    - name: Test2
      ansible.builtin.debug:
        msg: "it changed"
      when: result is changed
    - name: Test3
      ansible.builtin.debug:
        msg: "it succeeded in Ansible >= 2.1"
      when: result is succeeded
    - name: Test4
      ansible.builtin.debug:
        msg: "it succeeded"
      when: result is success
    - name: Test5
      ansible.builtin.debug:
        msg: "it was skipped"
      when: result is skipped

```


```
$ ansible-playbook ./playbooks/condition.yaml 
[WARNING]: Skipping plugin (/home/vagrant/.local/lib/python3.9/site-packages/ansible/plugins/connection/winrm.py), cannot
load: invalid syntax (spawnbase.py, line 224)

PLAY [Condition test] ****************************************************************************************

TASK [Gathering Facts] ****************************************************************************************
ok: [ansi-node1]

TASK [shell] ****************************************************************************************
fatal: [ansi-node1]: FAILED! => {"changed": true, "cmd": "/usr/bin/foo", "delta": "0:00:00.002201", "end": "2023-02-03 05:48:43.825925", "msg": "non-zero return code", "rc": 127, "start": "2023-02-03 05:48:43.823724", "stderr": "/bin/sh: 1: /usr/bin/foo: not found", "stderr_lines": ["/bin/sh: 1: /usr/bin/foo: not found"], "stdout": "", "stdout_lines": []}
...ignoring

TASK [debug] ****************************************************************************************
ok: [ansi-node1] => {
    "msg": "it failed"
}

TASK [debug] ****************************************************************************************
ok: [ansi-node1] => {
    "msg": "it changed"
}

TASK [debug] ****************************************************************************************
skipping: [ansi-node1]

TASK [debug] ****************************************************************************************
skipping: [ansi-node1]

TASK [debug] ****************************************************************************************
skipping: [ansi-node1]

PLAY RECAP ****************************************************************************************
ansi-node1                 : ok=4    changed=1    unreachable=0    failed=0    skipped=3    rescued=0    ignored=1
```

## 조건문 작업 구문
- 작업 또는 플레이북을 실행하면 ansible은 호스트에 대한 테스트를 평가한다.
- 테스트를 통과한 모든 호스트에서 ansible은 해당 작업을 실행한다.
- SELinux가 비활성화된 시스템에서만 해당 작업이 실행되는 예시
```yaml
- name: Condition test
  hosts: ABC
  tasks:
    - name: Echo
      ansible.builtin.command:
        cmd: "echo 'selinux disabled'"
      when: ansible_selinux.status == "disabled"

```

```
$ ansible-playbook ./playbooks/condition.yaml -v
Using /home/vagrant/ansitest/ansible.cfg as config file


PLAY [Condition test] ****************************************************************************************

TASK [Gathering Facts] ****************************************************************************************
ok: [ansi-node2]
ok: [ansi-node3]
ok: [ansi-node1]

TASK [Echo] ****************************************************************************************
changed: [ansi-node2] => {"changed": true, "cmd": ["echo", "selinux disabled"], "delta": "0:00:00.005167", "end": "2023-02-03 05:55:10.427609", "msg": "", "rc": 0, "start": "2023-02-03 05:55:10.422442", "stderr": "", "stderr_lines": [], "stdout": "selinux disabled", "stdout_lines": ["selinux disabled"]}
changed: [ansi-node3] => {"changed": true, "cmd": ["echo", "selinux disabled"], "delta": "0:00:00.005883", "end": "2023-02-03 05:55:10.428302", "msg": "", "rc": 0, "start": "2023-02-03 05:55:10.422419", "stderr": "", "stderr_lines": [], "stdout": "selinux disabled", "stdout_lines": ["selinux disabled"]}
changed: [ansi-node1] => {"changed": true, "cmd": ["echo", "selinux disabled"], "delta": "0:00:00.002267", "end": "2023-02-03 05:55:10.425777", "msg": "", "rc": 0, "start": "2023-02-03 05:55:10.423510", "stderr": "", "stderr_lines": [], "stdout": "selinux disabled", "stdout_lines": ["selinux disabled"]}

PLAY RECAP ****************************************************************************************
ansi-node1                 : ok=2    changed=1    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0   
ansi-node2                 : ok=2    changed=1    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0   
ansi-node3                 : ok=2    changed=1    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0
```

## fact 변수 기반 조건문
- fact를 기반으로 작업을 실행하거나 건너뛰고 싶은 경우가 있다.
- fact는 IP 주소, 운영 체제, 파일 시스템 상태 등을 포함한 개별 호스트의 속성
- fact에 기반한 조건문 사용 경우
	- 운영 체제가 특정 버전인 경우에만 특정 패키지를 설치
	- 내부 IP 주소가 있는 호스트에서 방화벽 구성 스킵
	- 파일 시스템이 가득 차면 정리 작업을 수행
- 특정 조건인 경우 실행
```yaml
- name: Condition test
  hosts: ABC
  tasks:
    - name: Shut down Debian flavored systems
      ansible.builtin.command: /sbin/shutdown -t now
      when: ansible_facts['os_family'] == "Debian"

```
- fact 내용이 목록 변수에 해당 유무에 따른 실행
```yaml
- name: Condition test
  hosts: ABC
  vars:
    supported_distros:
      - Centos
      - Fedora
  tasks:
    - name: Install httpd using yum, where supported
      ansible.builtin.yum:
        name: httpd
        state: present
      when: ansible_distribution in supported_distros

```

## 복수 조건에 따른 실행
- 조건을 리스트로 표현하면 and 연산이 적용된다.
```yaml
- name: Condition test
  hosts: ABC
  tasks:
    - name: Shut down CentOS 6 systems
      ansible.builtin.command: /sbin/shutdown -t now
      when:
        - ansible_facts['distribution'] == "CentOS"
        - ansible_facts['distribution_major_version'] == "6"

```
- 괄호로 연산 우선 순위를 지정할 수도 있다.
```yaml
- name: Condition test
  hosts: ABC
  tasks:
    - name: Shut down CentOS 6 and Debian 7 systems
      ansible.builtin.command: /sbin/shutdown -t now
      when:
        (ansible_facts['distribution'] == "CentOS" and ansible_facts['distribution_major_version'] == "6")
        or
        (ansible_facts['distribution'] == "Debian" and ansible_facts['distribution_major_version'] == "7")

```

## register 변수에 따른 조건
- 플레이북에서 이전 작업의 결과에 따라 작업을 실행하거나 건너뛰고 싶을 때 사용
- register 변수에는 항상 변수를 생성한 작업의 상태와 작업이 생성한 모든 출력이 포함된다.
- register는 템플릿과 액션 라인 뿐만 아니라 조건문에서도 사용 가능하다.

- ls로 확인 시, 경로에 아무것도 없는 경우 생성
```yaml
- name: Condition test
  hosts: ansi-node2
  tasks:
    - name: List root path
      ansible.builtin.command:
        cmd: ls
      register: ls_result
    - name: Print when emtpy
      ansible.builtin.debug:
        msg: "/home/vagrant is emtpy"
      when: ls_result.stdout == ''
    - name: Print when not empty
      ansible.builtin.debug:
        msg: "/home/vagrant is not emtpy"
      when: ls_result.stdout != ''
    - name: Create file
      ansible.builtin.file:
        state: touch
        dest: /home/vagrant/testfile
        mode: 0664
      when: ls_result.stdout == ''

```

```
vagrant@ansi-master1:~/ansitest
$ ansible-playbook ./playbooks/condition.yaml
[WARNING]: Skipping plugin (/home/vagrant/.local/lib/python3.9/site-packages/ansible/plugins/connection/winrm.py), cannot load: invalid syntax (spawnbase.py, line 224)

PLAY [Condition test] ****************************************************************************************

TASK [Gathering Facts] ****************************************************************************************
ok: [ansi-node2]
ok: [ansi-node1]

TASK [List root path] ****************************************************************************************
changed: [ansi-node2]
changed: [ansi-node1]

TASK [Print when emtpy] ****************************************************************************************
skipping: [ansi-node1]
ok: [ansi-node2] => {
    "msg": "/home/vagrant is emtpy"
}

TASK [Print when not empty] ****************************************************************************************
ok: [ansi-node1] => {
    "msg": "/home/vagrant is not emtpy"
}
skipping: [ansi-node2]

TASK [Create file] ****************************************************************************************
skipping: [ansi-node1]
changed: [ansi-node2]

PLAY RECAP ****************************************************************************************
ansi-node1                 : ok=3    changed=1    unreachable=0    failed=0    skipped=2    rescued=0    ignored=0   
ansi-node2                 : ok=4    changed=2    unreachable=0    failed=0    skipped=1    rescued=0    ignored=0  
```

- 변수가 목록이 아닌 경우 split() 을 사용하여 목록으로 변환 가능
```yaml
- name: Condition test
  hosts: ansi-node1
  tasks:
    - ansible.builtin.command:
        cmd: ls -l
      register: ls_result
    - name: Print stdout
      ansible.builtin.debug:
        msg: "{{ ls_result.stdout }}"
    - name: Print stdout_lines
      ansible.builtin.debug:
        msg: "{{ ls_result.stdout_lines }}"
    - name: Print stdout using loop
      ansible.builtin.debug:
        msg: "{{ item }}"
      loop:
        "{{ ls_result.stdout.split('\n') }}"

```

```
$ ansible-playbook ./playbooks/condition.yaml
[WARNING]: Skipping plugin (/home/vagrant/.local/lib/python3.9/site-packages/ansible/plugins/connection/winrm.py), cannot load: invalid syntax (spawnbase.py, line 224)

PLAY [Condition test] ****************************************************************************************

TASK [Gathering Facts] ****************************************************************************************
ok: [ansi-node1]

TASK [ansible.builtin.command] ****************************************************************************************
changed: [ansi-node1]

TASK [Print stdout] ****************************************************************************************
ok: [ansi-node1] => {
    "msg": "total 0\n-rw-rw-r-- 1 vagrant vagrant 0 Feb  3 05:40 file1\n-rw-rw-r-- 1 vagrant vagrant 0 Feb  3 05:42 file2"
}

TASK [Print stdout_lines] ****************************************************************************************
ok: [ansi-node1] => {
    "msg": [
        "total 0",
        "-rw-rw-r-- 1 vagrant vagrant 0 Feb  3 05:40 file1",
        "-rw-rw-r-- 1 vagrant vagrant 0 Feb  3 05:42 file2"
    ]
}

TASK [Print stdout using loop] ****************************************************************************************
ok: [ansi-node1] => (item=total 0) => {
    "msg": "total 0"
}
ok: [ansi-node1] => (item=-rw-rw-r-- 1 vagrant vagrant 0 Feb  3 05:40 file1) => {
    "msg": "-rw-rw-r-- 1 vagrant vagrant 0 Feb  3 05:40 file1"
}
ok: [ansi-node1] => (item=-rw-rw-r-- 1 vagrant vagrant 0 Feb  3 05:42 file2) => {
    "msg": "-rw-rw-r-- 1 vagrant vagrant 0 Feb  3 05:42 file2"
}

PLAY RECAP ****************************************************************************************
ansi-node1                 : ok=5    changed=1    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0  
```

## 변수 기반 조건부
- 플레이북이나 인벤토리에 정의된 변수를 기반으로 조건문을 생성
- 조건문에는 부울 입력이 필요하기 때문에 부울이 아닌 변수에 필터를 적용한다. 

```yaml
- name: Condition test
  hosts: ansi-node1
  vars:
    epic: true
    monumental: "yes"
  tasks:
    - name: Run the command if "epic" or "monumental" is true
      ansible.builtin.shell: echo "This certainly is epic!"
      when: epic or monumental | bool
    - name: Run the command if "epic" is false
      ansible.builtin.shell: echo "This certainly isn't epic!"
      when: not epic

```

```
$ ansible-playbook ./playbooks/condition.yaml -v
Using /home/vagrant/ansitest/ansible.cfg as config file
[WARNING]: Skipping plugin (/home/vagrant/.local/lib/python3.9/site-packages/ansible/plugins/connection/winrm.py), cannot load:
invalid syntax (spawnbase.py, line 224)

PLAY [Condition test] ***************************************************************************************

TASK [Gathering Facts] ****************************************************************************************
ok: [ansi-node1]

TASK [Run the command if "epic" or "monumental" is true] ****************************************************************************
changed: [ansi-node1] => {"changed": true, "cmd": "echo \"This certainly is epic!\"", "delta": "0:00:00.001941", "end": "2023-02-03 06:37:17.344183", "msg": "", "rc": 0, "start": "2023-02-03 06:37:17.342242", "stderr": "", "stderr_lines": [], "stdout": "This certainly is epic!", "stdout_lines": ["This certainly is epic!"]}

TASK [Run the command if "epic" is false] *************************************************************************************
skipping: [ansi-node1] => {"changed": false, "skip_reason": "Conditional result was False"}

PLAY RECAP ****************************************************************************************
ansi-node1                 : ok=2    changed=1    unreachable=0    failed=0    skipped=1    rescued=0    ignored=0
```

## 조건문과 반복문 결합
- when 명령문을 loop와 결합하면 각 항목에 대해 조건을 개별적으로 처리한다.
- 루프의 일부 항목에 대해서는 작업을 실행하고 다른 항목에서는 건너 뛸 수 있다.
```yaml
- name: Condition test
  hosts: ansi-node1
  vars:
    epic: true
    monumental: "yes"
  tasks:
    - name: Run with items greater than 5
      ansible.builtin.command: echo {{ item }}
      loop: [0, 2, 4, 6, 8, 10]
      when: item > 5

```

```yaml
- name: Condition test
  hosts: ansi-node1
  vars:
    user_info:
      - name: Ha
        age: 29
      - name: Lee
        age: 27
      - name: Kim
        age: 28
  tasks:
    - name: Run with ages older than equal 28
      ansible.builtin.command: echo {{ item.name }}
      loop: "{{ user_info }}"
      when: item.age >= 28

```

## Stat 모듈
- Ansible stat 모듈을 사용하여 파일의 세부 정보를 확인할 수 있다.
- stat 모듈은 linux stat 명령을 사용하여 작업에 지정된 경로를 확인한다. 

```yaml
- hosts: ansi-node1
  tasks:
  - stat:
      path: /etc/passwd
    register: result

  - ansible.builtin.debug:
      msg: "{{ result }}"

  - debug:
      msg: "Ansible When File Exists Example."
    when: result.stat.exists
```


```
$ ansible-playbook ./playbooks/condition.yaml -v
Using /home/vagrant/ansitest/ansible.cfg as config file
[WARNING]: Skipping plugin (/home/vagrant/.local/lib/python3.9/site-packages/ansible/plugins/connection/winrm.py), cannot load: invalid syntax (spawnbase.py, line 224)

PLAY [ansi-node1] ****************************************************************************************

TASK [Gathering Facts] ****************************************************************************************
ok: [ansi-node1]

TASK [stat] ****************************************************************************************
ok: [ansi-node1] => {"changed": false, "stat": {"atime": 1675387304.003001, "attr_flags": "e", "attributes": ["extents"], "block_size": 4096, "blocks": 8, "charset": "us-ascii", "checksum": "5355a6bebb212c3a20129de68e40b56ff980dc2f", "ctime": 1675047100.968, "dev": 2049, "device_type": 0, "executable": false, "exists": true, "gid": 0, "gr_name": "root", "inode": 68100, "isblk": false, "ischr": false, "isdir": false, "isfifo": false, "isgid": false, "islnk": false, "isreg": true, "issock": false, "isuid": false, "mimetype": "text/plain", "mode": "0644", "mtime": 1675047100.956, "nlink": 1, "path": "/etc/passwd", "pw_name": "root", "readable": true, "rgrp": true, "roth": true, "rusr": true, "size": 1609, "uid": 0, "version": "1346065541", "wgrp": false, "woth": false, "writeable": true, "wusr": true, "xgrp": false, "xoth": false, "xusr": false}}

TASK [ansible.builtin.debug] ****************************************************************************************
ok: [ansi-node1] => {
    "msg": {
        "changed": false,
        "failed": false,
        "stat": {
            "atime": 1675387304.003001,
            "attr_flags": "e",
            "attributes": [
                "extents"
            ],
            "block_size": 4096,
            "blocks": 8,
            "charset": "us-ascii",
            "checksum": "5355a6bebb212c3a20129de68e40b56ff980dc2f",
            "ctime": 1675047100.968,
            "dev": 2049,
            "device_type": 0,
            "executable": false,
            "exists": true,
            "gid": 0,
            "gr_name": "root",
            "inode": 68100,
            "isblk": false,
            "ischr": false,
            "isdir": false,
            "isfifo": false,
            "isgid": false,
            "islnk": false,
            "isreg": true,
            "issock": false,
            "isuid": false,
            "mimetype": "text/plain",
            "mode": "0644",
            "mtime": 1675047100.956,
            "nlink": 1,
            "path": "/etc/passwd",
            "pw_name": "root",
            "readable": true,
            "rgrp": true,
            "roth": true,
            "rusr": true,
            "size": 1609,
            "uid": 0,
            "version": "1346065541",
            "wgrp": false,
            "woth": false,
            "writeable": true,
            "wusr": true,
            "xgrp": false,
            "xoth": false,
            "xusr": false
        }
    }
}

TASK [debug] ****************************************************************************************
ok: [ansi-node1] => {
    "msg": "Ansible When File Exists Example."
}

PLAY RECAP ****************************************************************************************
ansi-node1                 : ok=4    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0 
```

# 템플릿
- ansible에서 파일을 관리하는 가장 강력한 방법은 템플릿을 만드는 것이다.
- 템플릿을 사용하면 가능한 변수와 팩트를 사용하여 파일이 배포될 때 관리 호스트에 대해 자동으로 사용자 정의되는 템플릿 구성 파일을 작성할 수 있다.
## Jinja2
- Python의 매우 강력하고 고급 템플릿 언어
- 매우 빠르고 안정적이며 동적 데이터를 생성하는데 널리 사용
- 텍스트 기반 템플릿 언어이므로 모든 마크업과 소스 코드를 생성하는 데 사용할 수 있음

### 특징
- 제어 구조(루프 및 조건문)
- 템플릿 상송
- 사용자 정의 필터 지원
- 풍부한 내장 필터 세트
- 구성 가능한 구문

### 기호
- `{{ ... }}`
	- 이중 중괄호는 템플릿 파일에서 널리 사용되는 태그이며 변수를 포함하고 궁극적으로 코드 실행 중에 값을 인쇄하는 데 사용
- `{%...%}`
	- 루프 및 if-else 문과 같은 제어 문에 주로 사용
- `{#....#}`
	- 작업을 설명하는 주석

### 예시
```jinja2
{# template1.j2 #}
{{ site_name }}
This node is {{ ansible_hostname }}
```

```yaml
- name: Template test
  hosts: ansi-node1
  vars:
    site_name: "Hello World!"
  tasks:
    - name: Create index.html using Jinja2
      ansible.builtin.template:
        src: ../template1.j2
        dest: /var/www/html/index.html

```

```
$ curl 192.168.56.21
Hello World!
This node is ansi-node1
```

```jinja2
{# template1.j2 #}
[test1]
hostname={{ ansible_hostname }}
distribution={{ ansible_distribution }}
major_version={{ ansible_distribution_major_version }}
ipv4={{ ansible_facts.all_ipv4_addresses[0] }}

```

```yaml
- name: Template test
  hosts: ansi-node1
  tasks:
    - name: Create Directory
      ansible.builtin.file:
        dest: /etc/ansible/facts.d
        state: directory
        recurse: true
    - name: Create Fact file using template
      ansible.builtin.template:
        src: ../template1.j2
        dest: /etc/ansible/facts.d/test.fact
    - name: Reload setup
      ansible.builtin.setup:
    - name: Print local fact
      ansible.builtin.debug:
        msg: "{{ ansible_local }}"

```

```
$ ansible-playbook ./playbooks/condition.yaml 

PLAY [Template test] *******************************************************************************

TASK [Gathering Facts] *****************************************************************************
ok: [ansi-node1]

TASK [Create Directory] ****************************************************************************
changed: [ansi-node1]

TASK [Create Fact file using template] *************************************************************
changed: [ansi-node1]

TASK [Reload setup] ********************************************************************************
ok: [ansi-node1]

TASK [Print local fact] ****************************************************************************
ok: [ansi-node1] => {
    "msg": {
        "test": {
            "test1": {
                "distribution": "Ubuntu",
                "hostname": "ansi-node1",
                "ipv4": "192.168.56.21",
                "major_version": "18"
            }
        }
    }
}

PLAY RECAP ****************************************************************************************
ansi-node1                 : ok=5    changed=2    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0 
```

#### 반복문 사용
```jinja2
{# template1.j2 #}
{% for host in groups['all'] %}
{{ hostvars[host].ansible_facts.default_ipv4.address}} {{ hostvars[host].ansible_facts.fqdn}} {{ hostvars[host].ansible_facts.hostname }}
{% endfor %}
```

```yaml
- name: Template test
  hosts: all
  tasks:
    - name: Create file using template
      ansible.builtin.template:
        src: ../template1.j2
        dest: /test.text
```

```
$ cat /test.text 
10.0.2.15 ansi-master1 ansi-master1
10.0.2.15 ansi-node1 ansi-node1
10.0.2.15 ansi-node3 ansi-node3
10.0.2.15 ansi-node2 ansi-node2
```

# 핸들러
- 핸들러는 작업을 실행하고 시스템의 변경이 있을 때에 별도의 작업을 호출하고 실행하는 작업이다. 
- 주로 핸들러를 사용하는 것은 시스템에서 특정 서비스의 구성파일이 변경된 경우 서비스를 재시작하는 경우에 사용한다.
- Ansible 모듈은 멱등이 되도록 설계되어 있기 때문에 제어노드가 원하는 상태가 되도록 하기 위해 플레이북과 해당 작업을 변경하지 않아도 되는 경우 적절하게 작성된  플레이북에서 제어노드를 변경하지 않고 플레이북과 해당 작업을 여러번 실행 가능
- 핸들러는 작업에 변경이 있고 반드시 알림이 있을 때만 실행되는 작업이다.

## 주의 사항
- 핸들러는 항상 플레이의 handler 섹션에서 지정한 순서대로 실행된다.
	- 작업의 notify 문에 따라 나열된 순서나 작업이 핸들러에 통지하는 순서대로 실행되지 않는다.
- 핸들러는 일반적으로 플레이에서 다른 모든 작업이 완료된 후에 실행된다.
	- 플레이북의 tasks 부분의 작업에서 호출한 핸들러는 tasks 아래에 있는 모든 작업이 처리될 때 까지 실행되지 않는다.
- 핸들러 이름은 글로벌 네임스페이스에 있기 때문에, 두 핸들러에 같은 이름이 지정되면 한 핸들러만 실행된다.
- 둘 이상의 작업에서 한 핸들러에게 알리는 경우 해당 핸들러가 한 번만 실행된다. 
- 핸들러는 작업이 제어노드를 변경할 때 추가 조치를 수행하기 위한 것으로 정상적인 작업을 대체하기 위해서 사용해서는 안된다.

```yaml
- name: Handler Test
  hosts: ansi-node1
  tasks:
    - name: Change file content
      ansible.builtin.copy:
        content: "copy content"
        dest: /var/www/html/index.html
      notify: Restart apache2
  handlers:
    - name: Restart apache2
      ansible.builtin.service:
        name: apache2
        state: restarted

```

```
$ ansible-playbook ./playbooks/handler.yaml 

PLAY [Handler Test] ********************************************************************************

TASK [Gathering Facts] *****************************************************************************
ok: [ansi-node1]

TASK [Change file content] *************************************************************************
changed: [ansi-node1]

RUNNING HANDLER [Restart apache2] ******************************************************************
changed: [ansi-node1]

PLAY RECAP ****************************************************************************************
ansi-node1                 : ok=3    changed=2    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0
```

- 한 번 더 실행하는 경우 파일의 변경이 일어나지 않기 때문에 핸들러가 수행되지 않는다. 

```
$ ansible-playbook ./playbooks/handler.yaml 

PLAY [Handler Test] ********************************************************************************

TASK [Gathering Facts] *****************************************************************************
ok: [ansi-node1]

TASK [Change file content] *************************************************************************
ok: [ansi-node1]

PLAY RECAP ****************************************************************************************
ansi-node1                 : ok=2    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0  
```

- notify에 리스트를 넘겨줄 수도 있다.

```yaml
- name: Handler Test
  hosts: ansi-node1
  tasks:
    - name: Change file content
      ansible.builtin.template:
        src: ../template1.j2
        dest: /var/www/html/index.html
      notify:
        - Restart apache2
        - Restart firewalld
  handlers:
    - name: Restart apache2
      ansible.builtin.service:
        name: apache2
        state: restarted
    - name: Restart firewalld
      ansible.builtin.service:
        name: firewalld
        state: restarted

```

- 혹은 핸들러가 notify를 listen 하도록 할 수도 있다.

```yaml
- name: Handler Test
  hosts: ansi-node1
  tasks:
    - name: Change file content
      ansible.builtin.template:
        src: ../template1.j2
        dest: /var/www/html/index.html
      notify: Restart service
  handlers:
    - name: Restart apache2
      ansible.builtin.service:
        name: apache2
        state: restarted
      listen: Restart service

    - name: Restart firewalld
      ansible.builtin.service:
        name: ufw
        state: restarted
      listen: Restart service

```

# 위임
## 위임(작업 실행 위치 제어)
include
add_host
debug
- 하나의 플레이를 실행할 때 작업들은 별도로 설정하지 않는 한 호스트에서 실행된다.
- 위임(delegation)은 호스트에 정의 되어 있는 여러 작업들 중에 일부분의 작업을 다른 호스트에서 실행하게 한다.
- 위임을 사용하면 상호 관련된 환경을 정확하고 효율적으로 관리할 수 있다.
- 다른 호스트를 참조하여 한 호스트에서 작업을 수행하려면 작업에서 delefate_to 키워드를 사용
- 이는 로드 밸런싱된 풀에서 노드를 관리하거나 중단 기간을 제어하는 데 이상적이다.
- 직렬 키워드와 함께 위임을 사용하여 한 번에 실행되는 호스트 수를 제어할 수 있다.

```yaml
- name: Delegation test
  hosts: ansi-node1
  tasks:
  - ansible.builtin.command:
      cmd: hostname
    register: hostname_result1
  - ansible.builtin.debug:
      msg: "{{ hostname_result1.stdout }}"

  - ansible.builtin.command:
      cmd: hostname
    register: hostname_result2
    delegate_to: ansi-node2
  - ansible.builtin.debug:
      msg: "{{ hostname_result2.stdout }}"
```

```
$ ansible-playbook ./playbooks/delegation.yaml 

PLAY [Delegation test] *****************************************************************************

TASK [Gathering Facts] *****************************************************************************
ok: [ansi-node1]

TASK [ansible.builtin.command] *********************************************************************
changed: [ansi-node1]

TASK [ansible.builtin.debug] ***********************************************************************
ok: [ansi-node1] => {
    "msg": "ansi-node1"
}

TASK [ansible.builtin.command] *********************************************************************
changed: [ansi-node1 -> ansi-node2]

TASK [ansible.builtin.debug] ***********************************************************************
ok: [ansi-node1] => {
    "msg": "ansi-node2"
}

PLAY RECAP ****************************************************************************************
ansi-node1                 : ok=5    changed=2    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0   
```

## 팩트 수집 위임
- 위임된 작업에 의해 수집된 모든 fact는 기본적으로 fact를 생성한 호스트(위임된 호스트)가 아닌 인벤토리 \_호스트  이름(현재 호스트)에 할당
- 수집된 fact를 현재 호스트 대신 위임된 호스트에 할당하려면 delegate_facts:true로 설정

```yaml
- name: Delegation test
  hosts: ansi-node1
  gather_facts: false
  tasks:
    - ansible.builtin.setup:
      delegate_to: ansi-node2
      delegate_facts: true

- name: Test
  hosts: ansi-node2
  gather_facts: false
  tasks:
    - ansible.builtin.debug:
        msg: "{{ ansible_hostname }}"

```

# 블록
## 블록의 개념
- 블록은 플레이에 하나 이상의 작업을 논리적으로 그룹화할 수 있다.
	- 그룹화의 장접은 대부분 단일 작업에서 적용했던 플레이북 키워드를 블록 수준에서 적용할 수 있다.
	- 조건문, 권한상승 등 블록에 구성할 수 있다.
	- 블록에 구성된 키워드는 블록에 속한 모든 작업에 공통적으로 적용된다.
	- 반복문은 블록에 적용 불가
- 예외 처리 기능을 제공한다.
	- 블록의 하나 이상의 작업이 실패한 경우, 실패한 작업에 대응(롤백, 오류 수정 등)하는 작업을 지정할 수 있다.

## 작업의 그룹화
- 블록의 모든 작업은 블록 수준에서 적용된 지시문을 상속한다.
- 단일 작업에 적용할 수 있는 대부분(반복문 제외)은 블록 수준에서 적용할 수 있으므로 블록을 사용하면 작업에 공통적인 데이터나 지시문을 훨씬 쉽게 설정 가능하다.
- 지시문은 블록 자체에 영향을 미치지 않으며 블록으로 묶인 작업에 의해서만 상속된다.
	- when 문은 블록 자체가 아니라 블록 내의 작업에 적용된다.
	- when 조건은 ansible이 블록의 세 가지 작업을 각각 실행하기 전에 평가한다.
- ingnore_errors:yes로 인해 일부 작업이 실패하더라도 ansible이 플레이북을 계속 실행한다. 

```yaml
- name: Block Test
  hosts: ABC
  tasks:
    - name: Block Session
      block:
        - name: Print1
          ansible.builtin.debug:
            msg: "Block Messege 1"
          when: ansible_hostname == "ansi-node1"
        - name: Print2
          ansible.builtin.debug:
            msg: "Block Messege 2"
          when: ansible_hostname == "ansi-node2"
      when: ansible_hostname in ["ansi-node1", "ansi-node2"]

```

```
$ ansible-playbook ./playbooks/block.yaml 

PLAY [Block Test] **********************************************************************************

TASK [Gathering Facts] *****************************************************************************
ok: [ansi-node3]
ok: [ansi-node2]
ok: [ansi-node1]

TASK [Print1] *************************************************************************************
ok: [ansi-node1] => {
    "msg": "Block Messege 1"
}
skipping: [ansi-node2]
skipping: [ansi-node3]

TASK [Print2] **************************************************************************************
skipping: [ansi-node1]
ok: [ansi-node2] => {
    "msg": "Block Messege 2"
}
skipping: [ansi-node3]

PLAY RECAP **************************************************************************************
ansi-node1                 : ok=2    changed=0    unreachable=0    failed=0    skipped=1    rescued=0    ignored=0   
ansi-node2                 : ok=2    changed=0    unreachable=0    failed=0    skipped=1    rescued=0    ignored=0   
ansi-node3                 : ok=1    changed=0    unreachable=0    failed=0    skipped=2    rescued=0    ignored=0 
```

## 오류 처리
- rescue 및 always 섹션이 있는 블록을 사용하여 ansible이 작업 오류에 응답하는 방식을 제어할 수 있다.
- 복구 블록은 블록의 이전 작업이 실패할 때 실행할 작업을 지정한다.
	- 접근 방식은 많은 프로그래밍 언어의 예외 처리와 유사
- ansible은 작업이 실패 상태를 반환한 후에만 복구 블록을 실행
	- 잘못된 작업 정의와 연결할 수 없는 호스트는 복구 블록을 트리거 하지 않는다.
- 블록의 작업 중 하나라도 실패가 있으면, Rescue 섹션의 작업이 실행된다.
- 블록에서 오류가 발생하고 rescue 작업이 성공하면 ansible은 실행에 대한 원래 작업의 실패 상태를 되돌리고 원래 작업이 성공한 것 처럼 재생을 계속 실행한다. 

```yaml
- name: Block Test
  hosts: ansi-node1
  tasks:
    - name: Block Session
      block:
        - name: Print1
          ansible.builtin.debug:
            msg: "Block Messege 1"
        - name: Command
          ansible.builtin.command:
            cmd: failed
        - name: Print2
          ansible.builtin.debug:
            msg: "Block Messege 2"
      rescue:
        - name: Print3
          ansible.builtin.debug:
            msg: "Rescue Block Messege 1"
      always:
        - name: Print4
          ansible.builtin.debug:
            msg: "Always Block Messege 1"

```

```
$ ansible-playbook ./playbooks/block.yaml 
[WARNING]: Skipping plugin (/home/vagrant/.local/lib/python3.9/site-
packages/ansible/plugins/connection/winrm.py), cannot load: invalid syntax (spawnbase.py, line 224)

PLAY [Block Test] **********************************************************************************

TASK [Gathering Facts] *****************************************************************************
ok: [ansi-node1]

TASK [Print1] **************************************************************************************
ok: [ansi-node1] => {
    "msg": "Block Messege 1"
}

TASK [Command] *************************************************************************************
fatal: [ansi-node1]: FAILED! => {"changed": false, "cmd": "failed", "msg": "[Errno 2] No such file or directory: b'failed': b'failed'", "rc": 2, "stderr": "", "stderr_lines": [], "stdout": "", "stdout_lines": []}

TASK [Print3] **************************************************************************************
ok: [ansi-node1] => {
    "msg": "Rescue Block Messege 1"
}

TASK [Print4] **************************************************************************************
ok: [ansi-node1] => {
    "msg": "Always Block Messege 1"
}

PLAY RECAP ****************************************************************************************
ansi-node1                 : ok=4    changed=0    unreachable=0    failed=0    skipped=0    rescued=1    ignored=0
```

# 태그
## 태그
- 많은 작업이 있는 플레이북의 경우 플레이북 전체를 실행하는 대신 특정 일부분 만 실행하는 것이 유용할 수 있다.
- 태그로 특정 작업만 실행하거나, 특정 작업을 실행하지 않을 수 있다.
- 태그는 플레이, 블록, 역할, 작업에 설정하고 플레이북 실행 시 태그를 선택한다.

```yaml
- name: Tag Test
  hosts: ansi-node1
  gather_facts: false
  tasks:
    - name: Block1
      block:
        - name: Task 1-1
          ansible.builtin.debug:
            msg: task 1-1
          tags: task1
        - name: Task 1-2
          ansible.builtin.debug:
            msg: task 1-2
          tags: task1

        - name: Task 2-1
          ansible.builtin.debug:
            msg: task 2-1
          tags: task2
        - name: Task 1-2
          ansible.builtin.debug:
            msg: task 2-2
          tags: task2
      tags: block1
    - name: Task 3
      ansible.builtin.debug:
        msg: task 3
      tags: task3
- name: Play2
  hosts: ansi-node2
  gather_facts: false
  tasks:
    - name: Task 4
      ansible.builtin.debug:
        msg: task 4
      tags: task4
- name: Play3
  hosts: ansi-node3
  gather_facts: false
  tasks:
    - name: Untagged Task
      ansible.builtin.debug:
        msg: untagged task

```

### ansible-playbook 명령의 태그 관련 옵션
- --tags all: 모든 작업 실행(기본 옵션)
- --tags \[tag1, tag2]: tag1 및 tag2 태그가 있는 작업 만 실행
- --skip-tags \[tag3, tag4]: tag3 및 tag4 태그가 있는 작업 건너뛰기
- --tags tagged: 태그가 설정된 작업 만 실행
- --tags untagged: 태그가 없는 작업 만 실행
