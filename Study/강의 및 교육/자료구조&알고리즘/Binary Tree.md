# Binary Tree
- 자식 노드를 2개까지만 가지는 트리
- 이진 검색 트리
- 힙트리

## 구현
```go
type TreeNode[T any] struct {
	Value T
	Left *TreeNode[T]
	Right *TreeNode[T]
}
```

- 이진트리 패키지 만들기
- drawtree를 별도 패키지로 분리
- interface에 의존하도록 변경
- 바이너리 트리를 drawtree 패키지를 이용해서 그리기
- interface를 사용하는 경우 인스턴스를 생성하게 되면 해당 값에 nil이 들어가더라도 그 인스턴스의 값이 nil이 되는 것이지 해당 interface에 대한 인스턴스는 생성되었기 때문에 그것 자체가 nil이 되지 않는다. 따라서 분기에서 nil인지 아닌지 체크를 할 때 유의할 점은 이전에 그 값을 할당하거나 넣어줄 때 값이 nil이라면 인스턴스를 넣는 것이 아니라 nil 자체를 넣어주도록 한다.

# Binary Search Tree
- 작은 값은 왼쪽, 큰 값은 오른쪽에 두는 트리이다. 

## 이진 검색 트리 성능
- 검색, 추가, 삭제 : $O(logN)$ 

## 이진 검색 트리 특징
- Sparse한 자료구조로 캐쉬 비 친화적(캐시 미스가 잘 일어남)
- 정렬 상태 유지(inorder 탐색시)
- 삽입/삭제/검색에 유리
- 대규모 데이터 처리에 유리

## 비교

| 비교          | Hash Map | Sorted Map(Array) | Sorted Map(Binary search tree) |
| ------------- | -------- | ----------------- | ------------------------------ |
| 순서 보장     | X        | O                 | O                              |
| sparse        | O        | X                 | O                              |
| 캐쉬 친화적   | X        | O                 | X                              |
| Add           | O(1)     | O(N)              | O(logN)                        |
| Remove        | O(1)     | O(N)              | O(logN)                        |
| Get           | O(1)     | O(logN)           | O(logN)                        |
| 메모리 사용량 | 많다.    | 중간              | 적다.                          |

- 순서 보장, 캐쉬 사용, 삽입 및 삭제가 많은지 혹은 순회가 많은지, 요소 개수 등 데이터의 특성에 따라서 어떤 것을 사용할지 달라지고 정답은 없다.

## 구현
- 삭제 시, 구현하는 것이 좀 복잡하다. 삭제하려는 노드의 자식 노드와 부모 노드를 사로 연결해줘야 한다. 이 때, 삭제하려는 노드에 자식 노드가 두 개 있다면 상위 노드로 올릴 노드를 결정하는 로직이 필요하다. 
	- 왼쪽 노드들 중에서 선택하는 경우 삭제하려는 노드의 왼쪽 노드들 중에서 가장 오른쪽에 있는 노드를, 오른쪽 노드들 중에서 선택하는 경우 삭제하려는 노드의 오른쪽 노드들 중에서 가장 왼쪽에 있는 노드를 상위 노드로 올려준다. 

## 단점
- 트리 불균형
	- root가 가장 작거나 가장 큰 경우, 결국 조회시 $O(N)$ 이 되므로 일반적인 경우인 $O(LogN)$ 이 될 수 없다.
- 트리 뷸균형을 해결하기 위해서 아래 트리를 사용할 수 있다.
	- AVL 트리
	- Red-Black트리
