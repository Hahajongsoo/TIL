# 클러스터 아키텍처
쿠버네티스의 목적은 애플리케이션을 컨테이너의 형태로 자동화된 방식으로 배포하는 것이다. 그래야 요구에 따라 애플리케이션의 많은 인스턴스를 쉽게 배포할 수 있고 애플리케이션끼리의 통신이 쉽게 가능하다. 
쿠버네티스 클러스터는 노드의 집합으로 이뤄져있다. 호스트 애플리케이션이 컨테이너 형태로 있는 물리 PC일 수도 있고 가상 머신일 수도 있고 온프레미스일 수도 있고 클라우드에 있을 수도 있다. 
worker node는 컨테이너를 실행하는 노드이다. master node는 어떻게 컨테이너를 실행할 지 계획하고, 어떤 노드에 실행할지 결정하고, 노드와 컨테이너에 대한 정보를 저장하고, 컨테이너들을 모니터링하는 등의 모든 컨테이너 실행 프로세스를 관리한다.  
- etcd: 쿠버네티스의 모든 정보는 고가용성의 키-값 저장소인 etcd에 저장된다. 
- kube-scheduler: 컨테이너에 할당된 리소스와 노드에서 사용 가능한 리소스를 확인하고 컨테이너를 가능한 노드에 실행한다거나 컨테이너가 실행되어야 하는 노드에만 실행한다거나 하는 일을 하는 것이 스케쥴러이다. 
- controller-manager
	- node-controller: 클러스터에 새로운 노드를 띄우는 역할을 한다. 노드를 사용할 수 없는 상황을 핸들링한다.
	- Replication-controller: replication 그룹에서 원하는 수의 컨테이너가 실행되도록 한다. 
- kube-apiserver: 쿠버네티스에서 가장 중요한 관리 구성요소이다. 클러스터 내에서 모든 작업을 오케스트레이션한다. 
-  애플리케이션이 컨테이너의 형태로 실행된다. 마스터 노드에 클러스터를 관리하는 여러 구성요소들이 컨테이너의 형태로 실행될 수 있고 클러스터의 DNS 시스템이 컨테이너로 실행될 수 있다. 따라서 컨테이너 런타임이 필요하다 그 중 하나가 도커가 될 수 있다. 
- kubelet: 클러스터의 각 노드에서 실행되는 에이전트이다. kube apiserver의 지시를 듣고 필요한대로 노드에서 컨테이너를 배포하거나 삭제한다. kube apiserver는 주기적으로 kubelet으로 부터 노드와 컨테이너의 상태를 모니터링하기 위해서 상태 보고서를 가져온다. 
- kube-proxy: 클러스터의 여러 노드들에서 실행되는 컨테이너들이 서로 통신할 수 있게 한다. 
# Docker vs ContainerD
쿠버네티스 관련 글을 보다보면 예전에는 docker, 요즘에는 containerD가 같이 언급되는 것을 볼 수 있다. 또한 `ctr`, `nerdctl`, `crictl` 등의 cli 툴도 볼 수 있었을 것이다.
## docker
컨테이너 툴 중에서 처음에는 docker만 있었다. rkt 같은 다른 도구도 있었지만 docker의 ux가 컨테이너를 사용하는 것을 매우 간단하게 만들었고 그 결과 docker가 가장 주요한 컨테이너 툴이 됐다. 그리고 나서 docker를 오케스트레이션하려고 k8s가 등장했다. k8s는 처음에는 docker를 오케스트레이션 하려고 만들어졌기 때문에 서로 강하게 연결되어 있었고 k8s는 docker로만 작동하고 다른 컨테이너 툴은 지원하지 않았다. 
이후 k8s가 컨테이너 오케스트레이터로 인기를 얻으면서 다른 컨테이너 런타임도 참여하고자 했다. 그래서 k8s는 CRI(Container Runtime Interface)를 도입했다. CRI를 통해 어떤 공급자도 OCI(Open Container Intiative)를 준수함다면 k8s의 컨테이너 런타임으로 작동할 수 있게 됐다. OCI는 이미지를 빌드하는 방법에 대한 명세인 `imagespec` 과 컨테이너 런타임 개발에 대한 표준인 `runtimespec`를 정의한다. 이러한 표준을 기반으로 누구든지 k8s와 함께 이용할 수 있는 컨테이너 런타임을 개발할 수 있었다. 
그러나 docker는 CRI 표준을 지원하기 위해 만들어지지 않았다. 그럼에도 docker는 대부분의 사용자가 사용하는 툴이었기 때문에 k8s는 CRI 외부에서 docker를 지원하기 위한 임시적인 방법인 `dockershim`을 도입했다. 다른 컨테이너 툴들은 CRI를 통해 작동하는 반면 docker는 CRI 없이 작동했다. docker는 컨테이너 런타임만 있는 것이 아니다. docker CLI, API, BUILD, VOLUMES, AUTH, SECURITY 및 runC라 불리는 컨테이너 런타임 그리고  runC를 관리하는 데몬인 Containerd가 포함되어 있다. 그런데 Containerd는 CRI 호환성이 있어서 다른 런타임 처럼 직접 작동할 수 있기 때문에 docker와 별개로 런타임으로 사용될 수 있다. 이후 dockershim을 유지하는 것은 불필요한 노력과 복잡성을 추가했기 때문에 k8s 1.24 버전부터는 dockershim을 제거하기로 했고 docker 지원도 제거되었다. 그러나 docke로 빌드된 이미지들은 컨테이너로 동작하기 위해서  OCI에 의한 표준인 `imagespec`을 따르기 때문에 k8s가 컨테이너 런타임으로 docker를 지원하지 않더라도 containerd와는 계속 동작한다. 
## ContainerD
containerd는 docker의 일부인 동시에 자체 프로젝트이며, CNCF의 gradutaed 상태이다. 따라서 containerd 단독으로 설치해서 사용할 수 있다. 
### CLI
#### ctr
containerd 를 설치하면 ctr이라는 명령 줄 도구가 함께 제공되며, 주로 containerd를 디버깅하는 데 사용된다. 기능이 제한적이고 사용자 친화적이지 않기 때문에 운영 환경에서 컨테이너를 실행하거나 관리하기 위해서 사용하지 않는다.
#### nerdctl
더 나은 대안은 nerdctl이다. containerd를 위한 docker 같은 CLI를 제공한다. 또한 암호화된 컨테이너 이미지 사용 같은  docker CLI에서 미래에 정식으로 구현될 새로운 기능에 대한 액세스를 제공한다. 또한 이미지의 lazy pulling, p2p image distribution, image 서명 및 검증, 도커에서는 사용할 수 없는 namespace 등을 제공한다. docker cli에서 실행하는 거의 모든 명령을 docker 대신 nerdctl을 사용하는 것으로 사용할 수 있다.

## crictl
crictl은 CRI 호환 컨테이너 런타임과 상호 작용하는데 사용되는 CLI이다.이는 k8s 관점에서 볼 때 일종의 상호작용이다. k8s 커뮤니티에서 개발 및 유지관리 하며 다양한 컨테이너 런타임에서 작동한다. 주로 디버깅 목적으로 사용된다. crictl로 컨테이너를 생성할 수 있지만 쉽지 않다. 컨테이너를 실행하는 것과는 거리가 멀다. 이러한 작업은 kubelet과 이뤄지는 것을 기억해야한다. kubelet은 특정한 수의 pod가 노드에 있는지 확인하는 역할을 담당한다. 따라서 crictl 도구를 사용하여 컨테이너를 생성하려고 하면 kubelet은 관련 정보를 모르기 때문에 해당 컨테이너를 삭제할 것이다. 위의 cli 툴들과 가장 주요한 차이는 파드를 알고 있다는 것이다. 따라서 파드 리스트를 확인할 수 있다. 
docker와 명령이 유사하다. 
k8s 1.24 이전의 버전에서는 dockershim이 사용되었기 때문에 기본 컨테이너 런타임 엔드포인트에 dockershim 이 포함되어 있었으나 이후 버전 부터는 그렇지 않기 때문에 해당 엔드포인트가 cri-codkerd.sock으로 대체되었다. crictl을 사용하는 경우 사용자가 수동으로 엔드포인트를 수정해야한다. 