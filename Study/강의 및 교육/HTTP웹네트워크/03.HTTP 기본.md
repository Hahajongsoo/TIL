#CS #Network #inflearn
# 모든 것이 HTTP
HyperText Transfer Protocol

HTML, TEXT, IMAGE, 음성, 영상, 파일 JSON, XML(API) 등 거의 모든 데이터 전송 가능하다. 서버간에 데이터를 주고 받을 때도 대부분 HTTP를 사용한다. TCP 프로토콜로 직접 연결하는 경우는 거의 없다.

## HTTP 역사
- HTTP/0.9 1991년: GET 메서드만 지원, HTTP 헤더X
- HTTP/1.0 1996년: 메서드, 헤더 추가
- **HTTP/1.1** 1997년: 가장 많이 사용, 우리에게 가장 중요한 버전
- HTTP/2 2015년: 성능 개선
- HTTP/3 진행중: TCP 대신에 UDP 사용, 성능 개선

## 기반 프로토콜
- TCP: HTTP/1.1, HTTP/2
- UDP: HTTP/3
- 현재 HTTP/1.1 주로 사용
- TCP는 3 way handshake , 데이터 양 등으로 빠른 속도를 낼 수 없다. UDP에서 애플리케이션 단에서 최적화를 통해 성능을 개선한 것이 HTTP/3

- 개발자 도구에서 어떤 프로토콜로 통신하는지 확인할 수 있다.

## HTTP 특징
- 클라이언트-서버 구조
- 무상태 프로토콜(스테이트리스), 비연결성
- HTTP 메시지를 사용
- 단순함, 확장 가능

# 클라이언트 서버 구조
- Request Response 구조
- 클라이언트는 서버에 요청을 보내고, 응답이 올때 까지 대기한다.
- 서버가 요청에 대한 결과를 만들어서 응답

![](images/Pasted%20image%2020230211014009.png)

엄청 단순한 구조이지만 이렇게 클라이언트와 서버를 분리하는 것이 중요하다. 비즈니스 로직과 데이터등을 서버에 밀어넣고 서버에는 UI와 UX에 집중을 한다. 이렇게 하면 서버와 클라이언트가 독립적으로 진화할 수 있게 된다. 

# 무상태 프로토콜
스테이트 리스(Stateless)
- 서버가 클라이언트의 상태를 유지하지 않는다. 
- 장점: 서버 확장성이 높다(스케일 아웃)
- 단점: 클라이언트가 추가 데이터를 전송

## Statufull, Stateless 차이
### 상태 유지 - Stateful
![](images/Pasted%20image%2020230211014419.png)
### Stateful 에서 점원이 바뀌는 경우
![](images/Pasted%20image%2020230211014458.png)

- Stateful의 경우, 처음에 `(노트북)` 상태를 유지한다. 이후에는 `(노트북, 2개)` 상태를 유지한다. 이후에는 `(노트북, 2개, 신용카드)` 상태를 유지하는 것

### Stateless

![](images/Pasted%20image%2020230211014945.png)

- Stateless의 경우, 고객이 추가적인 정보를 제공해야한다. 처음 데이터는 노트북, 이후에는 노트북 2개,  마지막에는 노트북, 2개, 신용카드 의 형태로 데이터를 제공하는 것이다. 이것이 점원이 중간에 바뀌는 경우에 적용하면 다음과 같다.

![](images/Pasted%20image%2020230211014837.png)
Stateful 의 경우에는 점원이 바뀌는 경우 context가 사라지기 때문에 서비스 장애가 일어나게 되는 것이다. stateless의 경우에는 고객이 필요한 데이터를 그때마다 넘기기 때문에 점원이 바뀌어도 문제가 발생하지 않는다.

클라이언트 서버 아키텍처에서 엄청난 확장성을 가질 수 있게 되는 것이다.

### 차이
- Stateful: 중간에 다른 점원으로 바뀌면 안된다. 중간에 다른 점원으로 바뀔 때 상태 정보를 다른 점원에게 미리 알려줘야 한다. 따라서 쉽지 않다.
- Stateless: 중간에 다른 점원으로 바뀌어도 된다.
	- 갑자기 고객이 증가해도 점원을 대거 투입할 수 있다.
	- 갑자기 클라이언트 요청이 증가해도 서버를 대거 투입할 수 있다.
- 무상태는 응답 서버를 쉽게 바꿀 수 있다 >> 무한한 서버 증설 가능

Stateful의 경우 항상 같은 서버가 유지되어야 하고 클라이언트는 통신하던 서버 하나만으로 통신할 수 밖에 없다. 그래서 서버를 맘대로 늘리기 어렵다. 그리고 해당 서버가 죽는 경우 통신을 처음부터 다시 시작해야한다
Stateless의 경우에는 필요한 데이터를 모두 담아서 보내기 때문에 아무 서버나 호출해도 상관없다. 중간에 통신하던 서버에 장애가 발생하더라도 문맥이 필요없기 때문에 다른 서버가 바로 응답해줄 수 있게 된다. 이러한 이유로 스케일 아웃에 유리하다. 

## 한계
- 모든 것을 무상태로 설계할 수 있는 경우도 있고 없는 경우도 있다.
- 로그인의 경우 상태 유지가 필요하다.
- 일반적으로 브라우저 쿠키와 서버 세션등을 사용해서 상태 유지
- 상태 유지는 최소한만 사용한다. 
- 데이터를 더 많이 보내야한다는 단점이 존재한다. 

# 비 연결성(connectionless)
## 연결을 유지하는 모델
TCP/IC의 경우 연결을 유지하게 되어있다. 서버 하나에 많은 클라이언트가 요청을 보내는 경우 서버는 다른 클라이언트틀과 계속 연결을 유지해야하기 때문에 서버 자원을 소모할 수 밖에 없다. 

![](images/Pasted%20image%2020230211020120.png)
## 연결을 유지하지 않는 모델
요청을 받았을 때 응답을 보내주고 바로 연결을 끊어버리기 때문에 최소한의 자원으로 유지할 수 있게 된다.

![](images/Pasted%20image%2020230211020211.png)

## 비 연결성
- HTTP는 기본이 연결을 유지하지 않는 모델이다
- 일반적으로 초 단위 이하의 빠른 속도로 응답이 이루어진다.
- 1시간 동안 수천명이 서비스를 사용해도 실제 서버에서 동시에 처리하는 요청은 수십개 이하로 매우 작다. 
- 따라서 서버 자원을 효율적으로 사용할 수 있게된다. 

### 한계와 극복
- 요청마다 TCP/IP 연결을 새로 맺어야한다. - 3 way handshake 시간이 추가됨
- 웹 브라우저로 사이트를 요청하면 HTML 뿐만 아니라 자바스크립트, css, 추가 이미지 등 수 많은 자원이 함께 다운로드 된다. 
- 지금은 HTTP 지속 연결(Persistent Connections)로 문제 해결
- HTTP/2, HTTP/3에서 더 많은 최적화

![](images/Pasted%20image%2020230211020816.png)

즉, 수 많은 데이터들을 다운로드 받을 때 마다 연결을 하게 된다는 것이다. 

![](images/Pasted%20image%2020230211020858.png)

이후에는 HTML 페이지를 모두 받을 때 까지 연결을 유지하는 방식을 취한다. 

## 스테이스리스를 기억하자
서버 개발자들이 어려워하는 업무 중 하나는 정말 같은 시간에 딱 맞추어 트래픽이 급증하는 경우이다.
- 예를 들어, 선착순 이벤트, KTX 예약, 학과 수업 등록 등 
이럴 때 스테이스리스인 경우 스케일 아웃이 편하다.

# HTTP 메시지
- 요청 메시지
```
GET /search?q=hello&hl=ko HTTP/1.1 
Host:www.google.com
```
- 응답 메시지
```
HTTP/1.1 200 OK
Content-Type: text/html;charset=UTF-8
Content-Length:3423

<html>
  <body...</body
</html>
```
요청 메시지와 응답 메시지는 약간의 차이가 있다.

![](images/Pasted%20image%2020230211021436.png)
- 시작 라인, 헤더, 공백 라인(실제로 공백이 필요함), 메시지 바디로 이루어져있다.
- 요청 메시지와 응답 메시지는 시작 라인이 다르다. 

## 시작 라인
### 요청 메시지
- start-line = request-line / status-line
	- 시작 라인은 요청 메시지과 상태 메시지으로 되어있다.
- **request-line** = mehode SP(공백) request-target SP HTTP-version CRLF(줄바꿈)
	- HTTP 메서드 (GET: 조회)
	- 요청 대상(/search?q=hello&hl=ko)
	- HTTP Version

#### HTTP 메서드
- 종류: GET, POST, PUT, DELETE
- 서버가 수행해야 할 동작 지정
	- GET: 리소스 조회
	- POST: 요청 내역 처리

#### 요청 대상
- absolute-path\[?query]
	- 보통 절대 경로로 시작을 한다.

#### HTTP Version
- HTTP 버전

### 응답 메시지
- **status-line** = HTTP-version SP status-code SP resion-phrase CRLF
	- HTTP 버전
	- HTTP 상태 코드: 요청 성공, 실패를 나타냄
		- 200: 성공
		- 400: 클라이언트 요청 오류
		- 500: 서버 내부 오류
	- 이유 문구: 사람이 이해할 수 있는 짧은 상태 코드 설명 글

## HTTP 헤더
- header-field = field-name ":" OWS field-value OWS (OWS: 띄어쓰기 허용)
- field-name은 대소문자 구분 없음
![](images/Pasted%20image%2020230211022621.png)

### 용도
- HTTP 전송에 필요한 모든 부가정보
- 예) 메시지 바디의 내용, 메시지 바디의 크기, 압축, 인증, 요청 클라이언트(브라우저) 정보, 서버 애플리케이션 정보, 캐시 관리 정보 ...
- 표준 헤더가 너무 많다. 따라서 전달하는 바디 이외의 모든 메타데이터를 포함한다고 볼 수 있다.
- 필요시 임의의 헤더 추가 가능

## HTTP 메시지 바디
- 실제 전송할 데이터
- HTML 문서, 이미지, 영상, JSON 등등 byte로 표현할 수 있는 모든 데이터 전송 가능, 압축도 가능

## 단순함 확장 가능
- HTTP는 단순하다.
- HTTP 메시지도 매우 단순하다.
- 크게 성공하는 표준 기술은 단순하지만 확장 가능한 기술

