#goorm #kubernetes
쿠버네티스는 왜 필요한가? 결국은 관리를 편리하게 하기 위해서이다. 물리 서버를 수십, 수백, 수천 대를 한 번에 관리하는 것은 쉽지 않을 것이다. 
여러 서버, 네트워크, 애플리케이션 등 사용하는 것을 논리적으로 하나로 묶은 것이 클러스터가 된다. 쿠버네티스도 결국은 컨테이너 클러스터이다. 
물리적인 서버든 가상화든 컨테이너든 그 수가 많아지게 되면 관리하기 어려워진다. 따라서 클러스터로, 하나로 묶어서 관리하게 되는 것이다. 
쿠버네티스는 컨테이너를 클러스터로 관리하기 위한 도구 중 하나이다. 

# kubeabm
쿠버네티스 서버 배포시에는 kubeabm을 사용하지는 않는다. 대신 cka를 위해서는 반드시 알아야할 필요가 있다. 

# kubespray
kubespary는 쿠버네티스 클러스터를 배포하는 방법 중 하나로 ansible을 이용하여 손쉽게 쿠버네티스 클러스터 배포를 한다. 그래서 kubespray는 ansible 플레이북, 인벤토리, 프로비저닝 툴 등으로 이루어져있다. 
먼저 vagrant로 노드들을 생성하고나서 kubespray github을 이용한다. 
```
git clone --branch release-2.20 https://github.com/kubernetes-sigs/kubespray.git
```
의존성 확인을 위해서 requirements 들을 설치한다.
이후 ansible 인벤토리를 준비한다. 그리고 addon, k8s cluster 설정들을 변경하고 ansible 플레이북을 실행한다. 

# 쿠버네티스 컴포넌트

![](images/Pasted%20image%2020230213143936.png)

- 클러스터는 여러 대의 VM으로 구성되어 있다. 쿠버네티스는 VM위에 구성을 할 수도 있고 물리적인 컴퓨터에 구성할 수도 있다.
- 클러스터는 Control Plane과 Node 들로 구성되어 있다. 쿠버네티스의 궁극적인 목표는 결국 컨테이너를 실행하는 것이다. Node(worker)들은 컨테이너들을 실행시키고 Control Plane(Master)는 Node들을 관리한다. 

## Control Plane
- 컨트롤 플레인의 어떤 구성요소들이라도 제대로 작동하지 않는다면 쿠버네티스가 제대로 작동할 수 없기 때문에 보통 고가용성을 가지도록한다. 위의 그림에서 각 구성요소들이 세개씩 그려져 있는 것이 그 이유이다.
- etcd의 경우는 백엔드 데이터베이스로 보면 되고, 보통 따로 클러스터를 구성한다고 한다.
- 보통 짝수로는 구성하지 않는다고 한다. 이는 split brain이 발생하는 경우 버리는 부분을 정하기 어려워 홀수로 구성한다.  

### API Server
- 장표상 모든 구성요소들은 API Server를 가리키고 있다. 클라이언트인 kubectl도 결국은 API server를 가리킨다. 쿠버네티스의 모든 요소, 기능들은 API 서버와 통신을 하고 직접 서로 통신하지 않는다. 이것이 기본적인 컨셉이다.
- 인터페이스라고도 한다.
- 따라서 API server에 문제가 생기게 되면 아무것도 제어할 수 없기 때문에 다른 기능들이 정상이어도 이용할 수 없게 된다. 

### etcd
- 쿠버네티스의 모든 정보를 저장하고 있는 key-valuse 데이터베이스이다. 엄밀하게 이야기 하자면 쿠버네티스의 구성요소는 아니며 다른 것으로 대체될 수 있다. 
- 모든 데이터가 여기에 저장되어 있기 때문에 데이터가 손상되는 경우 쿠버네티스가 제대로 동작할 수 없다. 따라서 이 데이터를 백업하는 것은 필수이다. 

### kube-scheduler
- 운영체제에서 핵심인 것은 커널이고 여기서 중요한 것은 스케쥴러이다. 이것으로 리소스 관리를 하는 것이 가능하다. 
	- 스케쥴러가 있는 것 때문에 쿠버네티스를 cloud os라고 하기도 한다. 
- 쿠버네티스의 가장 기본적인 목표는 컨테이너를 실행하는 것이다. 컨테이너를 실행시킬 수 있는 노드들이 여러대 존재하기 때문에 스케쥴러가 어느 노드에 컨테이너를 배치할 지 결정하게 된다. 

### kube-controller-menager
- 컨트롤 플레인이 컨트롤 플레인인 이유로 컨트롤러 프로세스를 실행하는 구성요소이다.
- 다음의 컨트롤러들을 포함한다.
	- 노드 컨트롤러: 노드가 다운되었을 때 통지와 대응에 관한 책임을 가진다.
	- 잡 컨트롤러: 일회성 작업(배치 작업)을 나타내는 잡 오브젝트를 감시한 다음, 해당 작업을 환료할 때 까지 동작하는 파드를 생성한다.
	- 엔드 포인트 컨트롤러: 네트워크를 관리하는 것으로 엔트포인트 오브젝트를 채워 서비스와 파드를 연결시킨다.
	- 서비스 어카운트, 토큰 컨트롤러: 새로운 네임스페이스에 대한 기본 계정과 API 접근 토큰을 생성한다.

### cloud-controller-manager
- 클라우드에 쿠버네티스를 올린다고 한다면 쿠버네티스와 클라우드 리소스, 솔루션들이 상호작용할 수 있어야 한다. 이 역할을 하는 것이 ccm이다. 
	- 클라우드별 컨트롤 로직을 포함하는 쿠버네티스 컨트롤 플레인 컴포넌트이다. 
- 예를 들어 노드 컨트롤러는 ec2, 라우트 컨트롤러는 vpc, 서비스 컨트롤러는 elb 등으로 볼 수 있다. 
- 클라우드에서 사용하지 않는 경우에는 없을 수도 있는 컴포넌트이다. 

## Node
### CRI(Container Runtime Interface)
- 컨테이너를 실행시키기 위해서 필요한 것
- 이것을 통해 컨테이너를 실행 및 관리한다.

### kubelet
- 클러스터의 각 노드에서 실행되는 에이전트이다. 파드에서 컨테이너가 확실하게 동작하도록 관리한다. 
- 에이전트들은 각 노드에 있는 컨테이너 런타임에게 컨테이너 관련 요청을 하게 된다. 

### kube-proxy
- netfilter는 라우팅, 포트포워딩 등 네트워크의 모든 것을 관리한다. firewalld 는 고수준, iptables는 저수준의 api이다. 리눅스에서의 netfilter처럼 도커에서 네트워크를 관리하는 것은 docker-proxy 이다. 
- kube-proxy는 해당 시스템에서 네트워크를 관리하는 컴포넌트이다. 노드의 네트워크 규칙을 유지 관리하고 이 네트워크 규칙이 내부 네트워크 세션이나 클러스터 바깥에서 파드로 네트워크 통신을 할 수 있도록 해준다. 

## 애드온
- 쿠버네티스의 추가 구성요소로 리소스는 상당히 많다. 
- 쿠버네티스에 애드온을 같이 붙여놓은 오픈소스가 OpenShift 이다. 

### DNS
- 보통 기본으로 설치된다. CoreDNS라는 오픈소스를 사용한다. 

### 웹 UI
- 리소스에 접근하기 편하게 해주지만 보안상 좋지 않기 때문에 추천하지 않는다. 

- 쿠버네티스 클러스터 구성 이후 kubectl get pods -A 를 해보면 각 컴포넌트들도 결국은 컨테이너임을 확인할 수 있다. 

![](images/Pasted%20image%2020230213161052.png)

- 설정에 따라 다르지만 etcd의 경우 서비스로 설치할 수도 있다.

![](images/Pasted%20image%2020230213161112.png)

- kubelet은 컨테이너가 아닌 서비스인 것을 확인할 수 있다. kubelete의 경우 컨테이너 일 수 없다. 

![](images/Pasted%20image%2020230213161144.png)

- kubelet과 kube-proxy의 경우 control plan에도 존재한다. Control plane 도 기본적으로 node 이기 때문에 해당 컴포넌트가 존재한다. 하지만 스케쥴러가 존재하기 때문에 control plane에는 container가 뜨지 않게 된다. 
	- minikube의 경우는 노드 하나에 모두 구성하기 때문에 그렇지 않다.

- 웹은 stateless이며 DB가 stateful하다. 웹은 데이터를 만들어내지 않고 생성된 데이터는 모두 DB로 넘기게 된다. 
- 기본적으로 컨테이너는 stateless로 되어있다. 따라서 이미지가 있으면 언제든 컨테이너를 지웠다가 다시 띄울 수 있는 것이다. 
	- 이러한 의미가 바로 Immutable Infrastructure가 되는 것이다. 상태가 없기 때문에 항상 같은 구성을 할 수 있는 것이다. 
- 기업, IT에서 결국 가장 중요한 것은 데이터이고 이를 잘 관리하는 것이 필요하다. 데이터는 상태가 있기 때문에 데이터는 컨테이너, VM이 아닌 다른 스토리지에 별도에 저장해야한다. 따라서 데이터를 따로 저장하기 위해 볼륨을 만들고 해당 볼륨을 마운트하게 한다. 
- 컨테이너 내부에 데이터를 저장하는 것이 아니라 따로 볼륨을 사용해야하는 것이다. 컨테이너는 stateless 하게 하여 항상 같은 형태로 구성되게 하고 변경되는 내용은 볼륨에 저장하게 한다.

- 쿠버네티스도 결국은 도커와 마찬가지로 컨테이너를 실행시키는 것이기 때문에, 이미지, 컨테이너, 볼륨, 네트워크가 중요하다. 
