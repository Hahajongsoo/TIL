관리자가 시스템을 관리할 때 직접 서버에서 접속하는 방식과 외부에서 네트워크를 통해 접속하는 방식이 있다. 외부에서 네트워크를 통해 원격 접속할 때 사용하는 방식은 telnet이나 ssh를 이용한 방식을 주로 사용한다. telnet의 경우 암호화하지 않은 평문전송방식으로 보안에 취약하여 안전하지 않다. 
SSH는 암호키를 사용하여 시스템 간 통신할 때 데이터를 암호화한다. SSH는 상용 SSH와 OpenSSH가 있다. 

# 암호화 이론

## 일방향 암호화
평문을 암호문으로 만드는 것을 암호화라고 한다. 암호문을 평문으로 만드는 것을 복호화라고 한다. 암호화는 가능하지만 복호화는 불가능한 알고리즘을 일방향 암호화라고 한다. 그리고 이렇게 일방향 암호화된 값을 해시(hash)라고 한다. 
md4, md5, sha256, sha512, sha1024 등의 방식을 사용하고 암호화 강도 때문에 보통 최소 sha256 이상을 사용한다.
패스워드 같은 데이터를 안전하게 보관하기 위해 사용한다. 복호화는 지원하지 않지만 비밀번호를 깨는 크랙킹은 할 수 있다. (무차별 대입, 사전 대입 공격 가능, 임의의 값으로 암호화하여 비교하면서 확인해볼 수 있다.)
파일이나 데이터의 무결성 검증을 위해서 해시를 사용하기도 한다. 서버에서 파일을 다운로드 받는다고 했을때 파일데이터와 해시데이터를 모두 제공을 하고 클라이언트는 해시 값을 비교하여 원본파일을 그대로 받아왔는지 확인할 수 있다. 

## 양방향 암호화
암호화와 복호화 둘다 지원되는 알고리즘이다. 양방향 암호화는 반드시 key가 필요하다. key는 일정 길이의 문자열이다. 키를 이용해서 평문을 암호문으로 만들고 다시 암호문을 평문으로 만들 수 있다. 

### 대칭키 암호화(세션키 암호화, 비밀키 암호화)
암호화키와 복호화키가 동일한 키가 1개인 암호화 방식이다. ~~DES, 3DES~~, AES 등의 방식이 있다. 

#### 대칭키 암호화를 이용한 암호화 통신
데이터를 보내는 A가 키를 이용하여 데이터를 암호문으로 만든다. 데이터와 키를 받은 B는 키를 사용하여 데이터를 해독한다. 
B에게 키를 건네주는 과정에서 키의 대한 정보도 하이재킹 당하게 되면 암호화가 의미없게 된다는 단점이 있다.

### 비대칭키 암호화(개인키/공개키 암호화)
키전달문제를 해결하기 위한 암호화로, 암호화키와 복호화키가 따로 있는 암호화방식이다.
개인키는 절대 누구에게도 주면 안되고 자기 자신만 소유해야 한다. 공개키는 어느 누구에게도 줄 수 있다. 개인키로 암호화한 것은 오직 공개키로만 해독이 가능하고 공개키로 암호화한 것은 오직 개인키로 해독이 가능하다. RSA 알고리즘이 있다.

#### 비대칭키 암호화를 이용한 암호화 통신
클라이언트가 서버에 통신을 요청하면 서버는 클라이언트에게 공개키를 제공한다. 서버에게 데이터를 전달하면 서버는 개인키로 암호문을 해독한다. 
키전달문제를 해결했다는 장점이 있으나 속도가 느리다는 단점이 있다. 그리고 키 신뢰성 문제가 존재한다. 
클라이언트가 공개키로 대칭키를 만들고 서버에게 대칭키를 전달하여 대칭키 암호화로 통신하면 키전달문제를 해결하면서 속도가 느린 문제도 해결된다.

#### 인증
B가 개인키와 공개키를 만들고 B의 공개키를 A에게 전달한다. 이후에 B는 자신을 인증하는 값을 만들고 B의 개인키로 암호화를 한다. 해당 암호문은 오직 B의 공개키로만 해독할 수 있다. 암호문을 받아서 B의 공개키로 해독이 가능하다는 것은 B의 암호문이라는 것이기 때문에 비대칭키 암호화는 인증하는 용도로 사용된다.

#### 키 신뢰성
A가 B에게 공개키를 요청한다. B가 A에게 공개키를 줄때 해커가 B의 공개키를 받고 A에게 해커의 공개키를 넘겨준다. A가 B에게 데이터를 줄때 해커의 공개키로 암호화해서 넘겨주게 되고 해커는 그 데이터를 받아서 다시 B의 공개키로 암호화한후 B에게 넘겨준다. A와 B 중간에 껴서 해커가 공개키를 바꿔치기하는 것이다. SSH 1.0은 MIT 공격에 취약했고 SSH 2.0부터는 디피-헬먼 알고리즘을 사용해서 좀 더 안전한 통신을 한다.

# SSH 연결 과정
클라이언트가 서버에 접속할 때 서버의 공개키가 클라이언트에 저장되어 있지 않으면 SSH서버의 공개키를 저장하기 위한 메시지가 출력된다. 서버의 공개키가 저장되는 위치는 접속을 시도한 사용자의 홈 디렉토리 아래 `.ssh/known_host` 파일에 저장된다. 
서버의 `/etc/ssh` 디렉토리에는 sshd 서비스와 관련된 파일들이 저장된다. 그 중 ssh_host로 시작하는 파일은 암호화 키 파일이다.  뒤에 `.pub` 확장자가 추가된 파일이 서버의 공개키 파일이다. 
서버의 공개키를 저장한 뒤 클라이언트는 디피-헬먼 알고리즘을 사용해 난수 데이터를 생성하여 대칭키 암호화를 위한 비밀키를 생성한다. 이 비밀키를 다시 서버의 공개키로 암호화하여 서버에게 전달한다. 서버는 서버의 공개키로 암호화된 비밀키를 복호화하여 클라이언트에서 생성한 비밀키를 얻게 된다. 이 비밀키를 사용하여 클라이언트와 서버는 데이터를 암호화하여 통신한다.

## ssh 명령 사용
클라이언트에서 SSH를 사용하여 원격 접속할 때 `ssh` 명령을 사용한다. 
```
ssh [user-name]@address
```
user-name에는 접속하고자 하는 사용자 이름을 지정하고 address에는 접속하려는 시스템의 DNS 이름 또는 IP 주소를 입력한다. 

사용자를 지정하지 않으면 클라이언트에 로그인 된 사용자와 동일한 UID를 가진 사용자를 서버에서 검색한다. 서버에 동일한 UID를 가진 사용자가 없으면 접속되지 않는다.
ssh 명령을 사용할 때 사용자를 지정하는 방식이 가장 많이 사용하는 유형이다. 
ssh를 사용하여 시스템에 원격 접속하는 경우 그래픽 도구를 사용할 수 없다. OpenSSH는 X11포워딩이라는 기능을 제공하는데 이 기능을 사용하여 원격접속 하면 그래픽 도구를 사용할 수 있다. `ssh -X`를 사용하여 접속하면 된다. 

# OpenSSH 설정 파일
설정파일은 `/etc/ssh` 디렉토리에 존재한다. OpenSSH의 클라이언트 설정이나 서버 설정 그리고 암호화 알고리즘에 따른 암호키를 확인할 수 있다.

# OpenSSH 키 기반 인증
키 기반 인증은 사용자의 암호를 알고 있지 않아도 원격 접속할 수 있는 인증방법이다. 키 기반 인증은 인증할 수 있는 키를 가지고 있는 사용자만 접속할 수 있기 때문에 보안성이 높아진다. 
```
ssh-keygen [option] [argument]
```
로 키 파일을 생성한다. 사용자의 홈 디렉토리 하위 디렉토리인 `.ssh`에 인증을 위한 개인키와 공개키 한 쌍이 생성된다. 사용하면 키와 저장되는 위치와 이름을 지정할 수 있다. passphrase에 특정 값을 입력하면 이 키를 사용해서 사용자를 인증할 때 passphrase 값을 입력해야 인증이 완료된다. `-t` 옵션을 주어 암호화 알고리즘을 지정할 수 있다. 

```
ssh-copy-id [option] [argument] [user-name]@address
```
를 사용하여 공개키를 접속하고자 하는 시스템에 전달한다. 옵션을 주지 않는 경우 자동으로 사용자의 홈 디렉토리의 `.ssh` 디렉토리에서 `id_rsa.pub` 파일을 전송한다. `-i` 옵션을 사용하면 다른 위치에 저장되어 있는 공개키 파일을 지정하여 전송할 수 있다. 

이때 파일 자체가 전송되는 것이 아니라 파일의 내용인 키 값이 전송된다. 이 키 값은 접속하려는 시스템의 사용자의 홈 디렉토리에 `.ssh` 디렉토리의 `authorized_keys` 파일에 저장된다. 

#  원격 파일 접속
SSH를 사용하여 시스템 간 원격으로 파일을 전송할 수 있다.

## scp 명령 사용
scp는 rcp를 대체하기 위한 명령이다. rcp는 평문 전송이기 때문에 보안성이 떨어진다. scp는 ssh를 사용하여 원격으로 파일이 전송되기 때문에 데이터 전송시 암호화 된다. 
```
scp [option] source1 source2 ... destination
```
다른 시스템의 파일의 위치를 지정할 때는 `[user-name]@address:path` 형식을 사용한다. 디렉토리를 전송할 때는 `-r` 옵션을 추가한다. 

### 로컬에서 원격으로 전송
```
scp /root/fileA user@server.co.kr:/home/user
```

### 원격에서 로컬로 전송
```
scp -r user@server.co.kr:/home/user/dir /root
```

