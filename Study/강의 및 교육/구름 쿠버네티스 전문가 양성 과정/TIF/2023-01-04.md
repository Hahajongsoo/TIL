논리 볼륨을 생성하면 좀 더 유연하게 저장 공간을 사용할 수 있다는 점이 있다. 논리 볼륨을 늘릴 수도 있고 단일 디스크 크기보다 큰 볼륨을 만들 수도 있고 데이터를 유지한 상태로 디스크를 제거할 수도 있다. 스냅샷 기능도 사용할 수 있다.
LV를 만드는 과정은 물리 볼륨 생성 -> 볼륨 그룹 생성 -> 논리 볼륨 생성 순이다.
생성하는 명령어는 다 비슷하다. `pvcreate`, `vgcreate`, `lvcreate`
논리 볼륨을 늘리는 경우 볼륨만 늘어나고 파일 시스템의 크기는 늘어나지 않기 때문에 해당 파일 시스템에 맞는 명령어를 사용하여  파일 시스템의 크기도 늘려줘야 한다.
볼륨 그룹에서 물리 볼륨을 제거할 때는 다른 물리 볼륨으로 데이터를 옮기는 작업을 한 후 볼륨 그룹에서 제거해야한다.

컴퓨터가 부팅을 하면 먼저 시스템 펌웨어에서 하드웨어상의 문제는 없는지 확인하는 POST(Power On Self Test)를 거친다. 이후 이상이 없다면 부팅 장치를 보고 부팅 디스크에서 첫 번째 섹터에 있는 512바이트를 로드한다. 그것이 MBR이고 여기서 부트로더의 위치를 찾아 로드한다. 
부트로더가 메모리에 적재되면 부팅할 운영체제를 선택하도록 커널에 목록을 출력한다. 
커널이 메모리에 올라가면 커널은 초기화 단계를 거치고나서 fork를 사용하지 않고 생성되는 프로세스와 스레드를 생성한다.
이때 실행되는 것이 init 혹은 systemd 이다. 기존 init 프로세스는 부팅 과정에서 각종 서비스를 제공하는 셸 스크립트 파일을 실행했다. systemd는 init을 대체하는 프로세스로 init보다 효율이 좋고 다양한 기능을 제공하는 서비스 관리자이다. 
systemd가 실행되면 먼저 default.target을 실행한다. (타겟 유닛은 유닛들을 그루핑하는 유닛이다. 해당 타겟 단계가 되었을 때 그루핑 되어있는 다른 유닛들을 실행한다.) 이후 계속 종속적인 관계를 가지는 타겟 유닛들이 필요한 타겟들을 실행시킨다. 그리고 최종적으로 사용자가 접근할 수 있는 타겟이 실행되는 것이다.

systemd의 유닛들을 조작할 수 있는 명령어는 systemctl로 다양한 유닛들을 관리할 수 있다.

[08-파일시스템](../02.리눅스/08-파일시스템.md)
[09-부팅](../02.리눅스/09-부팅.md)

Go 언어는 문자열 부분을 공부했다. 기억할 것은 문자열은 불변하고 문자열 메모리 주소를 가리키는 포인터와 문자열의 길이 정보를 필드로 가지는 구조체라는 것이다.

[15-문자열](../../../../Book/Tucker의%20Go%20언어%20프로그래밍/15-문자열.md)

