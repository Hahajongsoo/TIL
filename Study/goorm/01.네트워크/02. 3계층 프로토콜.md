# 토폴로지 
- 다른 PC와 연결을 하는 것은 스위치이기 때문에 보통 2계층이라 한다. 물론 외부까지 연결한다 생각하면 라우터도 껴야한다.
- 스타형, 버스형, 트리형, 링형, 메쉬형 등등이 있지만 스타형 트리형 정도만 제대로 알고 있으면 된다.
	- 링 구조는 무언가를 찾아야 하는 반복적인 업무에 주로 사용 될 수 있다.
		- 회선 교환 방식은 중앙에서 다른 라인으로 연결해주는 방식이다. 즉 사람이 입력을 계속 다른 라인에 연결해줘야 하는 것이다. 이를 해결하는 방식에 링 형식이 사용되었다. 입력이 들어오면 링을 돌면서 나가야 하는 방향( 예를 들면 지역번호 )을 찾아서 나갈 수 있도록 하였다.
		- 라인이 끊어지면 구조 전체가 죽어버리는 단점이 있다.
	- 메쉬 형은 어디가 끊겨도 상관 없다는 장점이 있다. 하지만 라인을 늘리는데 비용 소모가 크기 때문에 유선으로는 사용하지 않고 주로 무선으로 사용한다. 예를 들어 공공장소에서 하나의 와이파이, IP로 계속 연결되는 것이 메쉬 구조이다. 
		- 지하철의 경우에는 AP(Acess point, 공유기나 와이파이 같은 연결되는 지점)가 결국에는 연결되고 연결되어 외부로 나가는 라인과 연결되어 있어야 한다. 3G, LTE 망에 연결되는 경우에는 기지국을 계속 찾아가야 되기 때문에 딜레이가 발생하고 끊기기도 한다. 따라서 지하철 전체를 메쉬형으로 구성해놓고 다른 AP로 넘어가도 정보를 잃지 않도록 한다. 그리고 이렇게 구성을 하면 IP주소가 부족할 수 있기 때문에 IPv6를 사용한다.

# TCP/IP 모델
이전에 배운 OSI 7 Layer 모델을 4계층으로 나눌 수 있다. 
![](images/Pasted%20image%2020221221102837.png)
- 현재 우리가 사용하고 있는 계층은 TCP/IP 프로토콜 계층이다. OSI 7 Layer를 이해한다면 자동적으로 TCP/IP 프로토콜 계층을 이해할 수 있다.
## IEEE 802 시리즈
- 근거리 통신망과 도시권 통신망을 관할하는 IEEE 표준 규칙들의 계열을 말한다.
- IEEE 802.11: 무선랜, 와이파이
- IEEE 802.15: 개인 무선망
	- IEEE 802.15.1: 블루투스
### MAC 계층과 LLC 계층
- LLC 계층은 어떤 통신 방식을 사용하는지에 대한 정보를 담고 있다.
- MAC 계층
	- ARP(주소결정프로토콜) : IP를 이용해서 MAC을 호출하는 것 ARP이다.
	- RARP: MAC을 이용해서 IP를 찾는 것
		- DHCP(Dynamic Host Configuration Protocol): 필요에 따라서 자동으로, 동적으로 IP를 할당해주는 방식
		- 만약 공공장소를 생각해봤을 때, IP가 고정되어 있다면 사용할 수 있는 기기의 개수는 고정되어 있게 된다. 따라서 동적으로 IP를 할당하는 DHCP를 이용하게 된다. 그런데 이 경우에 어떠한 장비는 IP가 고정되어야 하는 경우가 있는데 이 경우에 RARP를 사용하여 IP를 고정한다.
	- CSMA/CD(Multiple Access Carrier Sense Collision Detection): 다수의 매체가 하나의 라인에 접근할 때 충돌을 감지하여 이를 해결한다. 이때 MAC이 연결된 기기의 정보를 갖고 있기 때문에 이를 해결하는 역할을 한다. 

# 3계층
## ICMP(Internet Control Message Protocol)
- IP 위에 붙게 되는 것이다. IP 헤더에 어떤 프로토콜을 사용하는지로 확인할 수 있다.
- Type, Code, Checksum으로 이루어져 있다.
- `ping 게이트웨이 주소` 로 ICMP 확인
![](images/Pasted%20image%2020221221112640.png)
- MAC 주소 확인
![](images/Pasted%20image%2020221221113211.png)
- IP헤더
![](images/Pasted%20image%2020221221113340.png)
- ICMP 에서 메시지 확인 가능
	- https://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml
	- 주된 내용은 Type으로 나타내고 세부 내용은 Code로 나타낸다.
	- 현업에서 ICMP 막아라 라는 이야기는 굳이 필요없는 ICMP를 막으라는 이야기이다.
		- 잘 구축되어있는 네트워크에서 ping은 굳이 필요없으므로 8,0은 필요없을 수 있다. 체크하는 것은 OS 이전에 메모리에서 하기 때문에 의도치 않게 메모리 낭비가 발생할 수 있다.
![](images/Pasted%20image%2020221221113417.png)

## IGMP(Internet Group Management Protocol)
- 멀티캐스팅과 관련된 프로토콜이다. 해당 그룹에 대해서 멀티캐스트를 하는 것이고 해당 채널을 듣게되면 멀티캐스트에 대한 정보를 받게 되는 것이다.

## VPN, IPSEC
- 멀리에 있지만, 수 많은 라우터들을 거치지만 바로 옆에 있는 LAN 처럼 보이게 하는 프로토콜, 암호화 되어있어 실제 IP는 해당 IP가 아니다.
- IPSEC 에서 사용하는 암호화 프로토콜에는 AH, ESP 등이 있다.
- 클라우드에 접속할 때 SSH 또는 VPN을 사용한다.

## UDP
- IP 위에 붙는다. IP 헤더에서 사용하는 프로토콜로 확인 가능
- 도메인은 ip 주소를 알기 쉽게 문자로 표기하는 것이고, 컴퓨터는 원래 도메인을 이해할 수 없다.
- DNS는 UDP를 사용한다. 매우 단순하고 신뢰도가 낮지만 속도가 빠르고 데이터를 전송할 수 있다. 
- 정방향 조회: 도메인을 통해서 IP 주소를 받아오는 것
![](images/Pasted%20image%2020221221123107.png)

![](images/Pasted%20image%2020221221141001.png)

![](images/Pasted%20image%2020221221142510.png)
- UDP는 Soruce Port, Destination Port, Length, Checksum 으로 이루어져있다. 즉 출발지 도착지 정보만 있고 뒤에 데이터가 붙는 형식
- UDP는 연결상태를 확인하지 않고(교섭 단계를 거치지 않음) 포트만 확인하고 바로 통신을 시도한다. 연결되지 않은 경우, 포트가 막혀있는 경우에는 ICMP가 이를 막게된다. 
	- UDP는 통신 상태를 확인하지 않기 때문에 흐름제어를 할 수 없다. 
	- 그렇기에 데이터 전체를 보내게 된다. 데이터 통신의 전송 크기를 카운트 하는 기능이 없다. 그래서 data 다운로드, 동영상 스트리밍 중간에 일시정지할 수 없다.
	- 통신 상체를 체크하는 기능이 없기 때문에 **비연결지향적**이라고 한다. 그래서 연결지향적인 프로토콜을 만들었고 이것이 TCP이다.

## TCP
![](images/Pasted%20image%2020221221142544.png)
- 출발지와 목적지 포트가 있다.
- TCP Flags
	- C, E는 사용하지 않고 UAPRSF 를 사용한다. 조합하여 통신 상태를 알려준다.
- Sequence Number와 Acknowledgment Number를 조합하여 데이터의 순서를 알려준다. 이것으로 데이터가 얼마나 전송되었는지 체크할 수 있다. 

### TCP State diagram, flow
![](images/Pasted%20image%2020221221143424.png)
![](images/Pasted%20image%2020221221153844.png)
- TCP로 통신하기 전에 교섭단계를 거치고 이때 일어나는 단계를 3-way handshake라고 한다.
	- LISTEN 하고 있는 상태에서 SYN을 보내면(SYN_SENT) SYN을 받은 곳(SYN_RCVD)은 SYN,ACK을 보낸다. 그리고 다시 이것을 받은 곳은 ACK를 보낸다. 이러한 단계가 전부 체크가되면 ESTABLISHED가 된다. 
		- 어떤 상태에서 어떤 신호를 받느냐에 따라서 다른 신호를 보내게 된다.
		- SYN을 보내면 SYN_SENT가 되고 SYN을 받으면 SYN_RCVD가 된다. 
		- SYN_RCVD에서 ACK을 보낼 때, flags에서 옆자리가 남으므로 보내는 김에 SYN을 같이 보내게 되는 것  같이 SYN을 해야하기 때문에
		- SYN_SENT 상태에서 SYN, ACK을 받게되면 ACK을 보내게 된다. 
![](images/Pasted%20image%2020221221153908.png)
- 클라이언트에서 통신을 종료시에는 4-way handshake이다.
- 서버에서 통신을 종료시(passive close)에는 서버가 FIN, ACK을 보내고 클라이언트가 ACK을 보내면서 종료
- TCP flags에서 데이터 전송을 위한 flag는 PUSH이다.
	- data 관련으로 보자면 PUSH만 찾으면 된다.

### Sequence, Acknowledgment Number
- 수 많은 통신 중에서 이전 통신과 연결된 다음 통신인 것을 식별하게 하는 정보이다.
- 특정 로직을 거쳐 Acknowledgment Number가 결정되고 이것이 다음에 받아야하는 Sequence Number이다. 즉 Ack Num을 통해서 다음에 보내야 하는 순서를 알려주는 것이다. 
- 순서를 보장할 수 있기 때문에 좀 더 신뢰도 있는 통신을 하게 된다.
	- 하지만 UDP든 TCP든 암호화가 되어있지는 않다.

- UDP는 통신의 상태를 알려주지 않는다. 데이터가 어디까지 갔는지도 알려주지 않는다. 따라서 신뢰도 있는 통신이 아니다. 이를 해결하기 위해서 TCP는 먼저 통신상태를 맺는 교섭 단계를 거치고 통신이 끝날 때 까지의 순서를 확인하는 로직을 가지고 있다. 통신 상태는 flags로 확인하고 순서를 확인하는 것은 seq num과 ack num을 통해 확인한다. 

# 클라우드에서 flag
## 포트 스캔은 어떻게 발생하는가?
- UDP는 port가 open된 경우에는 그냥 접근하게 된다. 따로 응답이 없다. close인 경우에는 ICMP가 type 3과 code 3이 오게 된다. 
- TCP는 열려있는 곳에 SYN을 보내면 ACK/SYN이 오게 되고 닫혀있는 곳에 SYN을 보내면 RST/ACK이 오게 된다.
즉 이것으로 열려있는 포트를 확인할 수 있고 어떤 응용프로그램을 사용하고 있는지 확인할 수 있다. 네트워크를 사용하게 되면 이러한 챌린지를 받을 수 밖에 없다. tcp flags로 만들 수 있는 조합은 64개이지만 실제로 사용하는 것은 몇가지이고 나머지에 대한 예외처리를 해놓지 않았기 때문에 문제가 있다. 


# 번외
- 통신이 외부로 나갈 수 있는 필요충분 조건은 IP를 가지고 있어야 한다는 것이다. 내부에서는 IP가 없어도 통신가능하다. 통신은 스위치를 통해서 외부로 나가고 알고 있는 네트워크 까지 가고 그것이 라우터, 게이트 웨이이다. 자신의 IP, 게이트 웨이 IP가 있어야 한다.
- 라우터는 게이트 웨이 기능을 갖고 있는 장비다.
- https://www.malware-traffic-analysis.net/ 에서 오른쪽 exercises에서 여러 튜토리얼으로 와이어샤크 실습가능
- 와이어샤크 `statistics -> conversations` 에서 통신들의 요약 통계를 확인할 수 있고 패킷의 수와 용량도 확인할 수 있다. 어느 IP와의 통신의 비중이 높은지를 먼저 확인