#CS #Network

# 네트워크 
- Local Area Network: 같은 IP 대역으로 통신
	- 네트워크 도메인: 같은 주소로 묶여있는 한 영역
	- 공유기가 LAN 환경을 만들어준다.

- 프로토콜: 컴퓨터 네트워크를 하기 위하여 송수신 장치 간 통일된 통신 규약
	- RFC(Request for Comments): 비평을 기다리는 문서라는 의미, 프로토콜에는 RFC 문서가 있다. 해당 프로토콜에 대해 정리가 되어 있는 공식 문서

## 계층 모델
- 처음에 네트워크가 있었을 때는 P2P였기 때문에 처음에는 규칙이 없었다. 이후 계층화 함. 계층화 되어있지 않고 통으로 되어있다면 중간에 맞지 않는 것만 커스터마이징 할 수 없다. 새로운 규약과 제품이 나오게 되면 해당 계층만 수정하면 된다. 그렇지 않다면 통째로 수정해야한다. 계층마다 각각의 기능에 대해서 분류를 하고 각각의 필요충분 조건을 체크하게 됨.

### OSI 7 Layer
- OSI 7 Layer의 에서 특히 알아야하고 정리해야할 내용
	1. 계층 별 특징
	2. 계층 별 PDU
	3. 계층 별 장비 및 Protocol

프로그램: 실행 파일, 프로세스: 메모리에 올라간 프로그램, 프로세서: 프로세스를 연산처리 하는 것

데이터 앞에 계속 무언가 붙여서 encapsultation한다.
#### 응용계층
- 사용자에게 다양한 Network Service 제공(SMTP, FTP, 가상 터미널 등), User Authentication
- 브라우저, 응용프로그램
- PDU: Data
- Http

#### 표현계층
- App Layer에 대한 Data 전송 Syntax 협의. Data Fromat 결정, 구성. Code 변환. 압축, 인코딩, 암호화, 코덱
	- 과거에는 코덱을 설치해야 했지만 현재에는 코덱을 설치할 필요가 없다 브라우저 표현 계층에서 처리를 해주기 때문이다.
	- 여러 처리를 해줄 수도 있지만 오히려 역으로 안좋은 영향을 줄 수도 있다.
- SSL/TLS

#### 세션계층
- Interhost Communication, Application 사이의 대화 Start, Maintain, Stop
- 포트를 프로세스에 연결해놓는다. 같은 포트로 유입되는 것은 다 똑같은 것으로 보이게 된다. 이를 구분하는 것이 세션이다. 
	- 특정 페이지에서 로그인을 하는 경우 특정 유저만을 위한 페이지가 아니기 때문에 특정 사용자를 구분지어야 한다. 로그인을 했을때 해당 정보를 가지고 있는 이유가 바로 이것이다. 이것을 식별하는 것이 세션이다. 
- 네트워크는 서로 연결이 되면 서로 주고 받는게 가능해진다. 사용자가 접근할 수 있도록 포트를 열어놓고 (리스너)  포트와 응용프로그램을 바인딩함. 
- netstat 명령어는 세션 정보를 보여주는 명령어이다. 사용하고 있는 IP와 Port가 같을 수 있다. 하지만 그에 따른 클라이언트는 다를 수 있다. 서버의 경우에는 같은 포트 번호로 들어오는 요청들을 구분할 필요가 있다. 이에 따라 세션을 관리하는 것이다. 클라이언트 포트가 명시되면 하나의 세션이 된다.

#### 전송계층
- End-to-End Connection, Application 사이에 논리적인 통로 제공, 전송 문제 관리, 신뢰성 있는 전송 보장
- 네트워크 계층 까지는 메모리에서 처리를 한다. 전송 계층은  OS에서. 세션 부터는 어플리케이션에서 처리를 한다.
https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml
- 전송 계층은 데이터를 전송하기 위한 계층이다. 여기서 제일 중요한 것은 포트 번호이다. (포트 => 서비스 => 프로세스) 만약 포트 번호가 없다면 어떤 응용프로그램으로 가는지 매번 체크해야하고 그때마다 딜레이가 발생하게 될 것이다. 네트워크와 응용프로그램을 연결하기 위해서 포트번호를 사용하는 것이고 만약 포트번호가 없다면 랜선만 꽂아놔도 네트워크가 들어올 때 마다 응용프로그램을 확인하기 위해 CPU가 연산처리를 하게 될 것이다. 
- nplookup을 이용해 DNS 확인 가능 
![](images/Pasted%20image%2020221220110248.png)
- `netstat -anv -p TCP` 를 사용하여 포트번호와 PID 확인 가능하다 즉 특정 포트와 프로세스는 매핑되어있음을 확인할 수 있다. `netstat -anv -p TCP | grep 223.130` 을 사용하면 naver.com에 연결 된 것을 확인할 수 있다.
![](images/Pasted%20image%2020221220110643.png)
![](images/Pasted%20image%2020221220110726.png)

>Port numbers are assigned in various ways, based on three ranges: System Ports (0-1023), User Ports (1024-49151), and the Dynamic and/or Private Ports (49152-65535)

- 시스템 포트(0~1023): administrator, root 권한으로 프로그램을 실행(binding)
	- 웹, DNS, SMCP 등 서버 영역
- 유저 포트(1024~49151): user 권한으로 프로그램을 실행
- 다이나믹/ 프라이빗 포트(49152~65535): client port(결국 source port)로 셋팅되는 포트로 OS가 할당해준다.
- OS에 지정되어 있는 포트들이 있기는 하다. FTP(21), TFP-Data(20, active-mode), SSH, SCP, SFTP(22), telnet(23), SMTP(25), DNS(53), TFTP(69, udp), HTTP(80), HTTPS(443), POP3(110), IMAP(143), sql-server(1433), mysql(3306), mariadb(3306), oracle(1521)

원칙적으로는 프로그램을 바인딩하는 포트는 시스템, 유저포트 즉 해당 영역이 서버 영역이다. 그리고 나머지 영역이 클라이언트 영역으로 볼 수 있다. 하지만 OS가 할당하기 때문에 다른 영역에 할당할 수도 있다.  
A에서 B로 가는 통신을 생각해보면 `Start: A, Destination: B, SPort: 지정, DPort: 지정, A: Client. B: Server`  C/S (Client, Server) 구조이다. 출발지와 목적지의 IP, Port 들이 명시되어야 한다.
즉 내가 모르는 포트가 열려있다면 내가 모르는 응용프로그램이 실행되고 있다는 것을 의미하는 것이다.
- PDU: Segment
- tcp/udp

#### 네트워크 계층
- 관리의 목적으로 IP주소를 할당한다. MAC 주소와 IP를 매핑시켜준다. (ARP, 주소변환프로토콜)
	- 원래 하드웨어 정보는 MAC이지만 효과적으로 관리하기 위해서 IP주소를 사용하고 해당 대역을 사용한다고 명시하는 것이다. 
	- 2계층의 경우에는 IP주소를 알 수 없다. 스위치에 연결되어 있는 것 끼리 통신을 할때, 실제로 ping을 날린다면 IP로 통신을 하는 것이 아니라 해당 PC에서 MAC 주소를 받아오고 스위치에 있는 포트와 MAC 정보를 통해서 스위치에 해당 MAC과의 통신을 요청하는 것이다. 
		- ARP에서 브로드캐스팅은 마을에서 휴대전화를 이장이 하나가지고 있고 전화가 오는 경우 이장이 방송으로 전화가 왔다고 알려주는 방식을 생각해보면 된다. 
		- arp -a 로 arp 캐싱 테이블 확인 가능, arp -d로 캐싱 테이블 삭제가능, IP를 통해서 MAC주소를 받아오고 MAC 주소를 학습하게 되는 것을 확인할 수 있다. 브로드캐스트를 쓴다는 단점이 있다. 브로드 캐스트는 들을 수 있는 모든 주소에 통신을 보내는 것이다. 브로드 캐스트는 주소를 찾기 위해서 불필요한 통신을 많이 하게 되고 가용 대역폭(band width)중에서 실제 통신을 위한 대역폭이 줄어들게 되는 것이다. 이러한 경우 낭비를 줄이기 위해서 캐싱을 사용한다. arp cache table에 해당 정보가 있는 경우에는 브로드 캐스팅 하지 않게 된다.
- 논리적인 주소를 사용, 경로 관리, 최적 경로 결정
- PDU: Packet
-  IP, icmp, igmp, ipsec
- 라우터 사용

#### 데이터 링크 계층
- 데이터 전송을 위한 Format 결정, 데이터 전송을 위하여 Media에 접근하는 방법 제공, 물리적인 주소 사용, Error Detection 기능 제공
- PDU: Frame
- LLC(이더넷을 사용하느냐 다른 네트워크 망을 이용하느냐를 정의), MAC(랜카드 하드웨어 어드레스 고유 주소를 나타낸다.)
	- MAC 주소는 vendor의 고유 번호 + 생산 일련 번호, 랜카드 디바이스는 하드웨어 정보이다.(MAC OUI) 같은 네트워크 도메인을 가지는 곳에서 PC1 MAC과 PC2 MAC이 같은 경우 통신이 불가능하게 된다. MAC이 동일하면 어느 곳으로 정보를 보낼지 모르기 때문에 통신할 수 없다. 이러한 경우를 대비헤서 OS 레벨에서 MAC 주소를 변경할 수 있다. 
- topology
	- 원래는 네트워크망을 어떻게 구성했는지 망에 대한 구조를 나타낸다.
	- 네트워크 망 끝에는 PC, 서버(엔드 포인트)가 붙어있을 것이다. 엔드 포인트 때문에 토폴로지가 생겨나게 됨
	- 기업에서 네트워크 망이 어떻게 구성되어있고 엔드 포인트에 무엇이 있는지 까지 나타나있기 때문에 대외비임
	- 보통 스타구조와 트리구조가 혼합된 형태
- 스위치, 스위칭 허브
	- 네트워크 망을 만들기 위해서 사용한다. 전기적 신호를 각각의 엔드포인트로 찢어주는 역할을 한다.
- 전기 신호를 디지털 신호로 바꿨을 때 온전하게 잘 왔는지 확인하기위한 CRC체크가 있다. 
- LLC는 어떤 망을 사용하게 할 것인지를 정한다. (ethernet, IPX 등등) 통신에 대한 링크를 정한다. 

#### 물리 계층
- 물리적인 연결. 전기적, 기계적, 기능적, 절차적인 수단 제공
	- 주파수를 재현하는 경우 해킹할 수 있다. 물리적 해킹
	- 실제 우리가 쓰는 네트워크는 해킹하기 어렵다. 그렇게 간단하지 않고 무엇이 0이고 무엇이 1인지 모르기 때문에 원래 정보를 알기 힘들다.
- PDU: Bit
- 케이블, 커넥터, 증폭기(리피터), hub
	- 허브는 전기적 신호를 모든 포트에 복제해서 한 번에 뿌린다. 

- 와이어샤크
	- 우리가 사용하고 있는 네트워크는 원래 모두 다 메모리에 올라간다. 메모리에 올라가서 담겨져 있는 공간을 back log(queueing) 공간이라고 한다. back log에 담겨졌다가 OS로 가게된다. 
	- protocol header는 반드시 protocol state diagram과 관련이 있다. 통신 정보는 헤더에 담기고 그것을 해결하기 위한 규칙을 state diagram이라고 하고 관련된 정보는 back log에 코딩되어 있다. 즉 back log를 통해 필터링 되어 거절되거나 OS로 넘거가거나 대기하거나 하는 등의 액션을 취하게 된다. https://nmap.org/book/tcpip-ref.html, https://www.cs.uni.edu/~diesburg/courses/cs3470_fa19/projects/p4-tcp.html, (TCP 의 경우이고 다른 프로토콜의 경우에는 다른 다이어그램을 가진다.)
	- 모두 메모리에서 처리하기 때문에 OS에서는 알지 못하고 OS로 넘어갈 수 있는 경우에만 넘어갈 수 있다.
	- 와이어샤크를 이용해서 back log queing 공간을 덤프를 떠서 그래프화 시켜주는 것이다. 
	- back log에 정책을 걸어주면 방화벽이 되고 보안 솔루션이 된다. 

## OSI 참조 모델의 데이터 전송
- A 에서 B로 통신할 때 수 많은 라우터를 거치게 된다. 그렇다면 라우터는 3계층 장비이므로 3계층 까지 decapsulation 하여 사용하기 때문에 실제로 사용자와 접속하는 4 계층에 있는 데이터 부터는 중간에 확인할 수 없다. 또한 라우터는 3계층 장비이므로 스펙이 거기에 맞춰져 있기 때문에 decapsulation을 하게된다면 과부하가 일어나게 될 것이다.
![](images/Pasted%20image%2020221220121239.png)

HTTP는 모두 TCP(80)를 사용하고 있다. HTTP는 처음부터는 암호화를 지원하지 않았다. 이것을 443에 던져서 SSL/TLS(443)가 감싸서 암호화를 하고 이것이 HTTPS이다. 이 과정에서 누군가 중간에 껴서 443에 해당하는 로직을 처리하기만 하면 되는 것이기 때문에 ssl strip이라는 공격이 있다. HTTPS가 완전히 안전하지는 않다.
크롬의 경우는 80으로 던지는 경우 자동으로 HTTPS로 바꾸는 것이 HSTS이다.(프로토콜은 아님, 443으로 잡고있도록 해주는 기술) 엔드포인트 유저들이 크롬 브라우저를 사용할 때 유저들을 보호하기 위한 기술이다. 구글에서 QUIC이라고 불리는 HTTP3를 쓰기 시작함. 클라우드등에 올리는 대부분의 서비스는 웹 서비스이다. 웹서비스에서 사용하는 프로토콜이 많다는 것을 알아둘 필요는 있다.

## IP
IP에 담긴 함축적인 의미를 아는 것이 중요하다. CIDR, 서브넷팅 등에 명시된 IP가 가지는 의미를 해석하는 것이 중요하다. 
https://nmap.org/book/tcpip-ref.html
- IP 헤더: IP 정보를 담기위한 공간, 어떤 정보를 담고 있는지에 대해 나와있다. 
	- 버전, 헤더길이
	- 서비스 타입: 세션 계층에서는 QoS(Quality of Service)라는 것으로 우선순위를 결정한다. 그것을 위한 정보
	- identification: 클라이언트는 서버에 수 많은 요청을 하게 될 텐데 그 요청들을 식별하기 위한 정보이다.
	- fragmentation: 정보를 한 번에 보낼 수 없을 때 정보를 잘라서 보내게 된다. 만약 파일을 다운로드 받는다고 할 때, 같은 Identification이고 분할되었다는 것을 flag 값을 1로 알려준다. 분할의 끝에는 0으로 한다.  이럴 경우 tmp 공간을 이용한다. tmp는 응용프로그램에서 사용한다. 이후 순서에 맞게 재조합하여 해당 파일을 다운로드 받기로한 경로로 옮겨준다. 
		- MTU는 장비와 장비 사이에 정해져 있는 값으로 보통은 1500바이트이다. MTU 사이즈에 맞게 fragmentation을 진행한다. 이 때문에 회선 속도가 빠르더라도 실제로 느릴 수 있다.
	- TTL: TTL이 없다면 잘못된 주소를 통해 가다보면 계속 해당 주소를 찾게되고 네트워크가 마비될 수 있다. TTL은 홉 마다 하나씩 차감되고 0이되면 죽게된다. 
	- source IP address 와 destination address가 있다.

### IP 주소 
- IPv4 하나의 주소 영역을 하나의 옥텟으로 구분하고 있다. 0.0.0.0 ~ 255.255.255.255, 00000000.00000000.00000000.00000000 ~ 11111111.11111111.11111111.11111111 즉 32 bit 주소 체계이다. 처음에 체계가 없을 때에는 IP 주소를 막 할당했기 때문에 IP가 모자라게 됐다. 
- 처음에는 클래스로 나누었었다.  0으로 시작 A클래스(0.0.0.0 ~ 127.255.255.255), 10 으로 시작 B 클래스(128.0.0.0 ~ 191.255.255.255), 110으로 시작 C클래스(192.0.0.0 ~ 223.255.255.255), 1110으로 시작 D클래스, 1111으로 시작 E클래스
- 이후에는 Class less 방식을 주로 사용하게 됐다. 
- 네트워크 주소와 호스트 주소로 구분한다.
	- 네트워크 주소
		- 전체 네트워크를 보다 작은 네트워크로 분할하여 각 호스트가 속한 네트워크를 대표하는 데 사용
		- 브로드 캐스트를 들을 수 있는 주소
		- 8비트 16비트 24비트의 크기로 분류, 앞의 24 비트를 네트워크 주소로 사용한다.
	- 호스트 주소
		- 네트워크 주소로 표현되는 네트워크 내부에서 각 호스트의 주소를 표현
		- 전체 32비트에서 네트워크 주소를 제외한 나머지에 해당
	- 클래스 방식을 추구하고 있지는 않지만 D클래스와 E클래스는 남아있다.
		- D클래스의 경우 멀티 캐스트 용도로 사용한다.(224~239)

### 서브넷 마스크
- 네트워크 주소와 호스트 주소를 구분하는 정보
```
IPv4 주소 ........ : 192.168.0.4
서브넷 마스크 ......... : 255.255.255.0
```
으로 되어있는 경우 아래 세 가지를 확인할 수 있다.
1. 네트워크 ID, 호스트 ID
	- 네트워크 ID: `192.168.0`
	- 호스트 ID: `4`
2. 네트워크 주소와 broadcast 주소( 규칙 존재: 네트워크에서 가장 첫 호스트 주소는 네트워크 주소, 가장 끝 호스트 주소는 브로드 캐스트 주소이다. 통신을 위해 존재하는 규칙으로 해당 주소들은 사용할 수 없다.)
	- 네트워크 주소: `192.168.0.0`
	- broadcast 주소: `192.168.0.255`
	- real host 개수는 254개가 된다. 
3. subneting(네트워크를 나눠서 사용) 유무를 파악

#### 서브넷팅
네트워크를 분리하는 것을 서브넷팅이라고 한다.  host id 를 network id로 가져올 때 마다 호스트 수는 2로 나누어지고 네트워크 수는 2배가 된다. 
- 네트워크 크기를 조절하는 이유는 브로드 캐스트 사이즈 관리와 네트워크 관리를 위함이다.
255.255.255.0 인 경우
- 나누지 않는 경우 
	- 255.255.255.0
	- 11111111.11111111.11111111.00000000 = 2^8 = 256
	- 24 prefix(CIDR 표기법)
- 반으로 나누는 경우 
	- 255.255.255.128
	- 11111111.11111111.11111111.10000000 = 2^7 = 128, subneting 된 네트워크 개수 2
	- 25
- 1/4 로 나누는 경우 
	- 255.255.255.192
	- 11111111.11111111.11111111.11000000 = 2^6 = 64, subneting 된 네트워크 개수 4
	- 26

- 192.168.0.4 / 255.255.255.0 네트워크 주소와 브로드 캐스트 주소는?
192.168.0.0, 192.168.0.255

- 192.168.0.4 / 255.255.255.128 네트워크 주소와 브로드 캐스트 주소는?
192.168.0.0, 192.168.0.127

- 192.168.0.200 / 255.255.255.128 네트워크 주소와 브로드 캐스트 주소는?
192.168.0.128, 192.168.0.255

- 200.200.200.150 / 255.255.255.224 네트워크 주소와 브로드 캐스트 주소는?
200.200.200.128, 200.200.200.159

- 192.168.0.120/26 네트워크 주소와 브로드캐스트 주소는?
192.168.0.64, 192.168.0.127

subnetmast calculator로 쉽게 확인 가능