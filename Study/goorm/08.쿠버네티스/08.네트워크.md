쿠버네티스는 컨테이너를 실행할 컴포넌트가 없다. 따라서 컨테이너 실행을 CRI를 이용해서 하는 것이다. 네트워크에서도 마찬가지로 쿠버네티스는 네트워크를 만들 수 없다. 그래서 이를 CNI를 이용해서 하게 된다. 

파드는 영구적인것이 아니고 언제든지 종료될 수 있다는 것을 기억해야한다. 파드가 재생성되게 되면 IP 주소는 변하게 되어있다. 예를들어 웹 애플리케이션이 DB에 접근해서 데이터를 가져와야하는데 파드가 변하는 경우 IP가 변하여 제대로 찾을 수 없게된다. 따라서 이를 도와주는 것이 필요하게 되고 그것을 service discovery라고 한다. (app이 db를 찾고 front가 app을 찾고 proxy가 front를 찾는 등등)
서비스는 proxy와 LB, service discovery를 지원한다.

# 서비스
서비스는 결국 프록시를 만드는 것이다. 따라서 이는 컴퓨터 리소스가 아니고 네트워크의 가상화된 자원이라고 봐야한다. 
```yaml
apiVersion: v1
kind: Service
metadata:
  name: myapp-svc
spec:
  ports:
  - port: 80
    targetPort: 8080
  selector:
    app: myapp-rs
```
- 여기서 port는 service의 port이고 targetPort는 컨테이너의 port이다.
- 컨트롤러와의 관계처럼 서비스와 파드의 관계도 레이블과 셀렉터를 통해서 이루어지게 된다.

```
NAME                 READY   STATUS    RESTARTS      AGE
pod/myapp-rs-65hs8   1/1     Running   0             60s
pod/myapp-rs-ds5h5   1/1     Running   0             60s
pod/myapp-rs-rqkkq   1/1     Running   0             60s

NAME                      TYPE           CLUSTER-IP      EXTERNAL-IP      PORT(S)        AGE
service/kubernetes        ClusterIP      10.233.0.1      <none>           443/TCP        3d3h
service/myapp-svc         ClusterIP      10.233.36.66    <none>           80/TCP         49s
```
서비스의 ip로 접근하게 되면 각 파드들로 접근하는 것을 확인할 수 있다. 
```
vagrant@kube-control1:~$ curl http://10.233.36.66
Hello World!
myapp-rs-rqkkq
vagrant@kube-control1:~$ curl http://10.233.36.66
Hello World!
myapp-rs-65hs8
vagrant@kube-control1:~$ curl http://10.233.36.66
Hello World!
myapp-rs-ds5h5
```

## 엔드포인트
```
vagrant@kube-control1:$ kubectl get endpoints
NAME              ENDPOINTS                                                 AGE
kubernetes        192.168.56.11:6443                                        3d3h
myapp-svc         10.233.118.110:8080,10.233.73.75:8080,10.233.74.26:8080   95s
```
서비스를 생성하게 되면 엔드포인트가 자동으로 생성되며 이는 파드의 IP와 포트 값을 가지고 있다. 측 서비스를 통해 최종적으로 연결되는 지점에 대한 정보를 가지고 있는 것이다. 
서비스는 수 많은 파드 중에서 셀렉팅을 통해서 그에 해당하는 파드들을 가지고 온다. 즉 셀렉터로 인해서 엔드포인트가 생성되게 된다. 
서비스에 접근하게 되면 서비스는 엔드포인트로 연결해주는 것이다. 프록시의 역할을 하고 있는 것

## 내부 네트워크
clusterIP를 우리가 임의로 정할 수 있지만 할당되어 있지 않은 IP를 선택하는 것은 쉽지 않다. 그리고 예를 들어 웹앱을 띄운다면 DB를 띄워놓고 IP를 찾거나 서비스를 만들어놓고 IP를 알아놓아야한다. 하지만 서비스를 사용하는 경우 해당 서비스의 이름, 도메인을 이용해서 리소스에 접근할 수 있게 된다. 그래서 DB를 띄우지 않고도 앱을 개발할 수 있게 된다. 
```
vagrant@kube-control1:~$ kubectl attach testnet -it
If you don't see a command prompt, try pressing enter.
testnet:~# curl http://myapp-svc
Hello World!
myapp-rs-rqkkq
testnet:~# curl http://myapp-svc
Hello World!
myapp-rs-65hs8
testnet:~# curl http://myapp-svc
Hello World!
myapp-rs-ds5h5
```
풀네임은 `myapp-svc.default.svc.cluster.local`이 된다. 이는 `리소스이름.네임스페이스.타입.도메인명` 이다. 이는 클러스터 내부에서만 사용하는 도메인으로 실제 도메인과 일치시켜서는 안된다. 예를 들어 보통 회사에서는 example.com 도메인을 사용하고 내부망이 있다면 내부 도메인은 example.local을 사용한다.
옛날에는 service discovery를 위한 개발을 하거나 솔루션을 이용했었다고 한다. 

```
vagrant@kube-control1:~$ kubectl attach testnet -it
If you don't see a command prompt, try pressing enter.
testnet:~# host myapp-svc
myapp-svc.default.svc.cluster.local has address 10.233.36.66
```
DNS 서버에 질의하는 host 명령으로 확인해볼 수 있다. 