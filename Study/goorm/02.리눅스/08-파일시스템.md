# 디스크 기본 구조
## 디스크의 물리적인 구조
![450](images/Pasted%20image%2020230102130314.png)

| 부분            | 내용                                                                                                                                            |
| --------------- | ----------------------------------------------------------------------------------------------------------------------------------------------- |
| Platter         | 실제 저장되는 위치, 데이터는 자기장을 기록하여 기록된다. 디스크에는 한개 이상의 플래터가 존재하고, 각 플래터의 양면에 기록된다.                 |
| Spindle         | 플래터를 회전시키는 역할을 한다.                                                                                                                |
| Head            | 플레터에 데이터를 기록하는 기능을 담당한다. 각 플래터의 양면에 각각 1개씩 위치한다.                                                             |
| Actuator        | 디스크 제어 컨트롤러에 의해 디스크 플래터의 원하는 위치에 있는 데이터를 읽어 오기 위해 암을 이동시키는 역할을 한다.                             |
| Actuator Arm    | 각 암마다 한 개씩의 헤드가 붙어있다. 액세스 암이라고도 한다.                                                                                    |
| Connector       | 디스크의 연결 인터페이스 종류에 맞는 케이블 연결을 담당한다. IDE, SATA, SCSI, SA-SCSI 등을 사용한다.                                            |
| Jumper Block    | IDE 인터페이스를 사용하는 하드디스크의 경우 Master, Slave를 결정하기 위한 점퍼를 결정해야한다. 다른 인터페이스의 경우에는 점퍼가 필요하지 않다. |
| Power Connector | 디스크 구동에 필요한 전원케이블을 연결한다.                                                                                                     |
- 블록 장치는 단위 블록으로 데이터를 다룬다. 예를 들어 디스크가 있다.
- 캐릭터 장치는 단위 문자로 데이터를 다룬다. 예를 들어 입출력 장치가 있다.

## 디스크 플래터의 논리적인 구성요소
![](images/Pasted%20image%2020230102130251.png)

| 부분     | 내용                                                                                                                                                                                 |
| -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| Sector   | 플래터의 가장 작은 단위이다. 1개 섹터의 크기는 512byte 이다. 섹터는 디스크 블록으로도 알려져있다.                                                                                    |
| Track    | 섹터가 모여 하나의 원을 구성한다. 트랙은 많은 수의 섹터를 가지고 있으며 플래터 내에 여러 개의 트랙이 존재한다. 가장 바깥쪽의 트랙은 가장 안쪽의 트랙보다 더 많은 섹터를 가지고 있다. |
| Cylinder | 여러 동심 트랙에 대한 스택 구조이다.                                                                                                                                                                                     |

- 섹터가 모여 블록을 이루기도 한다. 보통 4KB 이다. 

## 디스크 파티션
디스크를 사용하려면
1. 디스크를 추가해야한다.
2. 시스템이 인터페이스를 통해 디스크를 인식해야한다.
3. 파티셔닝을 해야한다.
4. 파일 시스템 초기화(포맷)을 해야한다.
5. 리눅스의 경우 디렉토리와 파일 시스템이 구축된 공간인 볼륨을 연결시키는 마운트를 해야한다.
물리적인 디스크는 파티션이라는 단위로 나누어진다. 하나의 디스크를 나누어 사용하면 여러 개의 디스크가 있는 것 처럼 사용할 수 있다.
파티션으로 나누어지면 각 파티션은 개별적으로 관리된다. 각 파티션을 용도에 따라 다양하게 활용할 수 있다.(운영체제별, 저장용 등) 그리고 각 파티션별로 초기화(포맷) 할 수 있다.
x86 시스템에서 디스크 파티션이 구성되는 방식은 두 가지가 있다. 
1. MBR(Master Boot Record) 방식
2. GPT(GUID Partition Table) 방식

### MBR 파티션(Mater Boot Record)
1. 디스크 전체의 파티션 레이아웃을 파티션 테이블에 저장한다.
2. 전체 파티션 중 운영체제 데이터를 가지고 있어 부팅할 수 있는 파티션에 대한 정보를 가지고 있다.
3. 운영 체제 부팅에 사용되는 부트 코드를 가지고 있다.
이와 같은 기능을 제공하기 위해 MBR은 디스크의 첫 번째 섹터를 사용한다. 첫 번째 섹터는 섹터의 LBA 주소가 0번인 섹터를 의미한다.
- LBA(Logical Block Address)
	- 섹터의 논리적인 주소를 의미한다. 예전에는 CHS(Cylinder, Head, Sector) 주소라는 물리적인 주소를 사용하였으나 CHS주소 사용시 디스크 용량 제한 등의 문제로 물리적인 구조와 상관없는 가상 CHS 주소를 사용하며 대부분 LBA주소를 사용하여 섹터를 지정한다.
MBR 파티션 방식의 경우 첫 번째 파티션에서 64 Byte 만큼을 전체 파티션 테이블 용도로 사용한다. 그리고 64 Byte는 다시 16Byte 씩 4개의 각 파티션 테이블로 나누어진다.
파티션 테이블은 아래와 같은 값을 가지고 있다.
- 파티션의 상태(부팅 가능/불가능)
- 파티션의 첫 번째 섹터 주소(CHS)
- 파티션의 종류(파티션 내 파일시스템 정보)
- 파티션의 마지막 섹터 주소(CHS)
- 파티션의 첫 섹터 주소(LBA) - 4 Byte
- 파티션의 섹터 개수 - 4Byte
MBR은 메인보으데서 바이오스  펌웨어를 사용하는 컴퓨터에서 사용하는 파티셔닝 방식으로 최대 4개의 Primary 파티션을 지원하지만 필요할 경우 마지막 파티션을 확장하여 4개 이상 파티션을 사용할 수 있다. 
- Primary Partition: OS를 설치할 수 있는 파티션
- Exteneded Partition: Logical Partition의 정보를 담고 있는 파티션, 데이터의 저장용도로 사용되지 않는 파티션
- Logical Partition: OS를 설치할 수 없고 데이터만 저장가능한 파티션
MBR 파티션의 경우 섹터의 주소를 4 Byte로 저장하고 한 개의 섹터는 512 Byte 이기 때문에 최대 2TB인 한계가 있다. 

### GPT 파티션
EFI/UEFI (Extensible Firmware Interface/ Unified EFI)의 일부에 포함된 디스크 파이션 레이블 레이아웃 표준이다. MBR 파티션 테이블이 첫 번째 섹터만을 사용했던 반면, GPT 파티션 테이블은 더 많은 섹터를 파티션 정보 저장 용도로 사용하고 있다. 
- 파티션의 테이블의 개수가 128개로 늘어났고 각 파티션 테이블 당 128 Byte 씩을 사용할 수 있다.
- 섹터 주소를 64bit로 저장하여 최대 8ZB($10^{21}$ Byte)의 디스크를 사용할 수 있다.
- GPT 중요 데이터를 디스크의 마지막 부분에 복제한다.

# 디스크 이름 및 확인
디스크를 시스템에 연결시키는 인터페이스에 따라서 장치파일 이름이 조금씩 다르게 지정된다.

## 디스크 연결 인터페이스 방식
디스크를 시스템에 연결할 때 사용하는 방식을 연결 인터페이스라고 한다. 연결 인터페이스의 종류에 따라 연결할 수 있는 디스크의 개수, 디스크 통신 속도, 시스템 구동 중 디스크 인식(Hot Plugging)등의 기능이 다르게 동작한다.

### E-IDE(Enhanced - Integrated Drive Electoronics)
- 다른 이름으로 ATA(Advanced Technology Attachment)라고도 부른다. 현재는 거의 쓰이지 않는다.
- 핫 플러깅을 지원하지 않는다. 다스크를 추가 또는 제거할 경우, 시스템을 종료한 상태에서 작업해야한다.
- 메인보드에 2개의 E-IDE 인터페이스를 연결할 수 있다. 그리고 하나의 케이블로 2개의 하드디스크(마스터/슬레이브)를 메인보드에 연결할 수 있다. 최대 4개 하드 디스크를 사용할 수 있다.

### SATA(Serial ATA)
- 현재 대부분의 개인용 PC에서 사용중인 디스크 드라이브 연결 인터페이스
- SATA1, SATA2, SATA3의 규격이 있다.
- 서로 다른 규격을 지원하는 메인보드와 디스크를 연결할 경우 이상 없이 호환되지만, 대신 낮은 규격의 속도로 동작한다.
- 핫 플러깅을 지원하기 때문에 운영 중인 시스템에서도 디스크를 자유롭게 추가하거나 제거할 수 있다.
- 한 케이블 당 한 개의 디스크를 연결할 수 있다. 메인보드의 종류에 따라 10개 이상의 SATA 인터페이스를 제공하는 제품도 있다.
- mSATA(mini SATA)는 플래시 메모리를 사용한 제품으로 노트북에서 많이 사용되는 SATA 인터페이스의 한 종류이다.
- 현재는 PCIe/NVMe 규격을 사용하는 M.2 인터페이스가 mSATA보다 우월한 성능으로 소형 플래시 메모리 저장 방식의 표준으로 자리 자고 있다.

### SCSI(Small Computer System Interface)
- 디스크뿐만 아니라 기타 주변기기들을 시스템에 연결할 수 있는 표준 연결 방식을 의미한다.
- 주변기기를 제어하는 기능이 시스템에 있는 것이 아니라 각 주변기기에 있다. 따라서 시스템의 CPU가 주변 장치를 제어하는 방식에 비해 빠른 성능을 구현할 수 있다.
- 많은 장치를 연결하는 서버를 생각해보면 CPU의 부담을 낮출 수 있다는 장점이 있다. 
- 핫 플러깅을 지원한다.

### SA-SCSI(Serial Attached SCSI:SAS)
- 병렬 통신을 수행하는 SCIS 인터페이스의 직렬 통신 버전이다. 병렬 방식 인터페이스가 신호간섭에 의해 고속 성능 구현이 어렵기 때문에 직렬 전송방식을 사용한다. 
- SATA와 호환성을 이루고 있다. SATA 디스크를 SA-SCSI 인터페이스에 연결하여 사용할 수 있다.

## 리눅스 시스템 스토리지 장치명
리눅스 시스템의 하드웨어 장치는 `/dev` 디렉토리 내에 파일로 생성된다. 디스크 연결 후 생성된 장치 파일명을 사용하여 파티셔닝 작업을 수행한다.
기본적인 장치명 생성 규칙은 다음과 같다.
```
인터페이스별 장치명 + 장치 번호 + [파티션 번호]
```
### E-IDE 인터페이스
- `hd` 장치명을 사용한다. 
- 이후 장치별로 알파벳을 붙인다. 
- 이후 파티션에 번호를 붙인다.
- 최신 리눅스 시스템에서는 `hd` 명령을 사용하지 않는다.

### SATA/SCSI/SA-SCSI
- `sd` 장치명을 사용한다.
- 이후 장치별로 알파벳을 붙인다.
- 이후  파티션에 번호를 붙인다.

### CD-ROM/DVD-ROM 등의 ODD
- `sr` 장치명을 사용한다.
- 이후 장치별로 번호를 붙인다.
- `/dev/cdrom` 이 장치파일에 심볼릭 링크로 되어있다.
```
[root@localhost ~]#ls -l /dev/cdrom 
lrwxrwxrwx. 1 root root 3 Jan  2 15:52 /dev/cdrom -> sr0
```

# 하드디스크 파티셔닝
파티션이란 하나의 디스크를 독립된 영역으로 구분하는 것으로 파티션을 분할하는 작업을 파티셔닝이라고 한다.

## `fdisk`
- x86 시스템의 MBR 파티셔닝을 위해 사용하는 도구로 대화형 메뉴를 통하여 손쉽게 디스크 파티션을 구성할 수 있다.
- 기능: 디스크의 파티션 생성, 삭제, 보기 등 파티션을 관리한다. 

###  `fdisk -l`
- 파티션 테이블을 출력한다. 파티션 정보를 볼 수 있다.
```
[root@localhost ~]#fdisk -l

Disk /dev/sda: 64.4 GB, 64424509440 bytes, 125829120 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk label type: dos
Disk identifier: 0x0009a861

   Device Boot      Start         End      Blocks   Id  System
/dev/sda1   *        2048     2099199     1048576   83  Linux
/dev/sda2         2099200   125829119    61864960   8e  Linux LVM

Disk /dev/sdb: 22.5 GB, 22548578304 bytes, 44040192 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
```
- 장치 파일 이름, 섹터 개수, 부트 코드를 포함하는지, 파티션의 섹터 주소 등을 확인할 수 있다.

### `fdisk 장치 파일명`
- 해당 디스크의 파티셔닝에 대해 접근한다.
- 대화형으로 실행된다. 입력하는 옵션들은 다음과 같다.

| 명령 | 기능                                  | 명령 | 기능                                                  |
| ---- | ------------------------------------- | ---- | ----------------------------------------------------- |
| a    | 부팅 파티션을 설정한다.               | p    | 파티션 테이블을 출력한다.                             |
| b    | BSD 디스크 라벨을 편집한다.           | q    | 작업 내용을 저장하지 않고 종료한다.                   |
| c    | 도스 호환성을 설정한다.               | s    | 새로운 빈 Sun 디스크 라벨을 생성한다.                 |
| d    | 파티션을 삭제한다.                    | t    | 파티션의 시스템 ID를 변경한다.(파일 시스템 종류 변경) |
| l    | 사용 가능한 파티션의 종류를 출력한다. | u    | 항목 정보를 변경, 출력한다.                           |
| m    | 도움말을 출력한다.                    | v    | 파티션 테이블을 검사한다.                             |
| n    | 새로운 파티션을 추가한다.             | w    | 파티션 정보를 디스크에 저장하고 종료한다.             |
| o    | 새로운 빈 DOS 파티션을 생성한다.      | x    | 실린더 개수 변경 등 전문가를 위한 부가적인 기능이다.                                                      |

```
[root@localhost ~]#fdisk /dev/sdb
Welcome to fdisk (util-linux 2.23.2).

Changes will remain in memory only, until you decide to write them.
Be careful before using the write command.

Device does not contain a recognized partition table
Building a new DOS disklabel with disk identifier 0xc4e2bf27.

Command (m for help): 
```

#### `m`
- 도움말 출력
```
Command (m for help): m
Command action
   a   toggle a bootable flag
   b   edit bsd disklabel
   c   toggle the dos compatibility flag
   d   delete a partition
   g   create a new empty GPT partition table
   G   create an IRIX (SGI) partition table
   l   list known partition types
   m   print this menu
   n   add a new partition
   o   create a new empty DOS partition table
   p   print the partition table
   q   quit without saving changes
   s   create a new empty Sun disklabel
   t   change a partition's system id
   u   change display/entry units
   v   verify the partition table
   w   write table to disk and exit
   x   extra functionality (experts only)
```

#### `l`
```
Command (m for help): l

 0  Empty           24  NEC DOS         81  Minix / old Lin bf  Solaris        
 1  FAT12           27  Hidden NTFS Win 82  Linux swap / So c1  DRDOS/sec (FAT-
 2  XENIX root      39  Plan 9          83  Linux           c4  DRDOS/sec (FAT-
 3  XENIX usr       3c  PartitionMagic  84  OS/2 hidden C:  c6  DRDOS/sec (FAT-
 4  FAT16 <32M      40  Venix 80286     85  Linux extended  c7  Syrinx         
 5  Extended        41  PPC PReP Boot   86  NTFS volume set da  Non-FS data    
 6  FAT16           42  SFS             87  NTFS volume set db  CP/M / CTOS / .
 7  HPFS/NTFS/exFAT 4d  QNX4.x          88  Linux plaintext de  Dell Utility   
 8  AIX             4e  QNX4.x 2nd part 8e  Linux LVM       df  BootIt         
 9  AIX bootable    4f  QNX4.x 3rd part 93  Amoeba          e1  DOS access     
 a  OS/2 Boot Manag 50  OnTrack DM      94  Amoeba BBT      e3  DOS R/O        
 b  W95 FAT32       51  OnTrack DM6 Aux 9f  BSD/OS          e4  SpeedStor      
 c  W95 FAT32 (LBA) 52  CP/M            a0  IBM Thinkpad hi eb  BeOS fs        
 e  W95 FAT16 (LBA) 53  OnTrack DM6 Aux a5  FreeBSD         ee  GPT            
 f  W95 Ext'd (LBA) 54  OnTrackDM6      a6  OpenBSD         ef  EFI (FAT-12/16/
10  OPUS            55  EZ-Drive        a7  NeXTSTEP        f0  Linux/PA-RISC b
11  Hidden FAT12    56  Golden Bow      a8  Darwin UFS      f1  SpeedStor      
12  Compaq diagnost 5c  Priam Edisk     a9  NetBSD          f4  SpeedStor      
14  Hidden FAT16 <3 61  SpeedStor       ab  Darwin boot     f2  DOS secondary  
16  Hidden FAT16    63  GNU HURD or Sys af  HFS / HFS+      fb  VMware VMFS    
17  Hidden HPFS/NTF 64  Novell Netware  b7  BSDI fs         fc  VMware VMKCORE 
18  AST SmartSleep  65  Novell Netware  b8  BSDI swap       fd  Linux raid auto
1b  Hidden W95 FAT3 70  DiskSecure Mult bb  Boot Wizard hid fe  LANstep        
1c  Hidden W95 FAT3 75  PC/IX           be  Solaris boot    ff  BBT   
```
#### `p`
- 현재 구성되어 있는 파티션 정보 확인, 파티션 테이블을 출력한다. 
```
Command (m for help): p

Disk /dev/sdb: 22.5 GB, 22548578304 bytes, 44040192 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk label type: dos
Disk identifier: 0xc4e2bf27

   Device Boot      Start         End      Blocks   Id  System
```

#### `n`
- 새로운 파티션을 생성하는 옵션
```
Command (m for help): n
Partition type:
   p   primary (0 primary, 0 extended, 4 free)
   e   extended
Select (default p): p
Partition number (1-4, default 1): 1
First sector (2048-44040191, default 2048): 2048
Last sector, +sectors or +size{K,M,G} (2048-44040191, default 44040191): +500M
Partition 1 of type Linux and of size 500 MiB is set
```
- 파티션 종류, 파티션 번호, 시작 섹터, 마지막 섹터 위치를 지정한다.

## `partprobe`
- `fdisk`로는 파티션 테이블만 만든 것일 뿐이고 실제로는 싱크가 안맞을 수도 있다. 따라서 디스크를 동기화하기 위해 커널에 변경된 파티션의 정보를 인식하도록 해야한다.
- 이 때 `partprobe` 명령어를 사용하고 명령어는 다음과 같다.
```
[root@localhost ~]#partprobe /dev/sdb
```
- `partprobe` 명령어만 사용하면 전체 연결된 디스크들에 대한 파티션 정보를 재인식한다. 인자로 디스크 파일을 지정할 경우 해당 장치에 대한 파티젼 정보만 재인식 한다.

## `gdisk`
- GPT 파티션 방식으로 파티션을 생성한다. 
- 사용법은 `fdisk`와 거의 동일하다. 
- 파티션 시작 위치 및 마지막 위치 지정시 +/- 둘 다 사용 가능하다. -의 경우 사용가능한 섹터 영역의 마지막 위치에서 부터 앞쪽으로 상대적인 위치를 의미한다.
- 파티션 생성 시 즉시 파티션 타입을 지정한다.

# 리눅스 파일 시스템의 종류
컴퓨터가 부팅되고 나면 디스크에 MBR과 파티션 테이블을 통해서 디스크의 구성을 읽게된다. 각 파티션은 특정 파일 시스템으로 포맷되어 있다. 특정 파일 시스템으로 초기화되어 있다면 해당 파티션은 파일의 메타데이터와 저널링 데이터 등의 디스크 정보를 담고 있는 공간과 실제 파일에 대한 데이터 공간으로 구분된다. 리눅스로 생각해보면 inode 공간이 있고 파일 데이터 공간이 블록으로 구성되어 있는 것으로 생각할 수 있다. 물론 구조는 파일 시스템에 따라 각각 다르다. 
## 파일 시스템
- 구조화된 일련의 정보를 구성하는 파일 디렉토리의 집합
- 디스크에 데이터(파일/디렉토리)를 논리적으로 저장하고 관리하는 방식
	- 파일을 어떻게 읽고 쓸지를 정하는 규칙
	- 어떤 구조를 구성하여 파일이나 디렉토리를 관리하느냐에 따라 다양한 형식의 파일 시스템이 존재
```
[root@localhost ~]#fdisk /dev/sdb
Welcome to fdisk (util-linux 2.23.2).

Changes will remain in memory only, until you decide to write them.
Be careful before using the write command.

Device does not contain a recognized partition table
Building a new DOS disklabel with disk identifier 0xc4e2bf27.

Command (m for help): 
```

## 리눅스 고유의 디스크 기반 파일 시스템
- ext1
- ext2
- ext3
	- 저널링 기능 도입
- ext4
	- 1EB 이상의 볼륨과 16TB 이상의 파일을 지원
	- 리눅스 기본 디스크 기반 파일 시스템

- 저널링: 파일의 읽기, 쓰기, 삭제에 대한 정보를 디스크에 기록해놓는다. 즉 우리 컴퓨터에서 무슨 일이 있었는지 기록해놓는 것이다. 저널링을 이용하여 디스크를 원하는 시기로 복원할 수 있다. 
- 디스크 파티션: 디스크에서 사용할 공간을 지정한 것
- 파티셔닝: 디스크의 파티션을 구획하는 작업 및 방식
	- 디스크를 사용하기 위해서는 파티셔닝부터 해야한다. 
	- 포맷을 하면 해당 파티션에 파일시스템이 구성된다.
- 볼륨: 파일시스템이 구성된 파티션 또는 전체 공간도 파티션이라고 한다.

- 레드햇의 경우에는 보통 `xfs` 파일 시스템을 사용한다.
```
[root@localhost test]#df -Th
Filesystem              Type      Size  Used Avail Use% Mounted on
devtmpfs                devtmpfs  903M     0  903M   0% /dev
tmpfs                   tmpfs     919M     0  919M   0% /dev/shm
tmpfs                   tmpfs     919M   41M  879M   5% /run
tmpfs                   tmpfs     919M     0  919M   0% /sys/fs/cgroup
/dev/mapper/centos-root xfs        38G  4.8G   33G  13% /
/dev/sda1               xfs      1014M  239M  776M  24% /boot
/dev/mapper/centos-home xfs        19G   37M   19G   1% /home
tmpfs                   tmpfs     184M   40K  184M   1% /run/user/0
```

- 리눅스에서 지원하는 기타 파일 시스템
	- 파티션에 파일을 읽고 쓰는 규칙과 관련되어 있다.

| 파일 시스템 | 기능                                                             |
| ----------- | ---------------------------------------------------------------- |
| msdos       | MS-DOS 파티션을 사용하기 위한 파일 시스템이다.                   |
| iso9660     | CD-ROM, DVD의 표준 파일 시스템으로 읽기 전용으로 사용된다.       |
| nfs         | network file system으로 원격 서버의 디스크를 연결할 때 사용된다. |
| ufs         | Unix file system으로 유닉스의 표준 파일 시스템이다.              |
| vfat        | 윈도우즈 95,98, NT를 지원하기 위한 파일 시스템이다.              |
| hpfs        | HPFS를 지원하기 위한 파일 시스템이다.                            |
| nfts        | 윈도우즈의 NTFS를 지원하기 위한 파일 시스템이다.                 |
| sysv        | 유닉스 시스템V를 지원하기 위한 파일 시스템이다.                  |
| hfs         | macOS의 hfs 파일 시스템을 지원하기 위한 파일 시스템이다.                                                                 |

- nfs와 samba가 있고 어느 운영체제와 네트워크 연결을 하느냐에 따라 다르다.
- fat 계열에는 fat16, fat32, fat64(exfat) 등이 있다. 파일 크기 제한이 작아서 요즘 잘 사용하지 않는다. USB 포맷에 사용한다.
- 윈도우즈에서는 주로 NTFS와 fat 계열을 사용한다.

- 리눅스의 가상 파일 시스템
	- 디스크 공간을  색다른 방식으로 사용할 때 사용

| 파일 시스템 | 기능                                                                                                                                                                     |
| ----------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| swap        | 스왑 영역을 관리하기 위한 스왑 파일 시스템이다.                                                                                                                          |
| tmpfs       | - temporary file system으로 메모리에 임시 파일을 저장하기 위한 파일 시스템이며, 시스템이 재시작 할 때마다 기존 내용이 없어진다. <br>- `/tmp` 디렉토리로 예를 들 수 있다. |
| proc        | - proc 파일 시스템으로 `/proc` 디렉토리이다. <br>- 프로세스 정보, 커널의 현재 상태를 나타내는 파일을 가지고 있다. 메모리에 임시로 저장한다.                              |
| ramfs       | 램디스크를 지원하는 파일시스템이다. 메모리를 하드디스크 처럼 사용하는 방식.                                                                                              |
| rootfs      | - root file system으로 `/` 디렉토리이다. <br>- 시스템 초기화 및 관리에 필요한 내용을 관리한다.                                                                           |
| devtmpfs    | 장비 관련 임시 파일 시스템                                                                                                                                                                         |

- `/proc/filesystems` 에 현재 커널이 지원하는 파일 시스템들이 나와있다.
```
[root@localhost test]#cat /proc/filesystems 
nodev	sysfs
nodev	rootfs
nodev	ramfs
nodev	bdev
nodev	proc
nodev	cgroup
nodev	cpuset
nodev	tmpfs
nodev	devtmpfs
nodev	debugfs
nodev	securityfs
nodev	sockfs
nodev	dax
nodev	bpf
nodev	pipefs
nodev	configfs
nodev	devpts
nodev	hugetlbfs
nodev	autofs
nodev	pstore
nodev	mqueue
nodev	selinuxfs
	fuseblk
nodev	fuse
nodev	fusectl
	xfs
nodev	rpc_pipefs
nodev	binfmt_misc
```

# 리눅스 파일 시스템의 구조
## 리눅스의 모든 파일 시스템의 기본 개념
- 파일은 inode로 관리된다.
- 디렉토리는 단순히 파일의 목록을 가지고 있는 파일일 뿐이다.
- 특수 파일을 통해 장치에 접근할 수 있다. 
## ext4 파일 시스템의 구조
- 파일시스템 전체에 대한 주요 정보는 슈퍼 블록에 저장된다.
- 효율적으로 디스크를 사용하기 위해 저장 장치를 논리적인 블록의 집합(블록 그룹)으로 구분
- 슈퍼 블록의 백업이 일부 블록 그룹에 저장된다.
- inode를 사용하여 파일의 메타정보와 데이터를 분리하여 저장한다.ㄴ
- 일반적으로 블록은 4KB이고 실제 크기는 시스템의 설정에 따라 변경 가능
- 블록 그룹 유형
	- 블록 그룹 0: 파일 시스템의 첫 번째 블록 그룹으로 특별하게 그룹 0 패딩과 슈퍼블록, 그룹 디스크립터를 가지고 있다.
	- 블록 그룹 a: 파일 시스템에서 첫 번째 블록 그룹이 아닌 블록 그룹으로 그룹 0 패딩이 없으나 슈퍼블록과 그룹 디스크립터에 대한 복사본을 가지고 있다.
	- 블록 그룹 b: 파일 시스템에서 첫 번째 블록 그룹이 아닌 블록 그룹으로 그룹 0 패딩, 슈퍼블록, 그룹 디스크립터가 없고 바로 데이터 블록 비트맵으로 시작한다.

![](images/Pasted%20image%2020230103112824.png)

### 패딩
- 블록 그룹 0의 첫 1024byte는 x86 부트섹터 등의 용도로 사용하기 위하여 패딩으로 비워져있다.

### 슈퍼블록
- 파일 시스템 전체에 대한 정보들을 저장하고 있다. 
- 파일 시스템 전체와 관련된 중요한 정보를 가지고 있기 때문에 슈퍼 블록이 손상될 경우 전체 파일 시스템의 작동에 장애가 발생한다. 따라서 중요한 데이터는 다른 블록 그룹에 백업 슈퍼 블록으로 백업된다. 그리고 이 복사본을 사용하여 복구한다.

### 그룹 디스크립터, 예약된 GDT블록
- 블록 그룹에 대한 정보를 가지고 있다.
- 예약된 GDT 블록은 그룹 디스크립터의 확장을 위해 예약된 블록이다.
- 이 정보 또한 중요하기 때문에 다른 블록 그룹에 백업된다.

### 데이터 블록 비트맵, inode 비트맵
- 비트맵은 데이터 블록/inode 용도로 지정된 블록들 중 사용 중인 블록과 사용하지 않는 블록을 체크하기 위한 영역이다.
- 각 블록의 사용여부를 체크하기 위하여 비트맵 목록에서 각 1bit씩 사용한다.

### inode 테이블
- 파일에 대한 정보를 가지고 있는 inode가 모여있는 테이블이다. 
- inode는 각각 1개의 파일 또는 디렉토리에 대한 정보를 가지고 있다.
- 파일의 종류 및 권한 정보, 파일 소유자의 UID, 파일의 크기, 파일의 접근시간, 변경시간, 수정시간, 파일의 소유그룹, 하드링크, 실제 파일 데이터가 들어있는 데이터 블록의 주소 등등

#### 포인터
- 각 inode의 데이터 블록 영역의 파일을 가리킨다.
- 직접 포인터
	- 데이터 블록의 주소를 가지고 있는 포인터
	- 파일의 크기가 작은 경우 직접포인터 만으로 파일의 데이터 블록을 전부 지정할 수 있지만, 파일의 크기가 커질 경우 간접 포인터를 사용해야한다.
- 단일 간접 포인터
	- 데이터 블록의 한 블록을 가리키고 있지만 그 데이터 블록에는 다른 블록을 가리키는 주소가 들어있다.
- 이중, 삼중 간접 포인터
	- 간접 포인터의 단계가 추가 되는 것이다. 
파일 시스템에서 사용할 수 있는 최대 파일의 크기는 리눅스 시스템의 블록의 크기에 따라 결정된다.

### 데이터 블록
- 실제 데이터가 들어있는 블록
- inode 포인터가 파일의 데이터를 가지고 있는 데이터 블록의 주소를 가지고 있다. 

## xfs 파일 시스템
- 최신 버전의 리눅스에서 기본 파일 시스템으로 사용되고 있다.
- 저널링 기능을 제공하고 저널링 기능에 의한 성능 저하 영향을 최소화하였다.
- 64bit를 지원하는 파일 시스템으로 대용량의 파일 시스템을 사용할 수 있다.
- 구조적인 특징은 다음과 같다.
	- inode를 사용한다. 내부 구조는 ext4와 다르다.
	- ext4의 블록 그룹 대신 할당 그룹(Allocation Group) 용어를 사용한다. 기본적으로 볼륨을 8개의 할당 그룹으로 분할한다. 8개 이상으로 분할할 수 있다.
	- 파일 탐색을 위해 B+ 트리를 사용한다.



### 슈퍼블록
- 전체 할당 그룹들에 대한 정보를 저장하는 용도로 사용된다.
- 첫 번째 할당 그룹의 슈퍼 블록이 사용되고 두 번째 이후 할당 그룹의 슈퍼 블록은 백업 용도로 존재하며 복구에사용된다.

### AG free block info
- 할당 그룹의 미할당 영역에 대한 정보를 가지고 있다. 
- 할당 그룹 구조의 Root of free space B+tree 항목과 연관이 있다.

### AG inode B+tree info
- 할당 그룹의 할당 영역에 대한 정보를 가지고 있다.
- 할당 그룹 구조의 Root of inode B+tree 항목과 연관이 있다.

### AG free list
- B+tree 영역을 확장하기 위하여 예약된 공간이다.

### inodes
- 할당 그룹 내 각 파일에 대한 inode의 집합이다.

### data blocks
- 실제 데이터가 저장되는 영역이다. 

## 파일 시스템 생성하기
- 파일 이스템은 이 파티션에서 파일과 디렉토리를 관리하기 위한 구조를 만드는 것
- `lsblk`(list block devices)를 통해 블록 장치와 파일시스템들을 확인할 수 있다.
### `mkfs`
- 기능: 리눅스 파일 시스템을 만든다.
- 형식: `mkfs [옵션] [장치명]`
- 옵션
	- `-t 종류`: 파일 시스템의 종류를 지정
		- `mkfs.파일시스템` 의 형태로 사용할 수도 있다. 해당 바이너리 파일들이 존재함

```
[root@localhost ~]#mkfs -t ext4 /dev/sdb1
mke2fs 1.42.9 (28-Dec-2013)
Filesystem label=
OS type: Linux
Block size=4096 (log=2)
Fragment size=4096 (log=2)
Stride=0 blocks, Stripe width=0 blocks
131072 inodes, 524288 blocks
26214 blocks (5.00%) reserved for the super user
First data block=0
Maximum filesystem blocks=536870912
16 block groups
32768 blocks per group, 32768 fragments per group
8192 inodes per group
Superblock backups stored on blocks: 
	32768, 98304, 163840, 229376, 294912

Allocating group tables: done                            
Writing inode tables: done                            
Creating journal (16384 blocks): done
Writing superblocks and filesystem accounting information: done
```

```
[root@localhost ~]#mkfs.xfs /dev/sdb4
meta-data=/dev/sdb4              isize=512    agcount=4, agsize=196608 blks
         =                       sectsz=512   attr=2, projid32bit=1
         =                       crc=1        finobt=0, sparse=0
data     =                       bsize=4096   blocks=786432, imaxpct=25
         =                       sunit=0      swidth=0 blks
naming   =version 2              bsize=4096   ascii-ci=0 ftype=1
log      =internal log           bsize=4096   blocks=2560, version=2
         =                       sectsz=512   sunit=0 blks, lazy-count=1
realtime =none                   extsz=4096   blocks=0, rtextents=0
```

- 섹터 크기, 블록 크기 등등 파일시스템이 어떻게 구성되었는지 대략적으로 확인 가능하다.

## 파일 시스템과 디렉토리 계층 구조
- 디렉토리 계층 구조는 리눅스의 전체 파일과 디렉토리를 어떤 구조로 정리하고 관리할 것인지를 정의한 것
- 실제 파일이 저장되어 있는 파일 시스템은 디렉토리 계층구조에 연결되어야 사용자가 접근 가능
### 한 파일 시스템으로 구성하기
- 디렉토리 계층 구조에서 보이는 모든 디렉토리와 파일을 하나의 파일 시스템으로 구성
### 여러 파일 시스템으로 구성하기
- 디렉토리 계층 구조를 여러 파일 시스템으로 구분하여 구성
- 여러 파일 시스템으로 나누어 디렉토리 계층 구조를 구성할 경우, 일부 파일 시스템에 문제가 생기더라도 다른 파일 시스템의 파일은 안전하다.

# 파일 시스템 마운트

## 마운트
- 파일 시스템을 디렉토리 계층 구조의 특정 디렉토리와 연결하는 것을 의미한다.
- 디렉토리 계층 구조에서 파일 시스템이 연결되는 디렉터리를 마운트 포인트라고 한다.

### 파일 시스템 마운트 설정 파일
- 리눅스에서 시스템이 부팅 될 때 자동으로 파일 시스템이 마운트 되게하려면 `/etc/fstab` 파일에 설정해야한다.
- 설정하지 않으면 다시 부팅하는 경우 마운트 되어있지 않다. 

## 마운트 관련 명령
### `mount`
- 기능: 파일 시스템을 마운트 한다.
- 형식: `mount [옵션] [장치명 또는 마운트 포인트]`
- 옵션:
	- 지정하지 않는 경우 마운트 정보를 확인할 수 있다.
	- `-t 파일 시스템 종류`: 파일 시스탬 종류를 지정한다.
	- `-o 마운트 옵션`: 마운트 옵션을 지정한다.
	- `-f`: 마운트할 수 있는지 점검만 한다.
	- `-r`: 읽기만 가능하게 마운트한다.

```
[root@localhost /]#ll /mnt/disk1
total 0
[root@localhost /]#mount /dev/sdb1 /mnt/disk1
[root@localhost /]#ll /mnt/disk1
total 16
drwx------. 2 root root 16384 Jan  3 12:11 lost+found
[root@localhost /]#touch /mnt/disk1/1234
[root@localhost /]#ll /mnt/disk1
total 16
-rw-r--r--. 1 root root     0 Jan  3 12:48 1234
drwx------. 2 root root 16384 Jan  3 12:11 lost+found
[root@localhost /]#umount /dev/sdb1
[root@localhost /]#ll /mnt/disk1
total 0
[root@localhost /]#mount /dev/sdb1 /mnt/disk4
[root@localhost /]#ll /mnt/disk4
total 16
-rw-r--r--. 1 root root     0 Jan  3 12:48 1234
drwx------. 2 root root 16384 Jan  3 12:11 lost+found
```
- 마운트 되지 않으면 정보를 확인할 수 없는 것과 다른 디렉토리에 마운트하더라도 해당 파티션에는 데이터가 계속 존재하는 것을 확인할 수 있다.
- 옵션을 지정하지 않으면 사전에 지정된 `defaults`라는 옵션의 집합이 사용된다.

| 옵션     | 설명                                                |
| -------- | --------------------------------------------------- |
| `rw`     | 파일 시스템을 읽기/쓰기 가능 상태로 마운트한다.     |
| `suid`   | 파일 시스템 내 파일의 SetUID 설정을 사용할 수 있다. |
| `dev`    | 파일 시스템 내의 블록장치/캐릭터장치를 해석한다.    |
| `exec`   | 파일시스템 내 바이너리 파일을 실행할 수 있다.       |
| `auto`   | `mount` 명령의 `-a` 옵션으로 마운트한다.            |
| `nouser` | 관리자가 아닌 일반사용자에 의한 마운트를 금지한다.  |
| `async`  | 파일시스템의 입출력을 비동기로 처리한다.            | 

- 일부 옵션들은 옵션 앞에 `no`를 붙여 반대 의미로 사용할 수 있다. (`nosuid`, `nodev`, `noexec`, `noauto` ...)

| 옵션      | 설명                                                       |
| --------- | ---------------------------------------------------------- |
| `ro`      | 파일시스템을 읽기 전용 모드로 마운트한다.                  |
| `atime`   | 파일 inode의 접근 시간의 갱신을 허용한다.                  |
| `remount` | 파일시스템을 다시 마운트한다. 마운트 옵션 수정시 사용한다. |
| `sync`    | 파일 입출력을 동기 방식으로 처리한다.                      | 

- 연속된 데이터의 기록 시, 동기식은 이전 데이터의 기록을 확인 한 뒤에 이후의 데이터를 기록한다. 따라서 디스크의 입출력 속도가 저하되고 빈도는 증가하기 때문에 디스크 수명에 영향을 줄 수 있다. 비동기식은 이전데이터의 기록을 확인하지 않고 데이터를 버퍼로 전송한다. 따라서 비동기식은 데이터가 즉시 기록되지 않을 가능성이 있어 데이터가 손실될 수도 있다.
- mount 명령은 `/etc/mtab` 파일을 참고하여 정보를 출력한다. 해당 파일은 파일시스템이 마운트 될 때 변경되는 정보를 저장하고 있다. 그리고 시스템에 의하여 자동으로 업데이트 되는 파일이므로 사용자가 임의로 수정하는 것을 금지하여야 한다. 

### `umount`
- 기능: 파일 시스템을 언마운트한다.
- 형식: `unmount [옵션] [장치명 또는 마운트포인트]`
- 옵션:
	- `-t 파일 시스템 종류`: 파일 시스탬 종류를 지정한다.

### 파일시스템 테이블(File System Table)
- 시스템은 전원이 종료될 때 마운트된 파일 시스템을 전부 해제한다. 그리고 시스템 전원이 다시 시작되면 특정 파일에서 파일 시스템의 마운트 정보를 읽어 파일시스템을 마운트한다. 
- `mount` 명령으로는 해당 파일에 저장되지 않기 때문에 해당 파일에 파일 시스템에 대한 마운트 정보를 등록해야 한다. 이 파일이 바로 파일시스템 테이블이고 경로는 `/etc/fstab` 이다. 
- 파일에서의 라인의 형태는 다음과 같다.
```
[장치명] [마운트 포인트] [파일 시스템 종류] [마운트 옵션] [덤프 관련 설정] [파일 점검 옵션]
```

#### 장치명
- 파일시스템의 파티션 장치명 또는 파일시스템의 UUID 값이 지정된다.
- 파티션 장치명을 사용할 경우 물리적 장치를 해제했다가 연결할 경우 이름이 변경되는 경우가 발생하기 때문에 UUID 사용을 권장한다.

#### 마운트 포인트
- 마운트 포인트가 필요할 경우에는 경로를 지정하고 필요하지 않는 경우는 swap 또는 none으로 지정한다.

#### 파일 시스템 유형
- 파일 시스템 유형을 지정한다.

#### 마운트 옵션
- `-o` 옵션과 함께 사용하는 세부 옵션을 `,`로 구분하여 입력한다.

#### 덤프
- 덤프 명령어 사용시 백업 설정
- 덤프 해야할 파일시스템의 경우 `1` 필요 없을 경우 `0`을 지정한다.

#### 파일점검옵션
- 시스템 부팅시 파일 시스템 체크 명령인 `fsck`에 의한 체크 여부에 대한 설정
- 필요하지 않은 경우 `0`, 체크가 필요한 경우 `1`을 지정
- 이 숫자는 파일 시스템 체크 우선순위로 `1`은 루트에만 사용할 것을 권장하고 일반 파일시스템은 `2` 이후의 값을 지정할 수 있고 같은 값을 가지는 경우 동시에 파일시스템 체크가 수행된다.

파일시스템 테이블에 등록하고 나서는 `mount -a`로 파일시스템 테이블에 등록된 항목 중 마운트 되지 않은 항목을 마운트한다. 파일 시스템 테이블 설정에 오류가 있는 상태에서 시스템을 재부팅 할 경우 정상적으로 시스템 부팅이 되지 않는 현상이 발생한다. 이 경우 파일시스템 테이블을 수정하기 위하여 emergency.target 모드 또는 rescue.target 모드로 시스템을 부팅해야한다.

# 스왑 메모리
시스템에서 실행할 프로그램은 메모리에 올라간 후에 CPU에 의해 읽혀지고 실행된다. 디스크에 프로그램이 저장되어 있더라도 프로그램이 실행되려면 결국엔 프로그램이 메모리에 로드되어 프로세스가 되어야한다. 하지만 물리 메모리인 RAM의 용량 확장에는 제한이 있기 때문에 물리 메모리가 부족한 경우를 해결하기 위하여 가상 메모리를 이용한다.
## 가상 메모리
가상 메모리는 물리 메모리(RAM) + 스왑(swap)이다. 스왑은 디스크 장치에 생성되는 영역을 의미한다. 운영체제의 가상 메모리를 관리하는 가상메모리 관리자는 물리메모리와 스왑 영역을 합산하여 가상메모리로 사용한다.
하지만 CPU가 스왑 영역에 있는 데이터를 물리 메모리 처럼 직접 접근하여  읽을 수 있는 것은 아니다. 프로세스가 스왑 영역에 존재한다면, 스왑 영역의 데이터를 물리 메모리 영역으롤 이동시키는 작업이 필요하고 이 작업을 페이지 인(Paged-in)이라고 한다. 반대로 물리 메모리에 위치한 프로세스의 우선순위가 낮거나 당분간 사용하지 않을 경우 스왑 영역으로 이동하는 작업이 필요하고 이 작업을 페이지 아웃(Paged-out)이라고 한다. 그리고 페이지 인과 페이지 아웃을 통틀어 페이징이라고 한다.
가상 메모리를 사용하면 물리 메모리의 부족한 부분을 어느 정도 해결할 수 있다. 하지만 페이징 작업은 디스크 입출력을 많이 발생시키기 때문에 디스크 성능을 저하시킨다. 디스크 입출력이 많은 시스템의 경우에는 스왑 영역을 최소한으로 두어야하며 디스크 입출력은 적으나 실행할 프로세스가 많은 시스템의 경우 스왑 영역을 무리 메모리의 2배 이상 설정한다.
스왑 영역을 구성하는 방식은 스왑 파티션과 스왑 파일 두 가지 방식이 있다. 
### 스왑 파티션
- 파티션 전체를 스왑 영역으로 사용하는 방식
- 파일시스템의 개입 없이 파티션 전체가 스왑으로 동작하므로 성능 저하가 일어나지 않는다.
- 전용 파티션을 확보하기 어려울 수 있다.
### 스왑 파일
- 파일시스템 내 파일을 생성하고, 이 파일을 스왑 영역으로 사용하는 방식
- 파일시스템이라는 중간 단계가 존재하기 때문에 스왑 파티션에 비해 성능이 떨어질 수 있다. 파티션의 경우 디스크에서 연속된 공간에 위치하지만, 파일 시스템 내의 파일형태로 저장된 스왑 파일은 디스크에서 연속된 공간을 할당받지 못 할 수도 있기 때문이다.
- 별도의 파티션 확보가 필요하지 않다.

## 스왑 영역 구성
### 스왑 영역 확인: `swapon -s`, `free -h`
- `swapon` 명령은 스왑영역의  활성화와 스왑 영역 확인에 사용한다.
	- `-s` 옵션을 함께 사용하면 활성화된 스왑 영역의 목록과 유형, 사이즈, 사용량, 우선순위가 출력된다.
- `free`: 명령은 전체 물리 메모리의 사이즈 및 사용량, 스왑 영역의 사용량 등을 출력한다.

### 스왑 파티션 생성
- 먼저 `fdisk`로 디스크를 파티셔닝 해야한다. 
	- `t` 명령으로 파티션 타입을 스왑 장치용 파티션으로 바꿔야한다.
- `mkswap [파티션 파일]` 명령으로 파티션에 스왑 영역을 생성한다.

### 스왑 파일 생성
- 파일시스템 아래 파일을 생성하여 그 파일을 스왑 영역으로 사용한다.
	- 루트 파일 시스템에 스왑 파일을 생성할 경우 시스템 성능 저하가 발생할 수 있다.
- 먼저 `dd` 명령을 사용해 스왑 파일을 생성한다.
	- `/dev/zero` 파일은 실제로 널 값을 갖고 있는 가상파일이다. 무한히 널 값을 제공한다. 특정한 길이의 초기화된 더미 파일을 임시 스왑 파일로 만드는데 주로 쓰인다. 
	- `if`에는 복사할 파일을
	- `of`에는 생성될 파일을
	- `bs`에는 복사할 때 사용할 블록의 크기를 byte 단위로
		- K 등의 단위로 해도 된다.
	- `count`에는 복사할 횟수를 지정한다.
		- M 등의 단위로 해도 된다.

### 스왑 영역 활성화
```
swapon [option] {partition | file-name}
```
으로 시스템에서 스왑 영역이 사용될 수 있도록 활성화 해야한다.
- 옵션:
	- `-a`: `/etc/fstab` 파일을 참고하여 스왑영역을 활성화한다.
	- `-p`: 스왑 영역을 활성화 할 때 우선순위를 지정한다.
	- `-s`: 활성화된 스왑 영역의 정보를 출력한다.
- 스왑도 파일 시스템과 마찬가지로 시스템의 전원이 종료될 때 해제되며 시스템의 전원이 시작될 때 파일시스템 테이블에 등록되어 있지 않으면 자동으로 활성화 되지 않는다.
	- 마운트포인트는 필요하지 않다. swap으로 작성한다.
	- 파일시스템 종류는 swap으로 작성한다.
	- 스왑 영역은 덤프를 사용하지 않는다.
	- 스왑 영역은 파일시스템 체크를 필요하지 않는다.
- 스왑 파일로 만든 스왑 영역을 활성화 할 때 파일을 소유한 사용자에게만 읽기와 쓰기 권한을 부여할 것을 권장한다.

### 스왑 영역 비활성화
```
swapoff [option] {partition | file-name | UUID}
```

# LVM
디스크의 용량이 부족할 때 여러 개의 디스크를 하나의 디스크 처럼 사용한다.
## LVM의 기본 개념
- LVM은 독립적으로 구성된 디스크 파티션을 하나로 연결하여 한 파티션 처럼 사용할 수 있도록 해준다.
- 디스크 파티션의 구조와 상관없이 원하는 크기의 논리 볼륨을 생성할 수 있다. 단일 디스크 크기보다 큰 볼륨을 생성할 수 있다.
- 논리 볼륨으로 생성된 볼륨의 사이즈가 부족할 경우 볼륨을 확장할 수 있다. 이때 볼륨 내의 데이터를 그대로 유지한 상태에서 볼륨 확장이 가능하다.
- 데이터를 유지한 상태에서 논리 볼륨을 구성하고 있는 디스크를 제거하는 것이 가능하다.
- 논리 볼륨 생성시 RAID를 적용한 볼륨을 생성할 수 있다.
- 스냅샷 기능을 사용할 수 있다.
![](images/Pasted%20image%2020230103163458.png)

- LVM 관련 용어
	- PV(Physical volume):`/dev/sdb1` 같은  실제 하드디스크 파티션을 의미
	- VG(volume group): 여러 개의 PV를 그룹으로 묶은 것을 뜻한다.
	- LV(logical volume): VG를 다시 적절한 크기의 파티션으로 나눌 때 각 파티션을 LV라고 한다.
	- PE(physical extent): PV가 가진 일정한 블록을 의미
	- LE(logical extent): LV가 가진 일정한 블록을 의미
### 물리 볼륨
- 논리 볼륨을 구성하기 위한 가장 기본적인 단계
- 디스크 전체 또는 일부를 파티션으로 지정하고 그 파티션으로 물리 볼륨을 생성한다. 볼륨그룹의 하나의 요소가 된다.
- 논리 볼륨의 메타데이터를 저장하는 영역이 있어 논리 볼륨의 정보를 복구할 때 사용할 수 있다.
### 볼륨 그룹
- 1개 이상의 물리 볼륨의 집합으로 구성되어 있다. 총 사이즈는 해당 볼륨 그룹에 포함된 물리 볼륨 사이즈의 합이다.
- PE(Pysical Extent)의 크기를 지정할 수 있다. 논리 볼륨 생성 또는 확장 시 사용할 수 있는 최소 단위를 의미한다. 기본값은 4MB
### 논리 볼륨
- 볼륨 그룹에서 지정한 만큼의 사이즈를 할당 받는다.
- 사이즈는 MB, GB 같은 단위를 입력하거나 PE의 개수를 지정한다. 
- 씬 프로비저닝 형태로 생성할 경우 볼륨 그룹의 크기보다 더 큰 사이즈의 논리 볼륨을 생성할 수 있다.

## 논리 볼륨 생성
물리 볼륨 생성 -> 볼륨 그룹 생성 -> 논리 볼륨 생성 의 세 단계를 거쳐야 한다.

### 1. 물리 볼륨을 생성하기 위한 파티션 생성
- 물리 볼륨은 파티션 단위로 생성하기 때문에 먼저 파티션을 생성한다.
- 파티션 타입은 Linux LVM 으로 설정한다.
```
[root@localhost ~]#fdisk -l /dev/sdb

Disk /dev/sdb: 22.5 GB, 22548578304 bytes, 44040192 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk label type: dos
Disk identifier: 0xd0bac52e

   Device Boot      Start         End      Blocks   Id  System
/dev/sdb1            2048     8390655     4194304   8e  Linux LVM
/dev/sdb2         8390656    16779263     4194304   8e  Linux LVM
/dev/sdb3        16779264    29362175     6291456   8e  Linux LVM
/dev/sdb4        29362176    41945087     6291456   8e  Linux LVM
```

### 2. 물리 볼륨 생성
- 준비된 파티션을 사용하여 물리 볼륨을 생성한다.
- `pvcreate` 명령을 사용한다.
	- `pvcreate partition1 partition2 ...` 
- `pvscan` 으로 PV 상태를 확인한다.
- `pvremove [파티션이름]` 으로 PV를 삭제할 수 있다.
```
[root@localhost ~]#pvcreate /dev/sdb1 /dev/sdb2 /dev/sdb3 /dev/sdb4
  Physical volume "/dev/sdb1" successfully created.
  Physical volume "/dev/sdb2" successfully created.
  Physical volume "/dev/sdb3" successfully created.
  Physical volume "/dev/sdb4" successfully created.
[root@localhost ~]#pvscan
  PV /dev/sda2   VG centos          lvm2 [<59.00 GiB / 4.00 MiB free]
  PV /dev/sdb1                      lvm2 [4.00 GiB]
  PV /dev/sdb2                      lvm2 [4.00 GiB]
  PV /dev/sdb4                      lvm2 [6.00 GiB]
  PV /dev/sdb3                      lvm2 [6.00 GiB]
  Total: 5 [<79.00 GiB] / in use: 1 [<59.00 GiB] / in no VG: 4 [20.00 GiB
```

### 3. 볼륨 그룹 구성
- `vgcreate` 명령으로 볼륨 그룹을 구성한다.
	- `vgcreate [옵션] [VG 이름] [PV 이름들]`
- `-s` 옵션으로 PE 크기를 정할 수 있다. 기본값 4MB
```
[root@localhost ~]#vgcreate -s 8M vg0 /dev/sdb2 /dev/sdb4
  Volume group "vg0" successfully created
[root@localhost ~]#vgdisplay -v vg0
  --- Volume group ---
  VG Name               vg0
  System ID             
  Format                lvm2
  Metadata Areas        2
  Metadata Sequence No  1
  VG Access             read/write
  VG Status             resizable
  MAX LV                0
  Cur LV                0
  Open LV               0
  Max PV                0
  Cur PV                2
  Act PV                2
  VG Size               9.98 GiB
  PE Size               8.00 MiB
  Total PE              1278
  Alloc PE / Size       0 / 0   
  Free  PE / Size       1278 / 9.98 GiB
  VG UUID               zmxNun-ejbB-6EwR-QwQO-g2Dw-1XZR-mguCYC
   
  --- Physical volumes ---
  PV Name               /dev/sdb2     
  PV UUID               Tm6BU1-81bx-AHee-qHlf-JrA0-vCu5-k9TNDJ
  PV Status             allocatable
  Total PE / Free PE    511 / 511
   
  PV Name               /dev/sdb4     
  PV UUID               2jm1fM-3drD-0sNa-2p63-nOHh-eAVj-sLUK8I
  PV Status             allocatable
  Total PE / Free PE    767 / 767
```

### 4. 논리 볼륨 생성
- `lvcreate [옵션] [볼륨 그룹 이름]` 으로 논리 볼륨을 생성한다.
	- `-l` : PE 개수로 논리 볼륨 크기를 지정한다.
	- `-L`: 사이즈 단위로 논리 볼륨 크기를 지정한다.
	- `-n`: 논리 볼륨 이름을 지정한다.
```
[root@localhost ~]#lvcreate -L 2G -n lv01 vg0
  Logical volume "lv01" created.
[root@localhost ~]#lvcreate -l 512 -n lv02 vg0
  Logical volume "lv02" created.
[root@localhost ~]#lvscan
  ACTIVE            '/dev/centos/swap' [<3.88 GiB] inherit
  ACTIVE            '/dev/centos/home' [18.08 GiB] inherit
  ACTIVE            '/dev/centos/root' [<37.04 GiB] inherit
  ACTIVE            '/dev/vg0/lv01' [2.00 GiB] inherit
  ACTIVE            '/dev/vg0/lv02' [4.00 GiB] inherit
[root@localhost ~]#vgdisplay -v vg0
  --- Volume group ---
  VG Name               vg0
  System ID             
  Format                lvm2
  Metadata Areas        2
  Metadata Sequence No  3
  VG Access             read/write
  VG Status             resizable
  MAX LV                0
  Cur LV                2
  Open LV               0
  Max PV                0
  Cur PV                2
  Act PV                2
  VG Size               9.98 GiB
  PE Size               8.00 MiB
  Total PE              1278
  Alloc PE / Size       768 / 6.00 GiB
  Free  PE / Size       510 / 3.98 GiB
  VG UUID               zmxNun-ejbB-6EwR-QwQO-g2Dw-1XZR-mguCYC
   
  --- Logical volume ---
  LV Path                /dev/vg0/lv01
  LV Name                lv01
  VG Name                vg0
  LV UUID                mm6yzY-2Ulv-ZlUA-WHMK-0cag-gcp0-AnExqe
  LV Write Access        read/write
  LV Creation host, time localhost.localdomain, 2023-01-04 10:52:29 +0900
  LV Status              available
  # open                 0
  LV Size                2.00 GiB
  Current LE             256
  Segments               1
  Allocation             inherit
  Read ahead sectors     auto
  - currently set to     8192
  Block device           253:3
   
  --- Logical volume ---
  LV Path                /dev/vg0/lv02
  LV Name                lv02
  VG Name                vg0
  LV UUID                jWriVe-PESI-aVIX-eTlJ-jyDI-8ibp-NA8OMC
  LV Write Access        read/write
  LV Creation host, time localhost.localdomain, 2023-01-04 10:52:42 +0900
  LV Status              available
  # open                 0
  LV Size                4.00 GiB
  Current LE             512
  Segments               1
  Allocation             inherit
  Read ahead sectors     auto
  - currently set to     8192
  Block device           253:4
   
  --- Physical volumes ---
  PV Name               /dev/sdb2     
  PV UUID               Tm6BU1-81bx-AHee-qHlf-JrA0-vCu5-k9TNDJ
  PV Status             allocatable
  Total PE / Free PE    511 / 255
   
  PV Name               /dev/sdb4     
  PV UUID               2jm1fM-3drD-0sNa-2p63-nOHh-eAVj-sLUK8I
  PV Status             allocatable
  Total PE / Free PE    767 / 255
```

### 5.파일 시스템 초기화
```
[root@localhost ~]#mkfs.xfs /dev/vg0/lv01
meta-data=/dev/vg0/lv01          isize=512    agcount=4, agsize=131072 blks
         =                       sectsz=512   attr=2, projid32bit=1
         =                       crc=1        finobt=0, sparse=0
data     =                       bsize=4096   blocks=524288, imaxpct=25
         =                       sunit=0      swidth=0 blks
naming   =version 2              bsize=4096   ascii-ci=0 ftype=1
log      =internal log           bsize=4096   blocks=2560, version=2
         =                       sectsz=512   sunit=0 blks, lazy-count=1
realtime =none                   extsz=4096   blocks=0, rtextents=0
[root@localhost ~]#mkfs.ext4 /dev/vg0/lv02
mke2fs 1.42.9 (28-Dec-2013)
Filesystem label=
OS type: Linux
Block size=4096 (log=2)
Fragment size=4096 (log=2)
Stride=0 blocks, Stripe width=0 blocks
262144 inodes, 1048576 blocks
52428 blocks (5.00%) reserved for the super user
First data block=0
Maximum filesystem blocks=1073741824
32 block groups
32768 blocks per group, 32768 fragments per group
8192 inodes per group
Superblock backups stored on blocks: 
	32768, 98304, 163840, 229376, 294912, 819200, 884736

Allocating group tables: done                            
Writing inode tables: done                            
Creating journal (32768 blocks): done
Writing superblocks and filesystem accounting information: done
[root@localhost ~]#lsblk -f
NAME            FSTYPE      LABEL UUID                                   MOUNTPOINT
sda                                                                      
├─sda1          xfs               9b6af47b-ff7f-4c4d-a4f1-72392b8d1990   /boot
└─sda2          LVM2_member       u5iIjC-oZF8-3DiR-fRbb-YEj2-zTWm-qgG1Q9 
  ├─centos-root xfs               767c5bc6-4766-410d-bd5b-0446372fabba   /
  ├─centos-swap swap              feba42c2-b454-4404-b180-6993d06b5a74   [SWAP]
  └─centos-home xfs               a2d9257d-fa23-4a02-acca-a095f501aafe   /home
sdb                                                                      
├─sdb1          LVM2_member       51E3w3-0qYZ-I1Sn-MaUn-t5Ge-ETR3-FggCdr 
├─sdb2          LVM2_member       Tm6BU1-81bx-AHee-qHlf-JrA0-vCu5-k9TNDJ 
│ └─vg0-lv01    xfs               bde4d71d-1de2-4bcb-871d-36ea97fd0d59   
├─sdb3          LVM2_member       3Wr5Pt-RM7h-UlUF-JOSp-pFu0-wV5e-b1nZ9y 
└─sdb4          LVM2_member       2jm1fM-3drD-0sNa-2p63-nOHh-eAVj-sLUK8I 
  └─vg0-lv02    ext4              86169003-9d1d-42bf-84f3-2196ad02233
```
### 6. 마운트
```
[root@localhost ~]#mount /dev/vg0/lv01 /mnt/disk1
[root@localhost ~]#mount /dev/mapper/vg0-lv02 /mnt/disk2
[root@localhost ~]#lsblk
NAME            MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sda               8:0    0   60G  0 disk 
├─sda1            8:1    0    1G  0 part /boot
└─sda2            8:2    0   59G  0 part 
  ├─centos-root 253:0    0   37G  0 lvm  /
  ├─centos-swap 253:1    0  3.9G  0 lvm  [SWAP]
  └─centos-home 253:2    0 18.1G  0 lvm  /home
sdb               8:16   0   21G  0 disk 
├─sdb1            8:17   0    4G  0 part 
├─sdb2            8:18   0    4G  0 part 
│ └─vg0-lv01    253:3    0    2G  0 lvm  /mnt/disk1
├─sdb3            8:19   0    6G  0 part 
└─sdb4            8:20   0    6G  0 part 
  └─vg0-lv02    253:4    0    4G  0 lvm  /mnt/disk2
sr0              11:0    1 1024M  0 rom  
[root@localhost ~]#df -Th
Filesystem              Type      Size  Used Avail Use% Mounted on
devtmpfs                devtmpfs  903M     0  903M   0% /dev
tmpfs                   tmpfs     919M     0  919M   0% /dev/shm
tmpfs                   tmpfs     919M  9.6M  910M   2% /run
tmpfs                   tmpfs     919M     0  919M   0% /sys/fs/cgroup
/dev/mapper/centos-root xfs        38G  4.8G   33G  13% /
/dev/sda1               xfs      1014M  239M  776M  24% /boot
/dev/mapper/centos-home xfs        19G   37M   19G   1% /home
tmpfs                   tmpfs     184M   36K  184M   1% /run/user/1000
tmpfs                   tmpfs     184M     0  184M   0% /run/user/0
/dev/mapper/vg0-lv01    xfs       2.0G   33M  2.0G   2% /mnt/disk1
/dev/mapper/vg0-lv02    ext4      3.9G   16M  3.6G   1% /mnt/disk2
```

- lv가 다른 파티션끼리 구성된 것을 확인할 수 있다.
```
[root@localhost ~]#lvcreate -l 100%FREE -n lv03 vg0
  Logical volume "lv03" created.
[root@localhost ~]#mkfs.xfs /dev/vg0/lv03
meta-data=/dev/vg0/lv03          isize=512    agcount=4, agsize=261120 blks
         =                       sectsz=512   attr=2, projid32bit=1
         =                       crc=1        finobt=0, sparse=0
data     =                       bsize=4096   blocks=1044480, imaxpct=25
         =                       sunit=0      swidth=0 blks
naming   =version 2              bsize=4096   ascii-ci=0 ftype=1
log      =internal log           bsize=4096   blocks=2560, version=2
         =                       sectsz=512   sunit=0 blks, lazy-count=1
realtime =none                   extsz=4096   blocks=0, rtextents=0
[root@localhost ~]#mount /dev/vg0/lv03 /mnt/disk3
[root@localhost ~]#lsblk
NAME            MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sda               8:0    0   60G  0 disk 
├─sda1            8:1    0    1G  0 part /boot
└─sda2            8:2    0   59G  0 part 
  ├─centos-root 253:0    0   37G  0 lvm  /
  ├─centos-swap 253:1    0  3.9G  0 lvm  [SWAP]
  └─centos-home 253:2    0 18.1G  0 lvm  /home
sdb               8:16   0   21G  0 disk 
├─sdb1            8:17   0    4G  0 part 
├─sdb2            8:18   0    4G  0 part 
│ ├─vg0-lv01    253:3    0    2G  0 lvm  /mnt/disk1
│ └─vg0-lv03    253:5    0    4G  0 lvm  /mnt/disk3
├─sdb3            8:19   0    6G  0 part 
└─sdb4            8:20   0    6G  0 part 
  ├─vg0-lv02    253:4    0    4G  0 lvm  /mnt/disk2
  └─vg0-lv03    253:5    0    4G  0 lvm  /mnt/disk3
sr0              11:0    1 1024M  0 rom  
```

### 원래 상태로 되돌리기
- `umount`
```
[root@localhost ~]#umount /mnt/disk1
[root@localhost ~]#umount /mnt/disk2
[root@localhost ~]#umount /mnt/disk3
```
- `lvremove`
```
[root@localhost ~]#lvremove /dev/vg0/*
Do you really want to remove active logical volume vg0/lv01? [y/n]: y
  Logical volume "lv01" successfully removed
Do you really want to remove active logical volume vg0/lv02? [y/n]: y
  Logical volume "lv02" successfully removed
Do you really want to remove active logical volume vg0/lv03? [y/n]: y
  Logical volume "lv03" successfully removed
```
- `vgremove`
```
[root@localhost ~]#vgremove vg0
  Volume group "vg0" successfully removed
```
- `pvremove`
```
[root@localhost ~]#pvremove /dev/sdb{1..4}
  Labels on physical volume "/dev/sdb1" successfully wiped.
  Labels on physical volume "/dev/sdb2" successfully wiped.
  Labels on physical volume "/dev/sdb3" successfully wiped.
  Labels on physical volume "/dev/sdb4" successfully wiped.
```

## 볼륨 그룹 및 논리 볼륨 관리
볼륨 그룹은 사이즈를 유연하게 관리할 수 있다. 논리 볼륨을 추가로 생성하거나 확장하기 위한 PE 확보를 위해 볼륨 그룹의 사이즈를 확장할 필요가 있다. 
논리 볼륨의 사이즈가 부족할 경우 논리 볼륨과 파일시스템의 사이즈를 증가시킬 수 있다. 논리 볼륨의 사이즈만 확장하는 경우 파일시스템은 확장되지 않으므로 같이 확장 시켜줘야 한다.
논리 볼륨 축소의 경우에는 깨질 가능성도 있기 때문에 권장하지 않는다. 
### 볼륨 그룹 관리
#### 볼륨 그룹 확장
- `vgextend [볼륨 그룹 이름] [물리 볼륨1 물리 볼륨2 ...]`
```
[root@localhost ~]#vgdisplay myvg
  --- Volume group ---
  VG Name               myvg
  System ID             
  Format                lvm2
  Metadata Areas        2
  Metadata Sequence No  4
  VG Access             read/write
  VG Status             resizable
  MAX LV                0
  Cur LV                3
  Open LV               3
  Max PV                0
  Cur PV                2
  Act PV                2
  VG Size               <9.97 GiB
  PE Size               16.00 MiB
  Total PE              638
  Alloc PE / Size       638 / <9.97 GiB
  Free  PE / Size       0 / 0   
  VG UUID               XWsdHT-0SAx-YBjl-XejS-EKE6-EDY2-ep9eDA
   
[root@localhost ~]#vgextend myvg /dev/sdb3
  Volume group "myvg" successfully extended
[root@localhost ~]#vgdisplay myvg
  --- Volume group ---
  VG Name               myvg
  System ID             
  Format                lvm2
  Metadata Areas        3
  Metadata Sequence No  5
  VG Access             read/write
  VG Status             resizable
  MAX LV                0
  Cur LV                3
  Open LV               3
  Max PV                0
  Cur PV                3
  Act PV                3
  VG Size               15.95 GiB
  PE Size               16.00 MiB
  Total PE              1021
  Alloc PE / Size       638 / <9.97 GiB
  Free  PE / Size       383 / 5.98 GiB
  VG UUID               XWsdHT-0SAx-YBjl-XejS-EKE6-EDY2-ep9eDA
```
#### 볼륨 그룹  축소
- `vgreduce [볼륨 그룹 이름] [물리 볼륨1 물리 볼륨2 ...]`
- 볼륨 그룹에서 사용 중인 물리 볼륨의 데이터를 다른 물리 볼륨으로 이동 시키고 볼륨 그룹을 축소해야 한다. 
- `pvmove [물리 볼륨 이름]`
```
[root@localhost ~]#lsblk
NAME            MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sda               8:0    0   60G  0 disk 
├─sda1            8:1    0    1G  0 part /boot
└─sda2            8:2    0   59G  0 part 
  ├─centos-root 253:0    0   37G  0 lvm  /
  ├─centos-swap 253:1    0  3.9G  0 lvm  [SWAP]
  └─centos-home 253:2    0 18.1G  0 lvm  /home
sdb               8:16   0   21G  0 disk 
├─sdb1            8:17   0    4G  0 part 
│ └─myvg-lv02   253:4    0    6G  0 lvm  /mnt/disk2
├─sdb2            8:18   0    4G  0 part 
├─sdb3            8:19   0    6G  0 part 
│ ├─myvg-lv01   253:3    0    5G  0 lvm  /mnt/disk1
│ └─myvg-lv02   253:4    0    6G  0 lvm  /mnt/disk2
└─sdb4            8:20   0    6G  0 part 
  ├─myvg-lv01   253:3    0    5G  0 lvm  /mnt/disk1
  ├─myvg-lv02   253:4    0    6G  0 lvm  /mnt/disk2
  └─myvg-lv03   253:5    0    2G  0 lvm  /mnt/disk3
sr0              11:0    1 1024M  0 rom  
[root@localhost ~]#pvmove /dev/sdb4
  /dev/sdb4: Moved: 0.52%
  /dev/sdb4: Moved: 66.58%
  /dev/sdb4: Moved: 66.84%
  /dev/sdb4: Moved: 67.10%
  /dev/sdb4: Moved: 100.00%
[root@localhost ~]#lsblk
NAME            MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sda               8:0    0   60G  0 disk 
├─sda1            8:1    0    1G  0 part /boot
└─sda2            8:2    0   59G  0 part 
  ├─centos-root 253:0    0   37G  0 lvm  /
  ├─centos-swap 253:1    0  3.9G  0 lvm  [SWAP]
  └─centos-home 253:2    0 18.1G  0 lvm  /home
sdb               8:16   0   21G  0 disk 
├─sdb1            8:17   0    4G  0 part 
│ └─myvg-lv02   253:4    0    6G  0 lvm  /mnt/disk2
├─sdb2            8:18   0    4G  0 part 
│ └─myvg-lv01   253:3    0    5G  0 lvm  /mnt/disk1
├─sdb3            8:19   0    6G  0 part 
│ ├─myvg-lv01   253:3    0    5G  0 lvm  /mnt/disk1
│ ├─myvg-lv02   253:4    0    6G  0 lvm  /mnt/disk2
│ └─myvg-lv03   253:5    0    2G  0 lvm  /mnt/disk3
└─sdb4            8:20   0    6G  0 part 
sr0              11:0    1 1024M  0 rom  
[root@localhost ~]#vgreduce myvg /dev/sdb4
  Removed "/dev/sdb4" from volume group "myvg"
```

```
[root@localhost ~]#vgdisplay -v myvg
  --- Volume group ---
  VG Name               myvg
  System ID             
  Format                lvm2
  Metadata Areas        3
  Metadata Sequence No  15
  VG Access             read/write
  VG Status             resizable
  MAX LV                0
  Cur LV                3
  Open LV               3
  Max PV                0
  Cur PV                3
  Act PV                3
  VG Size               13.95 GiB
  PE Size               16.00 MiB
  Total PE              893
  Alloc PE / Size       830 / <12.97 GiB
  Free  PE / Size       63 / 1008.00 MiB
  VG UUID               XWsdHT-0SAx-YBjl-XejS-EKE6-EDY2-ep9eDA
   
  --- Logical volume ---
  LV Path                /dev/myvg/lv01
  LV Name                lv01
  VG Name                myvg
  LV UUID                SPIP81-JwX9-fJ8p-Cr8I-0ZT7-m7Q0-BMcdek
  LV Write Access        read/write
  LV Creation host, time localhost.localdomain, 2023-01-04 12:17:06 +0900
  LV Status              available
  # open                 1
  LV Size                5.00 GiB
  Current LE             320
  Segments               3
  Allocation             inherit
  Read ahead sectors     auto
  - currently set to     8192
  Block device           253:3
   
  --- Logical volume ---
  LV Path                /dev/myvg/lv02
  LV Name                lv02
  VG Name                myvg
  LV UUID                emzYf0-eclW-Yjvi-SwSr-FdgQ-es8y-IFtnqP
  LV Write Access        read/write
  LV Creation host, time localhost.localdomain, 2023-01-04 12:17:32 +0900
  LV Status              available
  # open                 1
  LV Size                6.00 GiB
  Current LE             384
  Segments               3
  Allocation             inherit
  Read ahead sectors     auto
  - currently set to     8192
  Block device           253:4
   
  --- Logical volume ---
  LV Path                /dev/myvg/lv03
  LV Name                lv03
  VG Name                myvg
  LV UUID                WddX8J-0FLu-JERd-dDM1-43D3-JWTa-4e55WP
  LV Write Access        read/write
  LV Creation host, time localhost.localdomain, 2023-01-04 12:17:49 +0900
  LV Status              available
  # open                 1
  LV Size                <1.97 GiB
  Current LE             126
  Segments               1
  Allocation             inherit
  Read ahead sectors     auto
  - currently set to     8192
  Block device           253:5
   
  --- Physical volumes ---
  PV Name               /dev/sdb1     
  PV UUID               HPDTRJ-A3NT-fHuY-GNUe-D0gA-WAXn-AdM2MB
  PV Status             allocatable
  Total PE / Free PE    255 / 0
   
  PV Name               /dev/sdb3     
  PV UUID               omStyy-lTAN-1B2h-uLIB-aP9T-J3ON-NOvCwB
  PV Status             allocatable
  Total PE / Free PE    383 / 63
   
  PV Name               /dev/sdb2     
  PV UUID               OxRcFE-SvHc-BvpA-C6wy-3OGl-44vW-MkK3Yf
  PV Status             allocatable
  Total PE / Free PE    255 / 0
```
### 논리 볼륨 관리
#### 논리 볼륨 확장
- `lvextend [옵션] [논리 볼륨 경로]`
- 파일 시스템도 확장하는 과정이 필요하다.
	- `xfs_growfs [마운트 포인트]` :xfs 파일 시스템 확장
	- `resize2fs [논리 볼륨 경로]`: ext4 파일 시스템 확장
```
[root@localhost ~]#lsblk
NAME            MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sda               8:0    0   60G  0 disk 
├─sda1            8:1    0    1G  0 part /boot
└─sda2            8:2    0   59G  0 part 
  ├─centos-root 253:0    0   37G  0 lvm  /
  ├─centos-swap 253:1    0  3.9G  0 lvm  [SWAP]
  └─centos-home 253:2    0 18.1G  0 lvm  /home
sdb               8:16   0   21G  0 disk 
├─sdb1            8:17   0    4G  0 part 
│ └─myvg-lv02   253:4    0    4G  0 lvm  /mnt/disk2
├─sdb2            8:18   0    4G  0 part 
├─sdb3            8:19   0    6G  0 part 
└─sdb4            8:20   0    6G  0 part 
  ├─myvg-lv01   253:3    0    4G  0 lvm  /mnt/disk1
  ├─myvg-lv02   253:4    0    4G  0 lvm  /mnt/disk2
  └─myvg-lv03   253:5    0    2G  0 lvm  /mnt/disk3
sr0              11:0    1 1024M  0 rom  
[root@localhost ~]#lvextend -L 5G /dev/myvg/lv01
  Size of logical volume myvg/lv01 changed from 4.00 GiB (256 extents) to 5.00 GiB (320 extents).
  Logical volume myvg/lv01 successfully resized.
[root@localhost ~]#xfs_growfs /mnt/disk1
meta-data=/dev/mapper/myvg-lv01  isize=512    agcount=4, agsize=262144 blks
         =                       sectsz=512   attr=2, projid32bit=1
         =                       crc=1        finobt=0 spinodes=0
data     =                       bsize=4096   blocks=1048576, imaxpct=25
         =                       sunit=0      swidth=0 blks
naming   =version 2              bsize=4096   ascii-ci=0 ftype=1
log      =internal               bsize=4096   blocks=2560, version=2
         =                       sectsz=512   sunit=0 blks, lazy-count=1
realtime =none                   extsz=4096   blocks=0, rtextents=0
data blocks changed from 1048576 to 1310720
[root@localhost ~]#lsblk
NAME            MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sda               8:0    0   60G  0 disk 
├─sda1            8:1    0    1G  0 part /boot
└─sda2            8:2    0   59G  0 part 
  ├─centos-root 253:0    0   37G  0 lvm  /
  ├─centos-swap 253:1    0  3.9G  0 lvm  [SWAP]
  └─centos-home 253:2    0 18.1G  0 lvm  /home
sdb               8:16   0   21G  0 disk 
├─sdb1            8:17   0    4G  0 part 
│ └─myvg-lv02   253:4    0    4G  0 lvm  /mnt/disk2
├─sdb2            8:18   0    4G  0 part 
├─sdb3            8:19   0    6G  0 part 
│ └─myvg-lv01   253:3    0    5G  0 lvm  /mnt/disk1
└─sdb4            8:20   0    6G  0 part 
  ├─myvg-lv01   253:3    0    5G  0 lvm  /mnt/disk1
  ├─myvg-lv02   253:4    0    4G  0 lvm  /mnt/disk2
  └─myvg-lv03   253:5    0    2G  0 lvm  /mnt/disk3
sr0              11:0    1 1024M  0 rom 
```
# 디스크 관리
## 파일 시스템 별 디스크 사용량 확인하기 :`df`
- 기능: 디스크의 남은 공간에 대한 정보를 출력한다.
- 형식: `df [옵션] [파일 시스템]`
- 옵션:
	- `-a`: 모든 파일 시스템을 대상으로 디스크 사용량을 확인한다.
	- `-k`: KB 단위로 출력
	- `-m`: MB 단위로 출력
	- `-h`: 디스크 사용량을 알기 쉬운 단위로 출력
	- `-t 파일 시스템 종류`: 지정한 파일 시스템 종류에 해당하는 디스크의 사용량을 출력한다.
	- `-T`: 파일 시스템 종류도 출력한다.

## 디렉토리나 사용자별 디스크 사용량 확인하기:`du`
- 기능: 디스크의 사용 공간에 대한 정보를 출력한다.
- 형식: `du [옵션] [디렉토리]`
- 옵션:
	- `-s`: 특정 디렉토리의 전체 사용량을 출력한다.
	- `-h`: 디스크 사용량을 알기 쉬운 단위로 출력한다.
- 특정 사용자의 디스크 사용량을 출력하려면 `~사용자명` 을 인자로 넣어주면 된다. 홈 디렉토리의 용량을 확인한다.

## 파일 시스템 검사하기:`fsck`
- 기능: 리눅스의 파일 시스템을 점검한다.
- 형식: `fsck [옵션] [장치명]`
- 옵션:
	- `-f`: 강제로 점검한다.
	- `-b 슈퍼블록`: 슈퍼 블록으로 지정한 백업 슈퍼블록을 사용한다.
	- `-y`: 모든 질문에 yes로 대답하게 한다.
	- `-a`: 파일 시스템 검사에서 문제를 발견했을 때 자동으로 복구한다.