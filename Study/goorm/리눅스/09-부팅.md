# 리눅스 시스템의 부팅
![](images/Pasted%20image%2020230104140851.png)
## 바이오스 단계
![](images/Pasted%20image%2020230104141334.png)
- 전원을 켜면 시스템 펌웨어인 BIOS나 UEFI가 하드웨어를 점검하는 POST(Power On Self Test)를 진행한다. 이상이 있는 하드웨어가 있으면 시스템이 부팅되지 않는다.
- 메인 보드의 펌웨어(BIOS/UEFI)를 읽어서 기본적인 하드웨어 세팅을 확인한다.
	- 여기서 중요한 것은 부팅장치이다. 부팅 장치 설정을 보고 해당 부팅 장치를 통해 부팅을 한다. 부팅이 가능한 장치에서 부팅 디스크의 첫 섹터인 512Byte를 로딩한다.
- 이 512바이트가 MBR이고 2차 부팅 프로그램(부트 로더)의 위치를 저장한다. 

## 부트 로더 단계
- 부트로더가 메모리에 적재되면 여러 운영체제 중에서 부팅할 운영체제를 선택할 수 있도록 커널 목록을 화면에 출력한다.
- 리눅스 커널은 `/boot` 디렉토리 아래 `vmlinuz-버전명` 의 형태로 제공된다. 부트 로더는 리눅스 커널을 메모리에 로딩하고 시스템 제어권을 커널에게 전달한다.
- 리눅스의 대표적인 부트로더로는 GRUB과 LIO가 있다.
```
[root@localhost ~]#lsblk
NAME            MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sda               8:0    0   60G  0 disk 
├─sda1            8:1    0    1G  0 part /boot
└─sda2            8:2    0   59G  0 part 
...
```

```
[root@localhost ~]#ls /boot/vmlinuz*
/boot/vmlinuz-0-rescue-3c6d588fb3f08b4c8d45476db639717c
/boot/vmlinuz-3.10.0-1160.42.2.el7.x86_64
/boot/vmlinuz-3.10.0-1160.el7.x86_64
```

## 커널 초기화 단계
- 커널이 메모리에 올라가면 커널은 초기화 단계를 거친다. 
- 가장 먼저 시스템에 연결된 메모리, 디스크, 키보드, 마우스 등 장치들을 검사한다.
- 장치 검사등 기본적인 초기화 과정이 끝나면 커널은 fork를 사용하지 않고 생성되는 프로세스와 스레드를 생성한다.
	- 이 프로세스들은 메모리 관리 같은 운영체제의 기본적이고 핵심적인 커널의 여러 가지 동작을 수행한다.
	- 이들 프로세스는 일반적인 프로세스와 구분되도록 대괄호 `[]` 로 표시하며, 주로 PID 번호가 낮게 배정된다.
(프로세스는 기본적으로 부모 프로세스가 있고 부모 프로세스에서 fork를 사용하여 자식 프로세스를 생성한다.) 

## systemd 서비스 단계
- system 서비스 단계에 이르면 리눅스가 본격적으로 동작하기 시작한다.
- systemd 서비스는 기존의 init 스크립트를 대체한 것으로 다양한 서비스를 동작시킨다.
	- 각 서비스가 시작하는 과정은 화면에 메시지로 출력된다.
	- 기본적으로 메시지가 보이지 않도록 하고 대신에 부트 스플래시 라고 하는 이미지를 출력한다.
- 부팅시 출력된 메시지는 `dmesg` 명령으로 확인할 수 있다.
```
[root@localhost ~]#dmesg
[    0.000000] Initializing cgroup subsys cpuset
[    0.000000] Initializing cgroup subsys cpu
[    0.000000] Initializing cgroup subsys cpuacct
[    0.000000] Linux version 3.10.0-1160.42.2.el7.x86_64 (mockbuild@kbuilder.bsys.centos.org) (gcc version 4.8.5 20150623 (Red Hat 4.8.5-44) (GCC) ) #1 SMP Tue Sep 7 14:49:57 UTC 2021
[    0.000000] Command line: BOOT_IMAGE=/vmlinuz-3.10.0-1160.42.2.el7.x86_64 root=/dev/mapper/centos-root ro crashkernel=auto rd.lvm.lv=centos/root rd.lvm.lv=centos/swap rhgb quiet LANG=en_US.UTF-8
[    0.000000] e820: BIOS-provided physical RAM map:
[    0.000000] BIOS-e820: [mem 0x0000000000000000-0x000000000009fbff] usable
[    0.000000] BIOS-e820: [mem 0x000000000009fc00-0x000000000009ffff] reserved
[    0.000000] BIOS-e820: [mem 0x00000000000f0000-0x00000000000fffff] reserved
[    0.000000] BIOS-e820: [mem 0x0000000000100000-0x000000007ffeffff] usable
[    0.000000] BIOS-e820: [mem 0x000000007fff0000-0x000000007fffffff] ACPI data
[    0.000000] BIOS-e820: [mem 0x00000000fec00000-0x00000000fec00fff] reserved
[    0.000000] BIOS-e820: [mem 0x00000000fee00000-0x00000000fee00fff] reserved
[    0.000000] BIOS-e820: [mem 0x00000000fffc0000-0x00000000ffffffff] reserved
[    0.000000] NX (Execute Disable) protection: active
[    0.000000] SMBIOS 2.5 present.
[    0.000000] DMI: innotek GmbH VirtualBox/VirtualBox, BIOS VirtualBox 12/01/2006
[    0.000000] Hypervisor detected: KVM
...
```

## 1번 프로세스
- 전통적으로 유닉스에서는 `init` 프로세스가 처음 생성된 프로세스로서 PID가 1번이다.
- 리눅스 페도라 14, centos7 부터 init 대신에 시스템과 서비스 관리자로 systemd를 사용하기 시작했고, system 프로세스가 1번 프로세스이다. init 프로세스보다 효율이 좋고 다양한 기능을 제공한다. 
```
[root@localhost ~]#ps -ef | more
UID        PID  PPID  C STIME TTY          TIME CMD
root         1     0  0 09:56 ?        00:00:05 /usr/lib/systemd/systemd --switched-root --system --deseriali
ze 22
root         2     0  0 09:56 ?        00:00:00 [kthreadd]
root         4     2  0 09:56 ?        00:00:00 [kworker/0:0H]
root         6     2  0 09:56 ?        00:00:00 [ksoftirqd/0]
...
```

# systemd 서비스

## 기존 init 프로세스
- init 프로세스는 부팅 과정에서 각종 서비스를 제공하는 셸 스크립트 파일을 실행했다. init 프로세스 설정 파일은 `/etc/inittab` 이다. 
```
[root@localhost ~]#cat /etc/inittab
# inittab is no longer used when using systemd.
#
# ADDING CONFIGURATION HERE WILL HAVE NO EFFECT ON YOUR SYSTEM.
#
# Ctrl-Alt-Delete is handled by /usr/lib/systemd/system/ctrl-alt-del.target
#
# systemd uses 'targets' instead of runlevels. By default, there are two main targets:
#
# multi-user.target: analogous to runlevel 3
# graphical.target: analogous to runlevel 5
#
# To view current default target, run:
# systemctl get-default
#
# To set a default target, run:
# systemctl set-default TARGET.target
#
```
- init 프로세스가 실행하는 스크립트 파일은 `/etc/rc.d/init.d`  디렉토리에 위치한다.
- 현재는 systemd 서비스에 의해 대부분 대체되고 일부 파일만 유지
```
[root@localhost ~]#ls /etc/rc.d/init.d/
functions  netconsole  network  README
```

## init 프로세스와 런레벨
- init 프로세스에서 사용하던 런레벨(Run level)의 개념에 대한 이해가 필요하다.
- init은 시스템의 단계를 일곱 개로 정의하여 구분하고 각 단계에 따라 셸 스크립트를 실행하는데, 이 단계들을 런레벨이라고 함.
- 런레벨 개념은 사라졌지만 기존에 사용하던 명령어와 기능들은 리눅스에서는 유지중이다.

| 런레벨 | 의미                                  | 관련 스크립트의 위치 |
| ------ | ------------------------------------- | -------------------- |
| 0      | 시스템 종료                           | `/etc/rc0.d`         |
| 1, s   | 단일 사용자 모드                      | `/etc/rc1.d`         |
| 2      | 다중 사용자 모드(NFS를 실행하지 않음) | `/etc/rc2.d`         |
| 3      | 다중 사용자 모드(NFS 포함), CLI       | `/etc/rc3.d`         |
| 4      | 사용하지 않음(예비 번호)              | `/etc/rc4.d`         |
| 5      | X11 상태로 부팅, GUI                  | `/etc/rc5.d`         |
| 6      | 재시작                                | `/etc/rc6.d`         |

## systemd 의 기본 개념
- 거의 대부분의 서비스가 system 기반으로 변경
- systemd가 init 방식에 비해 가진 장점
	- 소켓 기반으로 동작하여inetd와 호환성을 유지한다.
	- 셸과 독립적으로 부팅이 가능하다.
	- 마운트 제어가 가능하다.
	- `fsck` 제어가 가능하다.
	- 시스템 상태에 대한 스냅샷을 유지한다
	- 서비스에 시그널을 전달할 수 있다.
	- 셧다운 전에 사용자 세션의 안전한 종료가 가능하다.

## systemd 유닛
- systemd는 전체 시스템을 시작하고 관리하는 데 유닛이라 부르는 구성 요소를 사용한다.
- 관리 대상의 이름을 `서비스 이름.유닛 종류`의 형태로 관리한다.
- 각 유닛은 같은 이름과 종류로 구성된 설정파일과 동일한 이름을 사용한다.
- `/usr/lib/systemd/system`에 유닛과 서비스들이 모여있다.
| 유닛      | 기능                                                                                           | 예          |
| --------- | ---------------------------------------------------------------------------------------------- | ----------- |
| service   | 가장 명백한 유닛으로 데몬을 시작, 종료, 재시작, 로드한다.                                      | atd.service |
| socket    | 소켓을 관리하는 유닛으로 AF_INET, AF_INET6, AF_UNIX 소켓 스트립과 데이터그램, FIFO를 지원한다. | dbus.soket  |
| device    | 리눅스 장치 트리에 있는 장치를 관리한다.                                                       |             |
| mount     | 디렉터리 계층 구조의 마운트 포인트를 관리한다.                                                 |             |
| automount | 디렉터리 계층 구조에서 자동 마운트 포인트를 관리한다.                                          |             |
| target    | 런레벨과 매핑되는 유닛이다. 유닛을 그루핑한다.                                                                             |             |
| swap      | 스왑 장치를 관리한다.                                                                          |             |
| path      | 경로를 관리한다.                                                                               |             |
| timer     | 타이머와 관련된 기능을 관리한다.                                                               |             |
| slice     | 프로세스 그룹의 자원을 계층적으로 관리한다.                                                    |             |
| scope     | 외부에서 생성된 프로세스를 관리한다.                                                           |             |

- 유닛을 통해 좀 더 체계적으로 서비스를 관리할 수 있게 되었다.
	- 서비스 파일의 내용을 확인하면 세부 내용들을 볼 수 있다.

```
```