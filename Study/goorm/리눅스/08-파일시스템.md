# 디스크 기본 구조
## 디스크의 물리적인 구조
![450](images/Pasted%20image%2020230102130314.png)

| 부분            | 내용                                                                                                                                            |
| --------------- | ----------------------------------------------------------------------------------------------------------------------------------------------- |
| Platter         | 실제 저장되는 위치, 데이터는 자기장을 기록하여 기록된다. 디스크에는 한개 이상의 플래터가 존재하고, 각 플래터의 양면에 기록된다.                 |
| Spindle         | 플래터를 회전시키는 역할을 한다.                                                                                                                |
| Head            | 플레터에 데이터를 기록하는 기능을 담당한다. 각 플래터의 양면에 각각 1개씩 위치한다.                                                             |
| Actuator        | 디스크 제어 컨트롤러에 의해 디스크 플래터의 원하는 위치에 있는 데이터를 읽어 오기 위해 암을 이동시키는 역할을 한다.                             |
| Actuator Arm    | 각 암마다 한 개씩의 헤드가 붙어있다. 액세스 암이라고도 한다.                                                                                    |
| Connector       | 디스크의 연결 인터페이스 종류에 맞는 케이블 연결을 담당한다. IDE, SATA, SCSI, SA-SCSI 등을 사용한다.                                            |
| Jumper Block    | IDE 인터페이스를 사용하는 하드디스크의 경우 Master, Slave를 결정하기 위한 점퍼를 결정해야한다. 다른 인터페이스의 경우에는 점퍼가 필요하지 않다. |
| Power Connector | 디스크 구동에 필요한 전원케이블을 연결한다.                                                                                                     |
- 블록 장치는 단위 블록으로 데이터를 다룬다. 예를 들어 디스크가 있다.
- 캐릭터 장치는 단위 문자로 데이터를 다룬다. 예를 들어 입출력 장치가 있다.

## 디스크 플래터의 논리적인 구성요소
![](images/Pasted%20image%2020230102130251.png)

| 부분     | 내용                                                                                                                                                                                 |
| -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| Sector   | 플래터의 가장 작은 단위이다. 1개 섹터의 크기는 512byte 이다. 섹터는 디스크 블록으로도 알려져있다.                                                                                    |
| Track    | 섹터가 모여 하나의 원을 구성한다. 트랙은 많은 수의 섹터를 가지고 있으며 플래터 내에 여러 개의 트랙이 존재한다. 가장 바깥쪽의 트랙은 가장 안쪽의 트랙보다 더 많은 섹터를 가지고 있다. |
| Cylinder | 여러 동심 트랙에 대한 스택 구조이다.                                                                                                                                                                                     |

- 섹터가 모여 블록을 이루기도 한다. 보통 4KB 이다. 

## 디스크 파티션
디스크를 사용하려면
1. 디스크를 추가해야한다.
2. 시스템이 인터페이스를 통해 디스크를 인식해야한다.
3. 파티셔닝을 해야한다.
4. 파일 시스템 초기화(포맷)을 해야한다.
5. 리눅스의 경우 디렉토리와 파일 시스템이 구축된 공간인 볼륨을 연결시키는 마운트를 해야한다.
물리적인 디스크는 파티션이라는 단위로 나누어진다. 하나의 디스크를 나누어 사용하면 여러 개의 디스크가 있는 것 처럼 사용할 수 있다.
파티션으로 나누어지면 각 파티션은 개별적으로 관리된다. 각 파티션을 용도에 따라 다양하게 활용할 수 있다.(운영체제별, 저장용 등) 그리고 각 파티션별로 초기화(포맷) 할 수 있다.
x86 시스템에서 디스크 파티션이 구성되는 방식은 두 가지가 있다. 
1. MBR(Master Boot Record) 방식
2. GPT(GUID Partition Table) 방식

### MBR 파티션(Mater Boot Record)
1. 디스크 전체의 파티션 레이아웃을 파티션 테이블에 저장한다.
2. 전체 파티션 중 운영체제 데이터를 가지고 있어 부팅할 수 있는 파티션에 대한 정보를 가지고 있다.
3. 운영 체제 부팅에 사용되는 부트 코드를 가지고 있다.
이와 같은 기능을 제공하기 위해 MBR은 디스크의 첫 번째 섹터를 사용한다. 첫 번째 섹터는 섹터의 LBA 주소가 0번인 섹터를 의미한다.
- LBA(Logical Block Address)
	- 섹터의 논리적인 주소를 의미한다. 예전에는 CHS(Cylinder, Head, Sector) 주소라는 물리적인 주소를 사용하였으나 CHS주소 사용시 디스크 용량 제한 등의 문제로 물리적인 구조와 상관없는 가상 CHS 주소를 사용하며 대부분 LBA주소를 사용하여 섹터를 지정한다.
MBR 파티션 방식의 경우 첫 번째 파티션에서 64 Byte 만큼을 전체 파티션 테이블 용도로 사용한다. 그리고 64 Byte는 다시 16Byte 씩 4개의 각 파티션 테이블로 나누어진다.
파티션 테이블은 아래와 같은 값을 가지고 있다.
- 파티션의 상태(부팅 가능/불가능)
- 파티션의 첫 번째 섹터 주소(CHS)
- 파티션의 종류(파티션 내 파일시스템 정보)
- 파티션의 마지막 섹터 주소(CHS)
- 파티션의 첫 섹터 주소(LBA) - 4 Byte
- 파티션의 섹터 개수 - 4Byte
MBR은 메인보으데서 바이오스  펌웨어를 사용하는 컴퓨터에서 사용하는 파티셔닝 방식으로 최대 4개의 Primary 파티션을 지원하지만 필요할 경우 마지막 파티션을 확장하여 4개 이상 파티션을 사용할 수 있다. 
- Primary Partition: OS를 설치할 수 있는 파티션
- Exteneded Partition: Logical Partition의 정보를 담고 있는 파티션, 데이터의 저장용도로 사용되지 않는 파티션
- Logical Partition: OS를 설치할 수 없고 데이터만 저장가능한 파티션
MBR 파티션의 경우 섹터의 주소를 4 Byte로 저장하고 한 개의 섹터는 512 Byte 이기 때문에 최대 2TB인 한계가 있다. 

### GPT 파티션
EFI/UEFI (Extensible Firmware Interface/ Unified EFI)의 일부에 포함된 디스크 파이션 레이블 레이아웃 표준이다. MBR 파티션 테이블이 첫 번째 섹터만을 사용했던 반면, GPT 파티션 테이블은 더 많은 섹터를 파티션 정보 저장 용도로 사용하고 있다. 
- 파티션의 테이블의 개수가 128개로 늘어났고 각 파티션 테이블 당 128 Byte 씩을 사용할 수 있다.
- 섹터 주소를 64bit로 저장하여 최대 8ZB($10^{21}$ Byte)의 디스크를 사용할 수 있다.
- GPT 중요 데이터를 디스크의 마지막 부분에 복제한다.

# 디스크 이름 및 확인
디스크를 시스템에 연결시키는 인터페이스에 따라서 장치파일 이름이 조금씩 다르게 지정된다.

## 디스크 연결 인터페이스 방식
디스크를 시스템에 연결할 때 사용하는 방식을 연결 인터페이스라고 한다. 연결 인터페이스의 종류에 따라 연결할 수 있는 디스크의 개수, 디스크 통신 속도, 시스템 구동 중 디스크 인식(Hot Plugging)등의 기능이 다르게 동작한다.

### E-IDE(Enhanced - Integrated Drive Electoronics)
- 다른 이름으로 ATA(Advanced Technology Attachment)라고도 부른다. 현재는 거의 쓰이지 않는다.
- 핫 플러깅을 지원하지 않는다. 다스크를 추가 또는 제거할 경우, 시스템을 종료한 상태에서 작업해야한다.
- 메인보드에 2개의 E-IDE 인터페이스를 연결할 수 있다. 그리고 하나의 케이블로 2개의 하드디스크(마스터/슬레이브)를 메인보드에 연결할 수 있다. 최대 4개 하드 디스크를 사용할 수 있다.

### SATA(Serial ATA)
- 현재 대부분의 개인용 PC에서 사용중인 디스크 드라이브 연결 인터페이스
- SATA1, SATA2, SATA3의 규격이 있다.
- 서로 다른 규격을 지원하는 메인보드와 디스크를 연결할 경우 이상 없이 호환되지만, 대신 낮은 규격의 속도로 동작한다.
- 핫 플러깅을 지원하기 때문에 운영 중인 시스템에서도 디스크를 자유롭게 추가하거나 제거할 수 있다.
- 한 케이블 당 한 개의 디스크를 연결할 수 있다. 메인보드의 종류에 따라 10개 이상의 SATA 인터페이스를 제공하는 제품도 있다.
- mSATA(mini SATA)는 플래시 메모리를 사용한 제품으로 노트북에서 많이 사용되는 SATA 인터페이스의 한 종류이다.
- 현재는 PCIe/NVMe 규격을 사용하는 M.2 인터페이스가 mSATA보다 우월한 성능으로 소형 플래시 메모리 저장 방식의 표준으로 자리 자고 있다.

### SCSI(Small Computer System Interface)
- 디스크뿐만 아니라 기타 주변기기들을 시스템에 연결할 수 있는 표준 연결 방식을 의미한다.
- 주변기기를 제어하는 기능이 시스템에 있는 것이 아니라 각 주변기기에 있다. 따라서 시스템의 CPU가 주변 장치를 제어하는 방식에 비해 빠른 성능을 구현할 수 있다.
- 많은 장치를 연결하는 서버를 생각해보면 CPU의 부담을 낮출 수 있다는 장점이 있다. 
- 핫 플러깅을 지원한다.

### SA-SCSI(Serial Attached SCSI:SAS)
- 병렬 통신을 수행하는 SCIS 인터페이스의 직렬 통신 버전이다. 병렬 방식 인터페이스가 신호간섭에 의해 고속 성능 구현이 어렵기 때문에 직렬 전송방식을 사용한다. 
- SATA와 호환성을 이루고 있다. SATA 디스크를 SA-SCSI 인터페이스에 연결하여 사용할 수 있다.

## 리눅스 시스템 스토리지 장치명
리눅스 시스템의 하드웨어 장치는 `/dev` 디렉토리 내에 파일로 생성된다. 디스크 연결 후 생성된 장치 파일명을 사용하여 파티셔닝 작업을 수행한다.
기본적인 장치명 생성 규칙은 다음과 같다.
```
인터페이스별 장치명 + 장치 번호 + [파티션 번호]
```
### E-IDE 인터페이스
- `hd` 장치명을 사용한다. 
- 이후 장치별로 알파벳을 붙인다. 
- 이후 파티션에 번호를 붙인다.
- 최신 리눅스 시스템에서는 `hd` 명령을 사용하지 않는다.

### SATA/SCSI/SA-SCSI
- `sd` 장치명을 사용한다.
- 이후 장치별로 알파벳을 붙인다.
- 이후  파티션에 번호를 붙인다.

### CD-ROM/DVD-ROM 등의 ODD
- `sr` 장치명을 사용한다.
- 이후 장치별로 번호를 붙인다.
- `/dev/cdrom` 이 장치파일에 심볼릭 링크로 되어있다.
```
[root@localhost ~]#ls -l /dev/cdrom 
lrwxrwxrwx. 1 root root 3 Jan  2 15:52 /dev/cdrom -> sr0
```

# 하드디스크 파티셔닝
파티션이란 하나의 디스크를 독립된 영역으로 구분하는 것으로 파티션을 분할하는 작업을 파티셔닝이라고 한다.

## `fdisk`
- x86 시스템의 MBR 파티셔닝을 위해 사용하는 도구로 대화형 메뉴를 통하여 손쉽게 디스크 파티션을 구성할 수 있다.
- 기능: 디스크의 파티션 생성, 삭제, 보기 등 파티션을 관리한다. 

###  `fdisk -l`
- 파티션 테이블을 출력한다. 파티션 정보를 볼 수 있다.
```
[root@localhost ~]#fdisk -l

Disk /dev/sda: 64.4 GB, 64424509440 bytes, 125829120 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk label type: dos
Disk identifier: 0x0009a861

   Device Boot      Start         End      Blocks   Id  System
/dev/sda1   *        2048     2099199     1048576   83  Linux
/dev/sda2         2099200   125829119    61864960   8e  Linux LVM

Disk /dev/sdb: 22.5 GB, 22548578304 bytes, 44040192 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
```
- 장치 파일 이름, 섹터 개수, 부트 코드를 포함하는지, 파티션의 섹터 주소 등을 확인할 수 있다.

### `fdisk 장치 파일명`
- 해당 디스크의 파티셔닝에 대해 접근한다.
- 대화형으로 실행된다. 입력하는 옵션들은 다음과 같다.

| 명령 | 기능                                  | 명령 | 기능                                                  |
| ---- | ------------------------------------- | ---- | ----------------------------------------------------- |
| a    | 부팅 파티션을 설정한다.               | p    | 파티션 테이블을 출력한다.                             |
| b    | BSD 디스크 라벨을 편집한다.           | q    | 작업 내용을 저장하지 않고 종료한다.                   |
| c    | 도스 호환성을 설정한다.               | s    | 새로운 빈 Sun 디스크 라벨을 생성한다.                 |
| d    | 파티션을 삭제한다.                    | t    | 파티션의 시스템 ID를 변경한다.(파일 시스템 종류 변경) |
| l    | 사용 가능한 파티션의 종류를 출력한다. | u    | 항목 정보를 변경, 출력한다.                           |
| m    | 도움말을 출력한다.                    | v    | 파티션 테이블을 검사한다.                             |
| n    | 새로운 파티션을 추가한다.             | w    | 파티션 정보를 디스크에 저장하고 종료한다.             |
| o    | 새로운 빈 DOS 파티션을 생성한다.      | x    | 실린더 개수 변경 등 전문가를 위한 부가적인 기능이다.                                                      |

```
[root@localhost ~]#fdisk /dev/sdb
Welcome to fdisk (util-linux 2.23.2).

Changes will remain in memory only, until you decide to write them.
Be careful before using the write command.

Device does not contain a recognized partition table
Building a new DOS disklabel with disk identifier 0xc4e2bf27.

Command (m for help): 
```

#### `m`
- 도움말 출력
```
Command (m for help): m
Command action
   a   toggle a bootable flag
   b   edit bsd disklabel
   c   toggle the dos compatibility flag
   d   delete a partition
   g   create a new empty GPT partition table
   G   create an IRIX (SGI) partition table
   l   list known partition types
   m   print this menu
   n   add a new partition
   o   create a new empty DOS partition table
   p   print the partition table
   q   quit without saving changes
   s   create a new empty Sun disklabel
   t   change a partition's system id
   u   change display/entry units
   v   verify the partition table
   w   write table to disk and exit
   x   extra functionality (experts only)
```

#### `l`
```
Command (m for help): l

 0  Empty           24  NEC DOS         81  Minix / old Lin bf  Solaris        
 1  FAT12           27  Hidden NTFS Win 82  Linux swap / So c1  DRDOS/sec (FAT-
 2  XENIX root      39  Plan 9          83  Linux           c4  DRDOS/sec (FAT-
 3  XENIX usr       3c  PartitionMagic  84  OS/2 hidden C:  c6  DRDOS/sec (FAT-
 4  FAT16 <32M      40  Venix 80286     85  Linux extended  c7  Syrinx         
 5  Extended        41  PPC PReP Boot   86  NTFS volume set da  Non-FS data    
 6  FAT16           42  SFS             87  NTFS volume set db  CP/M / CTOS / .
 7  HPFS/NTFS/exFAT 4d  QNX4.x          88  Linux plaintext de  Dell Utility   
 8  AIX             4e  QNX4.x 2nd part 8e  Linux LVM       df  BootIt         
 9  AIX bootable    4f  QNX4.x 3rd part 93  Amoeba          e1  DOS access     
 a  OS/2 Boot Manag 50  OnTrack DM      94  Amoeba BBT      e3  DOS R/O        
 b  W95 FAT32       51  OnTrack DM6 Aux 9f  BSD/OS          e4  SpeedStor      
 c  W95 FAT32 (LBA) 52  CP/M            a0  IBM Thinkpad hi eb  BeOS fs        
 e  W95 FAT16 (LBA) 53  OnTrack DM6 Aux a5  FreeBSD         ee  GPT            
 f  W95 Ext'd (LBA) 54  OnTrackDM6      a6  OpenBSD         ef  EFI (FAT-12/16/
10  OPUS            55  EZ-Drive        a7  NeXTSTEP        f0  Linux/PA-RISC b
11  Hidden FAT12    56  Golden Bow      a8  Darwin UFS      f1  SpeedStor      
12  Compaq diagnost 5c  Priam Edisk     a9  NetBSD          f4  SpeedStor      
14  Hidden FAT16 <3 61  SpeedStor       ab  Darwin boot     f2  DOS secondary  
16  Hidden FAT16    63  GNU HURD or Sys af  HFS / HFS+      fb  VMware VMFS    
17  Hidden HPFS/NTF 64  Novell Netware  b7  BSDI fs         fc  VMware VMKCORE 
18  AST SmartSleep  65  Novell Netware  b8  BSDI swap       fd  Linux raid auto
1b  Hidden W95 FAT3 70  DiskSecure Mult bb  Boot Wizard hid fe  LANstep        
1c  Hidden W95 FAT3 75  PC/IX           be  Solaris boot    ff  BBT   
```
#### `p`
- 현재 구성되어 있는 파티션 정보 확인, 파티션 테이블을 출력한다. 
```
Command (m for help): p

Disk /dev/sdb: 22.5 GB, 22548578304 bytes, 44040192 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk label type: dos
Disk identifier: 0xc4e2bf27

   Device Boot      Start         End      Blocks   Id  System
```

#### `n`
- 새로운 파티션을 생성하는 옵션
```
Command (m for help): n
Partition type:
   p   primary (0 primary, 0 extended, 4 free)
   e   extended
Select (default p): p
Partition number (1-4, default 1): 1
First sector (2048-44040191, default 2048): 2048
Last sector, +sectors or +size{K,M,G} (2048-44040191, default 44040191): +500M
Partition 1 of type Linux and of size 500 MiB is set
```
- 파티션 종류, 파티션 번호, 시작 섹터, 마지막 섹터 위치를 지정한다.

## `partprobe`
- `fdisk`로는 파티션 테이블만 만든 것일 뿐이고 실제로는 싱크가 안맞을 수도 있다. 따라서 디스크를 동기화하기 위해 커널에 변경된 파티션의 정보를 인식하도록 해야한다.
- 이 때 `partprobe` 명령어를 사용하고 명령어는 다음과 같다.
```
[root@localhost ~]#partprobe /dev/sdb
```
- `partprobe` 명령어만 사용하면 전체 연결된 디스크들에 대한 파티션 정보를 재인식한다. 인자로 디스크 파일을 지정할 경우 해당 장치에 대한 파티젼 정보만 재인식 한다.

## `gdisk`
- GPT 파티션 방식으로 파티션을 생성한다. 
- 사용법은 `fdisk`와 거의 동일하다. 
- 파티션 시작 위치 및 마지막 위치 지정시 +/- 둘 다 사용 가능하다. -의 경우 사용가능한 섹터 영역의 마지막 위치에서 부터 앞쪽으로 상대적인 위치를 의미한다.
- 파티션 생성 시 즉시 파티션 타입을 지정한다.

# 리눅스 파일 시스템의 종류
컴퓨터가 부팅되고 나면 디스크에 MBR과 파티션 테이블을 통해서 디스크의 구성을 읽게된다. 각 파티션은 특정 파일 시스템으로 포맷되어 있다. 특정 파일 시스템으로 초기화되어 있다면 해당 파티션은 파일의 메타데이터와 저널링 데이터 등의 디스크 정보를 담고 있는 공간과 실제 파일에 대한 데이터 공간으로 구분된다. 리눅스로 생각해보면 inode 공간이 있고 파일 데이터 공간이 블록으로 구성되어 있는 것으로 생각할 수 있다. 물론 구조는 파일 시스템에 따라 각각 다르다. 
## 파일 시스템
- 구조화된 일련의 정보를 구성하는 파일 디렉토리의 집합
- 디스크에 데이터(파일/디렉토리)를 논리적으로 저장하고 관리하는 방식
	- 파일을 어떻게 읽고 쓸지를 정하는 규칙
	- 어떤 구조를 구성하여 파일이나 디렉토리를 관리하느냐에 따라 다양한 형식의 파일 시스템이 존재
```
[root@localhost ~]#fdisk /dev/sdb
Welcome to fdisk (util-linux 2.23.2).

Changes will remain in memory only, until you decide to write them.
Be careful before using the write command.

Device does not contain a recognized partition table
Building a new DOS disklabel with disk identifier 0xc4e2bf27.

Command (m for help): 
```

## 리눅스 고유의 디스크 기반 파일 시스템
- ext1
- ext2
- ext3
	- 저널링 기능 도입
- ext4
	- 1EB 이상의 볼륨과 16TB 이상의 파일을 지원
	- 리눅스 기본 디스크 기반 파일 시스템

- 저널링: 파일의 읽기, 쓰기, 삭제에 대한 정보를 디스크에 기록해놓는다. 즉 우리 컴퓨터에서 무슨 일이 있었는지 기록해놓는 것이다. 저널링을 이용하여 디스크를 원하는 시기로 복원할 수 있다. 
- 디스크 파티션: 디스크에서 사용할 공간을 지정한 것
- 파티셔닝: 디스크의 파티션을 구획하는 작업 및 방식
	- 디스크를 사용하기 위해서는 파티셔닝부터 해야한다. 
	- 포맷을 하면 해당 파티션에 파일시스템이 구성된다.
- 볼륨: 파일시스템이 구성된 파티션 또는 전체 공간도 파티션이라고 한다.

- 레드햇의 경우에는 보통 `xfs` 파일 시스템을 사용한다.
```
[root@localhost test]#df -Th
Filesystem              Type      Size  Used Avail Use% Mounted on
devtmpfs                devtmpfs  903M     0  903M   0% /dev
tmpfs                   tmpfs     919M     0  919M   0% /dev/shm
tmpfs                   tmpfs     919M   41M  879M   5% /run
tmpfs                   tmpfs     919M     0  919M   0% /sys/fs/cgroup
/dev/mapper/centos-root xfs        38G  4.8G   33G  13% /
/dev/sda1               xfs      1014M  239M  776M  24% /boot
/dev/mapper/centos-home xfs        19G   37M   19G   1% /home
tmpfs                   tmpfs     184M   40K  184M   1% /run/user/0
```

- 리눅스에서 지원하는 기타 파일 시스템
	- 파티션에 파일을 읽고 쓰는 규칙과 관련되어 있다.

| 파일 시스템 | 기능                                                             |
| ----------- | ---------------------------------------------------------------- |
| msdos       | MS-DOS 파티션을 사용하기 위한 파일 시스템이다.                   |
| iso9660     | CD-ROM, DVD의 표준 파일 시스템으로 읽기 전용으로 사용된다.       |
| nfs         | network file system으로 원격 서버의 디스크를 연결할 때 사용된다. |
| ufs         | Unix file system으로 유닉스의 표준 파일 시스템이다.              |
| vfat        | 윈도우즈 95,98, NT를 지원하기 위한 파일 시스템이다.              |
| hpfs        | HPFS를 지원하기 위한 파일 시스템이다.                            |
| nfts        | 윈도우즈의 NTFS를 지원하기 위한 파일 시스템이다.                 |
| sysv        | 유닉스 시스템V를 지원하기 위한 파일 시스템이다.                  |
| hfs         | macOS의 hfs 파일 시스템을 지원하기 위한 파일 시스템이다.                                                                 |

- nfs와 samba가 있고 어느 운영체제와 네트워크 연결을 하느냐에 따라 다르다.
- fat 계열에는 fat16, fat32, fat64(exfat) 등이 있다. 파일 크기 제한이 작아서 요즘 잘 사용하지 않는다. USB 포맷에 사용한다.
- 윈도우즈에서는 주로 NTFS와 fat 계열을 사용한다.

- 리눅스의 가상 파일 시스템
	- 디스크 공간을  색다른 방식으로 사용할 때 사용

| 파일 시스템 | 기능                                                                                                                                                                     |
| ----------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| swap        | 스왑 영역을 관리하기 위한 스왑 파일 시스템이다.                                                                                                                          |
| tmpfs       | - temporary file system으로 메모리에 임시 파일을 저장하기 위한 파일 시스템이며, 시스템이 재시작 할 때마다 기존 내용이 없어진다. <br>- `/tmp` 디렉토리로 예를 들 수 있다. |
| proc        | - proc 파일 시스템으로 `/proc` 디렉토리이다. <br>- 프로세스 정보, 커널의 현재 상태를 나타내는 파일을 가지고 있다. 메모리에 임시로 저장한다.                              |
| ramfs       | 램디스크를 지원하는 파일시스템이다. 메모리를 하드디스크 처럼 사용하는 방식.                                                                                              |
| rootfs      | - root file system으로 `/` 디렉토리이다. <br>- 시스템 초기화 및 관리에 필요한 내용을 관리한다.                                                                           |
| devtmpfs    | 장비 관련 임시 파일 시스템                                                                                                                                                                         |

- `/proc/filesystems` 에 현재 커널이 지원하는 파일 시스템들이 나와있다.
```
[root@localhost test]#cat /proc/filesystems 
nodev	sysfs
nodev	rootfs
nodev	ramfs
nodev	bdev
nodev	proc
nodev	cgroup
nodev	cpuset
nodev	tmpfs
nodev	devtmpfs
nodev	debugfs
nodev	securityfs
nodev	sockfs
nodev	dax
nodev	bpf
nodev	pipefs
nodev	configfs
nodev	devpts
nodev	hugetlbfs
nodev	autofs
nodev	pstore
nodev	mqueue
nodev	selinuxfs
	fuseblk
nodev	fuse
nodev	fusectl
	xfs
nodev	rpc_pipefs
nodev	binfmt_misc
```

# 리눅스 파일 시스템의 구조
## 리눅스의 모든 파일 시스템의 기본 개념
- 파일은 inode로 관리된다.
- 디렉토리는 단순히 파일의 목록을 가지고 있는 파일일 뿐이다.
- 특수 파일을 통해 장치에 접근할 수 있다. 
## ext4 파일 시스템의 구조
- 파일시스템 전체에 대한 주요 정보는 슈퍼 블록에 저장된다.
- 효율적으로 디스크를 사용하기 위해 저장 장치를 논리적인 블록의 집합(블록 그룹)으로 구분
- 슈퍼 블록의 백업이 일부 블록 그룹에 저장된다.
- inode를 사용하여 파일의 메타정보와 데이터를 분리하여 저장한다.ㄴ
- 일반적으로 블록은 4KB이고 실제 크기는 시스템의 설정에 따라 변경 가능
- 블록 그룹 유형
	- 블록 그룹 0: 파일 시스템의 첫 번째 블록 그룹으로 특별하게 그룹 0 패딩과 슈퍼블록, 그룹 디스크립터를 가지고 있다.
	- 블록 그룹 a: 파일 시스템에서 첫 번째 블록 그룹이 아닌 블록 그룹으로 그룹 0 패딩이 없으나 슈퍼블록과 그룹 디스크립터에 대한 복사본을 가지고 있다.
	- 블록 그룹 b: 파일 시스템에서 첫 번째 블록 그룹이 아닌 블록 그룹으로 그룹 0 패딩, 슈퍼블록, 그룹 디스크립터가 없고 바로 데이터 블록 비트맵으로 시작한다.

![](images/Pasted%20image%2020230103112824.png)

### 패딩
- 블록 그룹 0의 첫 1024byte는 x86 부트섹터 등의 용도로 사용하기 위하여 패딩으로 비워져있다.

### 슈퍼블록
- 파일 시스템 전체에 대한 정보들을 저장하고 있다. 
- 파일 시스템 전체와 관련된 중요한 정보를 가지고 있기 때문에 슈퍼 블록이 손상될 경우 전체 파일 시스템의 작동에 장애가 발생한다. 따라서 중요한 데이터는 다른 블록 그룹에 백업 슈퍼 블록으로 백업된다. 그리고 이 복사본을 사용하여 복구한다.

### 그룹 디스크립터, 예약된 GDT블록
- 블록 그룹에 대한 정보를 가지고 있다.
- 예약된 GDT 블록은 그룹 디스크립터의 확장을 위해 예약된 블록이다.
- 이 정보 또한 중요하기 때문에 다른 블록 그룹에 백업된다.

### 데이터 블록 비트맵, inode 비트맵
- 비트맵은 데이터 블록/inode 용도로 지정된 블록들 중 사용 중인 블록과 사용하지 않는 블록을 체크하기 위한 영역이다.
- 각 블록의 사용여부를 체크하기 위하여 비트맵 목록에서 각 1bit씩 사용한다.

### inode 테이블
- 파일에 대한 정보를 가지고 있는 inode가 모여있는 테이블이다. 
- inode는 각각 1개의 파일 또는 디렉토리에 대한 정보를 가지고 있다.
- 파일의 종류 및 권한 정보, 파일 소유자의 UID, 파일의 크기, 파일의 접근시간, 변경시간, 수정시간, 파일의 소유그룹, 하드링크, 실제 파일 데이터가 들어있는 데이터 블록의 주소 등등

#### 포인터
- 각 inode의 데이터 블록 영역의 파일을 가리킨다.
- 직접 포인터
	- 데이터 블록의 주소를 가지고 있는 포인터
	- 파일의 크기가 작은 경우 직접포인터 만으로 파일의 데이터 블록을 전부 지정할 수 있지만, 파일의 크기가 커질 경우 간접 포인터를 사용해야한다.
- 단일 간접 포인터
	- 데이터 블록의 한 블록을 가리키고 있지만 그 데이터 블록에는 다른 블록을 가리키는 주소가 들어있다.
- 이중, 삼중 간접 포인터
	- 간접 포인터의 단계가 추가 되는 것이다. 
파일 시스템에서 사용할 수 있는 최대 파일의 크기는 리눅스 시스템의 블록의 크기에 따라 결정된다.

### 데이터 블록
- 실제 데이터가 들어있는 블록
- inode 포인터가 파일의 데이터를 가지고 있는 데이터 블록의 주소를 가지고 있다. 

## xfs 파일 시스템
- 최신 버전의 리눅스에서 기본 파일 시스템으로 사용되고 있다.
- 저널링 기능을 제공하고 저널링 기능에 의한 성능 저하 영향을 최소화하였다.
- 64bit를 지원하는 파일 시스템으로 대용량의 파일 시스템을 사용할 수 있다.
- 구조적인 특징은 다음과 같다.
	- inode를 사용한다. 내부 구조는 ext4와 다르다.
	- ext4의 블록 그룹 대신 할당 그룹(Allocation Group) 용어를 사용한다. 기본적으로 볼륨을 8개의 할당 그룹으로 분할한다. 8개 이상으로 분할할 수 있다.
	- 파일 탐색을 위해 B+ 트리를 사용한다.



### 슈퍼블록
- 전체 할당 그룹들에 대한 정보를 저장하는 용도로 사용된다.
- 첫 번째 할당 그룹의 슈퍼 블록이 사용되고 두 번째 이후 할당 그룹의 슈퍼 블록은 백업 용도로 존재하며 복구에사용된다.

### AG free block info
- 할당 그룹의 미할당 영역에 대한 정보를 가지고 있다. 
- 할당 그룹 구조의 Root of free space B+tree 항목과 연관이 있다.

### AG inode B+tree info
- 할당 그룹의 할당 영역에 대한 정보를 가지고 있다.
- 할당 그룹 구조의 Root of inode B+tree 항목과 연관이 있다.

### AG free list
- B+tree 영역을 확장하기 위하여 예약된 공간이다.

### inodes
- 할당 그룹 내 각 파일에 대한 inode의 집합이다.

### data blocks
- 실제 데이터가 저장되는 영역이다. 

## 파일 시스템 생성하기
- 파일 이스템은 이 파티션에서 파일과 디렉토리를 관리하기 위한 구조를 만드는 것
- `lsblk`(list block devices)를 통해 블록 장치와 파일시스템들을 확인할 수 있다.
### `mkfs`
- 기능: 리눅스 파일 시스템을 만든다.
- 형식: `mkfs [옵션] [장치명]`
- 옵션
	- `-t 종류`: 파일 시스템의 종류를 지정
		- `mkfs.파일시스템` 의 형태로 사용할 수도 있다. 해당 바이너리 파일들이 존재함

```
[root@localhost ~]#mkfs -t ext4 /dev/sdb1
mke2fs 1.42.9 (28-Dec-2013)
Filesystem label=
OS type: Linux
Block size=4096 (log=2)
Fragment size=4096 (log=2)
Stride=0 blocks, Stripe width=0 blocks
131072 inodes, 524288 blocks
26214 blocks (5.00%) reserved for the super user
First data block=0
Maximum filesystem blocks=536870912
16 block groups
32768 blocks per group, 32768 fragments per group
8192 inodes per group
Superblock backups stored on blocks: 
	32768, 98304, 163840, 229376, 294912

Allocating group tables: done                            
Writing inode tables: done                            
Creating journal (16384 blocks): done
Writing superblocks and filesystem accounting information: done
```

```
[root@localhost ~]#mkfs.xfs /dev/sdb4
meta-data=/dev/sdb4              isize=512    agcount=4, agsize=196608 blks
         =                       sectsz=512   attr=2, projid32bit=1
         =                       crc=1        finobt=0, sparse=0
data     =                       bsize=4096   blocks=786432, imaxpct=25
         =                       sunit=0      swidth=0 blks
naming   =version 2              bsize=4096   ascii-ci=0 ftype=1
log      =internal log           bsize=4096   blocks=2560, version=2
         =                       sectsz=512   sunit=0 blks, lazy-count=1
realtime =none                   extsz=4096   blocks=0, rtextents=0
```

- 섹터 크기, 블록 크기 등등 파일시스템이 어떻게 구성되었는지 대략적으로 확인 가능하다.

## 파일 시스템과 디렉토리 계층 구조
- 디렉토리 계층 구조는 리눅스의 전체 파일과 디렉토리를 어떤 구조로 정리하고 관리할 것인지를 정의한 것
- 실제 파일이 저장되어 있는 파일 시스템은 디렉토리 계층구조에 연결되어야 사용자가 접근 가능
### 한 파일 시스템으로 구성하기
- 디렉토리 계층 구조에서 보이는 모든 디렉토리와 파일을 하나의 파일 시스템으로 구성
### 여러 파일 시스템으로 구성하기
- 디렉토리 계층 구조를 여러 파일 시스템으로 구분하여 구성
- 여러 파일 시스템으로 나누어 디렉토리 계층 구조를 구성할 경우, 일부 파일 시스템에 문제가 생기더라도 다른 파일 시스템의 파일은 안전하다.

# 파일 시스템 마운트

## 마운트
- 파일 시스템을 디렉토리 계층 구조의 특정 디렉토리와 연결하는 것을 의미한다.
- 디렉토리 계층 구조에서 파일 시스템이 연결되는 디렉터리를 마운트 포인트라고 한다.

### 파일 시스템 마운트 설정 파일
- 리눅스에서 시스템이 부팅 될 때 자동으로 파일 시스템이 마운트 되게하려면 `/etc/fstab` 파일에 설정해야한다.
- 설정하지 않으면 다시 부팅하는 경우 마운트 되어있지 않다. 

## 마운트 관련 명령
### `mount`
- 기능: 파일 시스템을 마운트 한다.
- 형식: `mount [옵션] [장치명 또는 마운트 포인트]`
- 옵션:
	- 지정하지 않는 경우 마운트 정보를 확인할 수 있다.
	- `-t 파일 시스템 종류`: 파일 시스탬 종류를 지정한다.
	- `-o 마운트 옵션`: 마운트 옵션을 지정한다.
	- `-f`: 마운트할 수 있는지 점검만 한다.
	- `-r`: 읽기만 가능하게 마운트한다.

```
[root@localhost /]#ll /mnt/disk1
total 0
[root@localhost /]#mount /dev/sdb1 /mnt/disk1
[root@localhost /]#ll /mnt/disk1
total 16
drwx------. 2 root root 16384 Jan  3 12:11 lost+found
[root@localhost /]#touch /mnt/disk1/1234
[root@localhost /]#ll /mnt/disk1
total 16
-rw-r--r--. 1 root root     0 Jan  3 12:48 1234
drwx------. 2 root root 16384 Jan  3 12:11 lost+found
[root@localhost /]#umount /dev/sdb1
[root@localhost /]#ll /mnt/disk1
total 0
[root@localhost /]#mount /dev/sdb1 /mnt/disk4
[root@localhost /]#ll /mnt/disk4
total 16
-rw-r--r--. 1 root root     0 Jan  3 12:48 1234
drwx------. 2 root root 16384 Jan  3 12:11 lost+found
```
- 마운트 되지 않으면 정보를 확인할 수 없는 것과 다른 디렉토리에 마운트하더라도 해당 파티션에는 데이터가 계속 존재하는 것을 확인할 수 있다.

### `umount`
- 기능: 파일 시스템을 언마운트한다.
- 형식: `unmount [옵션] [장치명 또는 마운트포인트]`
- 옵션:
	- `-t 파일 시스템 종류`: 파일 시스탬 종류를 지정한다.