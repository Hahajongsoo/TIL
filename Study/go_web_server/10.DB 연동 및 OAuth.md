먼저 인터페이스를 이용해서 쉽게 전환할 수 있도록 한다. 

이후 메모리 핸들러 부분은 다른 파일로 분리한다. 이렇게 하면 원래 파일에는 인터페이스만 있게 되고 이제 이 인터페이스를 구현하는 sql 핸들러를 만들게 되면 쉽게 메모리핸들러에서 db핸들러로 교체할 수 있게 된다. 

데이터베이스를 임포트할 때에는 어떤 엔진을 사용할지 암시적으로 표기해야한다. 

데이터베이스를 열었을 때는 프로그램이 종료되기 전에 데이터베이스를 닫아줘야한다. 그래서 close 함수를 만들어준다. 하지만 이 함수의 경우 해당 패키지 내에서는 인스턴스의 생명주기를 알 수 없기 때문에 이 패키지를 사용하는 쪽에 close함수를 추가해준다. 

기존 외부로 공개하지 않던 인터페이스와 메소드를 대문자로 바꿔 외부로 공개한다. 그리고 기존 함수를 내보내던 것을 삭제하고 인터페이스 자체를 바깥으로 내보내게 한다. 이렇게 함으로써 호출한 쪽에서 인스턴스를 가지고 있다가 필요가 없어지면 Close 함수를 호출할 수 있게 책임을 외부로 넘긴다. 

app 패키지 또한 DB 사용에 대한 책임이 없기 때문에 여기서도 다시 책임을 외부로 넘겨줘야 한다. 그래서 기존 함수들을 새로 만든 핸들러의 메소드로 바꿔준다. 이때 AppHandler 는 http.Handler 를 포함하고 있다는 의미로 그냥 구조체 안에 명시한다. 상속과는 다른 개념이다. 

테스트시에는 db를 삭제해주어 새로운 db에서 테스트할 수 있도록 한다. 

Oauth 를 적용하여 로그인 페이지를 만든다. 이때 세션 정보를 저장하여 그 세션 정보를 이용하도록 한다. 

웹에서 로그인을 하는 경우 세션을 만든다. 그런데 창이 바뀌어도 로그인은 유지되어 있어야 하기 때문에 이 정보를 저장할 곳이 필요하다. 그래서 이를 쿠키에 저장한다. 즉 브라우저가 그 정보를 가지고 있고 요청을 보낼 때 같이 보낸 쿠키 정보를 가지고 로그인이 됐는지 확인한다. 

하지만 쿠키에 민감한 정보를 같이 보내면 중간에 패킷을 읽어볼 수도 있다. 따라서 이 쿠키를 보지 못하게 암호화하는 것이  필요하다. HTTP를 사용하는 경우에는 그렇다.

쿠키 스토어를 만들고 암호 키는 OS 환경 변수에서 가져와서 암호화한다. google/uuid 로 key를 만든다.  

google에서 보내주는 정보를 이용하기 위해 해당 정보 그대로 구조체를 만든다. 

이후에 인덱스 핸들러가 호출 될 때 해당 세션 정보를 읽어와야 한다.

negroni가 커스텀 미들웨어를 지원하기 때문에 로그인 데코레이터를 만들어서 negroni 에 추가한다. Use 함수를 이용한다.
classic에 recovery, log, fileserve 가 있기 때문에 fileserve 이전에 로그인 데코레이터를 사용해주기 위해서 classic은 사용할 수 없다.

Table에 세션아이디를 추가하여 세션별로 볼 수 있게 한다. 따라서 DB 테이블 스키마와 데이터를 조작하는 함수들의 인수에 세션아이디를 추가한다.

인터페이스가 바뀌었기 때문에 해당 부분을 변경해준다.

테이블에서 where 절을 통해 sessionId로 가져오는 것은 결국 리스트에서 모든 값을 하나하나 비교해서 가져오는 것과 같다. 따라서 검색 효율을 높이기 위해 인덱스를 만들어주는 것이 필요하다. 이는 bst 키 인덱스로 해결한다. 
기본키는 기본적으로 인덱스가 만들어져있어서 빠르게 될 수 있다. 다른 컬럼에 대해서는 인덱스를 만들어줘야한다. 

이렇게 바꾼 경우 기존 테스트 코드가 동작할 수 없다. 로그인 한 상태가 아니기 때문에 기존 테스트코드는 모두 될 수 없다. 하지만 여기서 로그인을 하는 동작을 하는 것은 어렵기 때문에 로그인을 했다고 치는 더미 역할이 필요하다. 그것을 목업으로 해결한다. 

로그인을 확인하는 getSessionID의 경우에는 리턴하는 것이 빈문자열이 아니면 된다. 하지만 이 함수를 수정하는 것은 원래 역할을 못하게 할 수 있으므로 위험하다.  따라서 이것을 함수 포인터를 갖는 변수로 만든다.