 
# 쿠버네티스와 클러스터 동작 방식

## 쿠버네티스가 왜 필요한가
**의문점: 수 많은 마이크로 서비스를 어떤 서버에 어떻게 배포할 것인가?**
![](images/Pasted%20image%2020221103153707.png)
- 배포해야 할 마이크로서비스가 수 백개인 경우에 사람이 처리할 수 있을까?
	- 관리하는 서비스가 적은 경우 개발서버, 운영서버를 오가면서 애플리케이션을 실행하고 관리하는 역할을 책임질 수 있을 것이다. 그러나 수많은 애플리케이션의 조합으로 서비스가 제공된다면 제대로 책임질 수 있을까?
	- 무엇보다 배포가 끝이 아니라, 컨테이너가 정말 정상적으로 동작하고 있는지 지속적으로 감시하는 역할도 포함해야 한다.
- 수 많은 마이크로서비스를 여러 서버에 효율적으로 배치하는 것은 어렵다.
	- 각각의 서버에 리소스가 충분해야만 애플리케이션을 동작시킬 수 있을 텐데 리소스를 어떻게 파악하고 관리해야하는가?
	- 개발자의 입장에서 인프라 관리까지 수행하는 것은 부담이 될 수 있다.
- 여러 서버와 마이크로서비스 배포 조합 수를 사람이 계산하는 것은 어렵다.
	- 충분한 리소스를 할당하여 해결할 수 있으나, 리소스 낭비와 불필요한 비용이 발생하게 된다.
- 어떤 서버에 어떤 서비스가 있는지를 기억하고 있어야 해당 서버에 접근할 수 있다.
	- 인지적인 부하가 많이 들기 때문에 불편할 수 있다.

### 쿠버네티스는 다음을 제공한다.
- **자동화된 빈 패킹(bin packing)**: 컨테이너화된 작업을 실행하는데 사용할 수 있는 쿠버네티스 클러스터 노드를 제공한다. 각 컨테이너가 필요로 하는 CPU와 메모리를 쿠버네티스에게 지시한다. 쿠버네티스는 컨테이너를 노드에 맞추어서 리소스를 가장 잘 사용할 수 있도록 해준다.
- **자동화된 복구(self-healing)**: 쿠버네티스는 실패한 컨테이너를 다시 시작하고, 컨테이너를 교체하며, '사용자 정의 상태 검사'에 응답하지 않는 컨테이너를 죽이고, 서비스 준비가 끝날 때까지 그러한 과정을 클라이언트에 보여주지 않는다.
- **자동화된 롤아웃과 롤백**: 쿠버네티스를 사용하여 배포된 컨테이너의 원하는 상태를 서술할 수 있으며 현재 상태를 원하는 상태로 설정한 속도에 따라 변경할 수 있다. 예를 들어 쿠버네티스를 자동화해서 배포용 새 컨테이너를 만들고, 기존 컨테이너를 제거하고, 모든 리소스를 새 컨테이너에 적용할 수 있다. 

## 쿠버네티스 히스토리
### 구글 컨테이너 관리 시스템
#### Borg
- Google에서 개발한 최초의 통합 컨테이너 관리 시스템
- 자원 요구사항 예측하여 리소스 활용도를 높이고 비용을 줄이는 방법을 제공
>컨테이너로 경량화 된 프로세스를 운영하는 것을 넘어서, 이 컨테이너를 여러 서버에 어떻게 하면 비용 효율적으로 배치할 수 있을지 를 해결
- 그 외 기능 - Configuration 파일을 실행 중인 서비스를 동적으로 반영(설정파일을 변경하더라도 애플리케이션을 재시작해야만 해당 설정이 적용되게 된다. Borg에서는 이를 동적으로 반영할 수 있도록 개발함), 서비스 디스커버리, 로드밸런싱, 자동 크기 조정 등

##### 서비스 디스커버리
- 마이크로 서비스 아키텍처에서 수 많은 애플리케이션이 예고없이 종료되거나 재시작된다.
- 애플리케이션이 실행되는 노드는 매번 바뀐다. (클라이언트가 호출하려는 서비스의 IP를 예측할 수 없다.) 
![](images/Pasted%20image%2020221103155614.png)
- 중앙에 service registry 서버를 두고 해당 서버에 마이스로서비스 주소 목록을 저장한다.
- 마이크로 서비스 인스턴스들이 레지스트리 서버로 주소를 등록하거나 제거해달라는 요청을 호출하게 된다.
	- 서비스레지스트리 서버를 최신화하는 것이 중요하므로, 인스턴스는 주기적으로 인스턴스가 살아있다는 heartbeat을 보내게 된다. 
- 서비스 레지스트리 서버는 인스턴스 주소 목록에서 해당 주소를 갱신한다.
- 마이크로서비스 클라이언트는 주기적으로 레지스트리 최신화된 목록을 요청하고 이후 마이크로서비스 인스턴스와 통신한다.

#### Omega
- 클러스터 상태의 일관성을 부여하기 위해 클러스터 상태 저장 기능을 추가 - 영구 저장소(어떤 방식으로 컨테이너를 배포하겠다는 것을 시스템에 요청했다면, 그러한 정보들을 저장해놓을 수 있고 다른 사람이 해당 상태를 변경하고자 했을 때 애플리케이션의 상태를 어떻게 관리할 것인가에 대한 고민)
- 낙관적 동시성 제어 방법을 이용해서 리소스 충돌을 해결한다.

##### 낙관적 동시성 제어
![](images/Pasted%20image%2020221103160429.png)
- 쿠버네티스에서는 리소스버전을 이용해서 리소스 충돌을 해결하고 있다.
- 서로 다른 사용자가 같은 버전의 리소스를 조회 > 둘 다 리소스를 변경 > 2가 변경 내용으로 배포 > 1은 변경 내용 반영하려고 하면 쿠버네티스는 거부하게 된다.
	- 이전에 조회했던 리소스의 버전과 현재 쿠버네티스에 기록되어 있는 상태 버전이 다르기 때문이다. 
	- 리소스를 조회하거나 변경하는데 락을 거는 대신에, 리소스 버전을 통해서 쿠버네티스 상태 일관성을 유지할 수 있도록 제어한다.

#### Kubernetes
- Borg, Omega 와 달리 오픈소스이다.
- 구글 퍼블릭 클라우드 인프라 사업을 성장시키기 위해 설계하고 개발함
- Omega처럼 리소스 변경 사항을 저장하기 위한 공유 영구 저장소가 있지만, Omega는 이 저장소를 신뢰할 수 있는 구성요소들이 직접 접근할 수 있도록 개방한 것과 달리, 쿠버네티스는 더 높은 수준의 추상화를 위해 REST API를 통해서만 접근할 수 있도록 바꾸었다.
- 더 중요한 것은 쿠버네티스가 클러스터에서 실행되는 애플리케이션을 개발하는 개발자의 경험에 더 중점을 두고 개발했다는 점이다.
- 주요 설계 목표는 컨테이너로 향상된 리소스 활용의 이점을 누리면서도 복잡한 분산 시스템을 쉽게 배포하고 관리할 수 있게 만드는 것이었다.

##### 쿠버네티스 이름의 의미
- 조타수: 주어진 명령을 핸들에 반복 실행해야한다.
	- 개발자/운영자: 명령을 내리는 사람
		- 해당 명령을 내리기위한 자세한 내용을 담은 명세 파일을 작성해야한다.
	- 쿠버네티스: 해당 명령을 정상적으로 실행
		- 해당 명령을 REST API로 전달하게 되면 쿠버네티스가 자신이 관리하고 있는 여러개의 서버의 리소스를 예측해서 적절한 서버를 선택하고 그 서버에 이 애플리케이션을 배포해서 컨테이너로 실행시켜주는 역할을 한다.
- 쿠버네티스는 여러 개의 컨테이너화 된 애플리케이션을 여러 서버(쿠버네티스 클러스터)에 자동으로 배포, 스케일링 및 관리해주는 오픈소스 시스템이다.

## 쿠버네티스 클러스터
- 클러스터 : 여러 개의 서버를 하나로 묶은 집합, 하나의 서버처럼 동작
- 쿠버네티스 클러스터: 애플리케이션 컨테이너를 배포하기 위한 서버 집합
	- master node 와 worker 노드로 구성된다.
### Master node 의 Control Plane
- 마스터 노드는 클러스터의 상태를 저장하고 관리하기 위한 컴포넌트들이 속해있는 서버이다.
- etcd(key-value data store): 클러스터에 배포된 애플리케이션 실행 정보를 저장
- APKI Server: 클러스터 상태 조회, 변경을 위한 API 인터페이스 제공
	- 외부에서 들어오는 API나 내부에서 다른 컴포넌트들이 요청하는 API들도 이 API server가 수신하고 있다.
- Scheduler: 노드를 선택하기 위한 노드 스케쥴링 수행
- Controller Managers: 실제로 사용자가 요청한 컨테이너의 개수나 상태들이 현재 잘 운영되고 있는지 감시하고 일치하지 않는다면 API 서버에 추가적인 리소스를 요청하는 역할을 한다.

### Worker node
- 컨테이너의 실행을 담당하는 서비스
- Kubelet 이라는 프로세스가 실행되고 있다.
- 컨테이너를 실행하기 위한 Container Runtime 들이 있다. (Docker, ...)
- kube-proxy : 워커 노드로 들어오는 트래픽을 파드로 전달하기 위한 프로세스

### 쿠버네티스에 '애플리케이션 컨테이너를 배포한다' 란?
- 쿠버네티스 오브젝트 Manifest 파일을 작성해서 마스터 노드에 있는 API Server에게 요청을 보내는 행위
- Menifest 파일이란?
	- 쿠버네티스 오브젝트를 생성하기 위한 필수 정보
	- "일을 시키기 위한 지시서"

### API Server를 통한 협력(like 옵저버 패턴)
> 단언할 수는 없지만 옵저버 패턴을 사용하는 것 같다고 함. 옵저버 패턴이란, 구독하고자 하는 이벤트를 중앙장치에 등록을 해놓고 이벤트가 발생할 때 마다 이벤트의 알람을 받는 형태이다. API 서버와 다른 마스터노드에 있는 컴포넌트들도 이벤트 기반으로 동작을 하고 있다.

그렇다면 중요한 것은 API 서버의 역할을 보는 것이다. 과연 API 서버가 다른 마스터 노드에 있는 컴포넌트들과 어떻게 협업하는가? 어떻게 우리 명령을 받아서 각각의 노드에 애플리케이션을 배포하는 것을 자동화 하는가?
- 내부적으로는 API 서버를 중심으로 마스터노드에 있는 컨트롤러 매니저, 스케쥴러, etcd, 워커노드에 있는 kubelet 이 협력해서 요청을 실행하고 최종적으로는 노드에 애플리케이션을 배포한다.
![](images/Pasted%20image%2020221103163252.png)
- kubectl 이라는 인터페이스로 주로 작업을 하게 된다. 해당 명령어는 실제로는 `HTTP POST` Request로 변환이 된다.
- 해당 요청을 받은 API 서버는 해당 요청을 etcd(영구저장소)에 상태를 저장하게 된다.
- 특정 이벤트들에 대해서 구독을 하겠다 라고 이미 설정이 되어 있다. 쿠버네티스 클러스터를 구성하면서 자동으로 구성이 될 것임
- Controller Manager라는 컴포넌트가 `신규 리소스 요청` 이라는 이벤트를 받게 된다. 그러면 컨트롤러가 추가 리소스 생성하는 요청을 API 서버에 보내게 된다. etcd에 상태 저장
- API 서버는 파드 생성 요청을 받게 되고 파드에 대한 설정 정보를 etcd에 저장한다. 
- 스케쥴러는 이벤트를 받아 노드에 배포되지 않은 파드를 읽어오게 된다. 이후 노드의 상태와 파드에서 필요한 리소스를 체크해서 해당 리소스를 가지고 있는 최적의 노드를 선택하게 된다.
- 노드 정보를 파드 정보에 추가해서 API 서버에 전송을 한다. etcd에 상태 저장
- 해당 노드의 kubelet 이라는 프로세스는 예약된 리소스가 있다는 이벤트를 받게 되고, 컨테이너 런타임에 컨테이너 실행을 위임하게 된다. 이후 컨테이너 런타임은 컨테이너를 실행하게 된다.
- kubelet은 이후 실행되어있는 컨테이너 상태를 체크, 재시작 하기위한 책임을 갖게 된다. 컨테이너 실행 상태를 API 서버에 전송한다. api 서버는 etcd에 저장

### kube-proxy와 iptables를 이용한 통신 방법
트래픽이 어떻게 전달 되는가?
![](images/Pasted%20image%2020221103164919.png)
- 각각의 워크 노드에는 kube-proxy 들이 실행되고 있다.
- 예를 들어 API 서버를 통해서 리소스 엔드포인트가 추가 되었다. 어떤 파드의 ip들이 할당이 될 것이고 할당된 정보가 추가가 되면 kube-proxy가 해당 정보를 감시를 해서 워커노드에 있는 iptable을 업데이트하게 된다. 워커노드로 새로운 트래픽이 들어오게 되면 해당 클라이언트 요청을 목적지로 연결하는 역할을 제공한다.
- 목적지 번호를 패킷에 위 처럼 적었을 때, 실제로 전송되기 전에 커널에서 iptable 을 참조해서 목적지를 변경하는 작업을 하게 된다.
- 위의 경우 두 개의 엔드포인트가 있는 것이고, 임의적으로 하나를 선택해서 라우팅을 하게 된다. 실제로 패킷이 전달 될때에는 0.231로 변경될 것이고 해당 파드가 요청을 받게 될 것이다.
- 즉, kube-proxy와 iptable을 이용해서 해당 워커 노드로 들어온 요청들을 다른 파드로 보내게 된다.

# 쿠버네티스 오브젝트
## 쿠버네티스 오브젝트 개념
- 쿠버네티스로 애플리케이션을 배포하고 관리한다.
	- 어떤 어플리케이션을 얼마나 어디에 어떤 방식으로 배포할 것인가. 에 대한 의도를 담는 것을 말한다. 해당 의도를 담아서 manifest 파일을 작성한다.
- 사용자 의도를 어떻게  표현하는가?
	- 의도를 정의하는 방법: 쿠버네티스 오브젝트로 정의하고 오브젝트 종류에 따라 정의할 수 있는 속성이 달라진다.
	- 표현 방식 : YAML 형식
	- 전달 방식: REST API
- 쿠버네티스 오브젝트는 클러스터 상태를 결정한다.
	- 오브젝트는 내가 의도한 바를 작성한 것이고 이것은 결국 컨테이너 배포가 어떻게 이루어지는지에 대한 것을 정의한 것이기 때문에 쿠버네티스 오브젝트가 클러스터 상태가 결정될 수 밖에 없다. 따라서 사용자가 어떻게 쿠버네티스 오브젝트를 정의하느냐에 따라 쿠버네티스 상태가 결정된다.
	- 즉 쿠버네티스 오브젝트를 이용하여 개발팀의 구조, 배포 정책, 프로세스를 표현할 수 있다.

## 쿠버네티스 오브젝트란
쿠버네티스 클러스터를 이용해 애플리케이션을 배포하고 운영하기 위해 필요한 모든 쿠버네티스 리소스

### 쿠버네티스 오브젝트가 될 수 있는 것
- 어떤 애플리케이션을 : Pod
- 얼마나 : ReplicaSet
- 어디에: Node, Namespace
- 어떤 방식으로 배포할 것인가: Deployment
- 트래픽을 어떻게 로드밸런싱 할 것인가: Service, Endpoints
![](images/Pasted%20image%2020221104143729.png)

## 쿠버네티스 오브젝트 표현 방법

### 우리의 의도를 담는 spec 필드
- 오브젝트 기본 정보(필수값)
	- apiVersion: 오브젝트를 생성할 때 사용하는 API 버전
	- kind: 생성하고자 하는 오브젝트 종류
	- metadata: 오브젝트를 구분 지을 수 있는 정보
		- name, resourceVersion, labels, namespace
	- spec: 사용자가 원하는 오브젝트 상태
		- 선언할 수 있는 속성은 오브젝트 종류마다 다르다.

### 쿠버네티스가 오브젝트 상태를 알려주는 status 필드
오브젝트가 쿠버네티스 클러스터에 생성되면 쿠버네티스는 오브젝트 정보에 status 필드를 추가하고 현재 실행중인 오브젝트의 상태 정보를 알려준다.

## 쿠버네티스가 하는 일
spec 과 status가 항상 일치되도록 유지하는 일을 수행한다. 즉 쿠버네티스가 달성해야 할 목표 와 오브젝트의 현재 상태가 일치되도록 한다. 쿠버네티스가 현재 상태를 사용자가 정의한 spec에 도달할 수 있게끔 계속 조절하는 일을 한다.

# kubectl 명령어 맛보기
- `kubectl api-resources`
	- 쿠버네티스 클러스터에서 사용할 수 있는 오브젝트 목록 조회
	- ![](images/Pasted%20image%2020221104151337.png)

- `kubectl expain <type>`
	- 쿠버네티스 오브젝트의 설명과 1레벨 속성들의 설명
	- apiVersion, kind, metadata, spec, status
	- ![](images/Pasted%20image%2020221104151419.png)

- `kubectl explain <type>.<filedName>[.<filedName>]`
	- kubectl explain pods.spec.containers
	- 쿠버네티스 오브젝트 속성들의 구체적인 설명(Json 경로)
	- ![](images/Pasted%20image%2020221104151659.png)

- `kubectl get nodes`
	- 쿠버네티스 클러스터에서 속한 노드 목록 조회
- `kubectl apply -f <object-file-name>`
	- `kubectl apply -f deployment.yaml`
	- 쿠버네티스 오브젝트 생성/변경
- `kubectl get pods`
	- 실행 중인 Pod 목록 조회
- `kubectl scale -f <object-file-name> --replicas=#`
	- 애플리케이션 배포 개수를 조정
- `kubectl diff -f <object-file-name>`
	- 현재 실행 중인 오브젝트 설정과 입력한 파일의 차이점 분석
	- ![](images/Pasted%20image%2020221104152452.png)

- `kubectl edit <type>/<name>`
	- 쿠버네티스 오브젝트의 spec을 editor로 편집
- `kubectl port-forward <type>/<name><local-port>:<container-port>`
	- 로컬 포트를 파드에서 실행 중인 컨테이너 포트로 포워딩
- `kubectl attach <type>/<name> -c <container-name>`
	- 현재 실행중인 컨테이너 프로세스에 접속하여 로그 확인
- `kubectl logs <type>/<name> -c <container-name> -f`
	- 현재 실행중인 컨테이너 프로세스에 모든 로그 출력